"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/history";
exports.ids = ["vendor-chunks/history"];
exports.modules = {

/***/ "(ssr)/./node_modules/history/index.js":
/*!***************************************!*\
  !*** ./node_modules/history/index.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Action: () => (/* binding */ Action),\n/* harmony export */   createBrowserHistory: () => (/* binding */ createBrowserHistory),\n/* harmony export */   createHashHistory: () => (/* binding */ createHashHistory),\n/* harmony export */   createMemoryHistory: () => (/* binding */ createMemoryHistory),\n/* harmony export */   createPath: () => (/* binding */ createPath),\n/* harmony export */   parsePath: () => (/* binding */ parsePath)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ \"(ssr)/./node_modules/@babel/runtime/helpers/esm/extends.js\");\n\n/**\r\n * Actions represent the type of change to a location value.\r\n *\r\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#action\r\n */ var Action;\n(function(Action) {\n    /**\r\n   * A POP indicates a change to an arbitrary index in the history stack, such\r\n   * as a back or forward navigation. It does not describe the direction of the\r\n   * navigation, only that the current index changed.\r\n   *\r\n   * Note: This is the default action for newly created history objects.\r\n   */ Action[\"Pop\"] = \"POP\";\n    /**\r\n   * A PUSH indicates a new entry being added to the history stack, such as when\r\n   * a link is clicked and a new page loads. When this happens, all subsequent\r\n   * entries in the stack are lost.\r\n   */ Action[\"Push\"] = \"PUSH\";\n    /**\r\n   * A REPLACE indicates the entry at the current index in the history stack\r\n   * being replaced by a new one.\r\n   */ Action[\"Replace\"] = \"REPLACE\";\n})(Action || (Action = {}));\nvar readOnly =  true ? function(obj) {\n    return Object.freeze(obj);\n} : 0;\nfunction warning(cond, message) {\n    if (!cond) {\n        // eslint-disable-next-line no-console\n        if (typeof console !== \"undefined\") console.warn(message);\n        try {\n            // Welcome to debugging history!\n            //\n            // This error is thrown as a convenience so you can more easily\n            // find the source for a warning that appears in the console by\n            // enabling \"pause on exceptions\" in your JavaScript debugger.\n            throw new Error(message); // eslint-disable-next-line no-empty\n        } catch (e) {}\n    }\n}\nvar BeforeUnloadEventType = \"beforeunload\";\nvar HashChangeEventType = \"hashchange\";\nvar PopStateEventType = \"popstate\";\n/**\r\n * Browser history stores the location in regular URLs. This is the standard for\r\n * most web apps, but it requires some configuration on the server to ensure you\r\n * serve the same app at multiple URLs.\r\n *\r\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createbrowserhistory\r\n */ function createBrowserHistory(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    var _options = options, _options$window = _options.window, window = _options$window === void 0 ? document.defaultView : _options$window;\n    var globalHistory = window.history;\n    function getIndexAndLocation() {\n        var _window$location = window.location, pathname = _window$location.pathname, search = _window$location.search, hash = _window$location.hash;\n        var state = globalHistory.state || {};\n        return [\n            state.idx,\n            readOnly({\n                pathname: pathname,\n                search: search,\n                hash: hash,\n                state: state.usr || null,\n                key: state.key || \"default\"\n            })\n        ];\n    }\n    var blockedPopTx = null;\n    function handlePop() {\n        if (blockedPopTx) {\n            blockers.call(blockedPopTx);\n            blockedPopTx = null;\n        } else {\n            var nextAction = Action.Pop;\n            var _getIndexAndLocation = getIndexAndLocation(), nextIndex = _getIndexAndLocation[0], nextLocation = _getIndexAndLocation[1];\n            if (blockers.length) {\n                if (nextIndex != null) {\n                    var delta = index - nextIndex;\n                    if (delta) {\n                        // Revert the POP\n                        blockedPopTx = {\n                            action: nextAction,\n                            location: nextLocation,\n                            retry: function retry() {\n                                go(delta * -1);\n                            }\n                        };\n                        go(delta);\n                    }\n                } else {\n                    // Trying to POP to a location with no index. We did not create\n                    // this location, so we can't effectively block the navigation.\n                     true ? warning(false, // detail and link to it here so people can understand better what\n                    // is going on and how to avoid it.\n                    \"You are trying to block a POP navigation to a location that was not \" + \"created by the history library. The block will fail silently in \" + \"production, but in general you should do all navigation with the \" + \"history library (instead of using window.history.pushState directly) \" + \"to avoid this situation.\") : 0;\n                }\n            } else {\n                applyTx(nextAction);\n            }\n        }\n    }\n    window.addEventListener(PopStateEventType, handlePop);\n    var action = Action.Pop;\n    var _getIndexAndLocation2 = getIndexAndLocation(), index = _getIndexAndLocation2[0], location = _getIndexAndLocation2[1];\n    var listeners = createEvents();\n    var blockers = createEvents();\n    if (index == null) {\n        index = 0;\n        globalHistory.replaceState((0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, globalHistory.state, {\n            idx: index\n        }), \"\");\n    }\n    function createHref(to) {\n        return typeof to === \"string\" ? to : createPath(to);\n    } // state defaults to `null` because `window.history.state` does\n    function getNextLocation(to, state) {\n        if (state === void 0) {\n            state = null;\n        }\n        return readOnly((0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n            pathname: location.pathname,\n            hash: \"\",\n            search: \"\"\n        }, typeof to === \"string\" ? parsePath(to) : to, {\n            state: state,\n            key: createKey()\n        }));\n    }\n    function getHistoryStateAndUrl(nextLocation, index) {\n        return [\n            {\n                usr: nextLocation.state,\n                key: nextLocation.key,\n                idx: index\n            },\n            createHref(nextLocation)\n        ];\n    }\n    function allowTx(action, location, retry) {\n        return !blockers.length || (blockers.call({\n            action: action,\n            location: location,\n            retry: retry\n        }), false);\n    }\n    function applyTx(nextAction) {\n        action = nextAction;\n        var _getIndexAndLocation3 = getIndexAndLocation();\n        index = _getIndexAndLocation3[0];\n        location = _getIndexAndLocation3[1];\n        listeners.call({\n            action: action,\n            location: location\n        });\n    }\n    function push(to, state) {\n        var nextAction = Action.Push;\n        var nextLocation = getNextLocation(to, state);\n        function retry() {\n            push(to, state);\n        }\n        if (allowTx(nextAction, nextLocation, retry)) {\n            var _getHistoryStateAndUr = getHistoryStateAndUrl(nextLocation, index + 1), historyState = _getHistoryStateAndUr[0], url = _getHistoryStateAndUr[1]; // TODO: Support forced reloading\n            // try...catch because iOS limits us to 100 pushState calls :/\n            try {\n                globalHistory.pushState(historyState, \"\", url);\n            } catch (error) {\n                // They are going to lose state here, but there is no real\n                // way to warn them about it since the page will refresh...\n                window.location.assign(url);\n            }\n            applyTx(nextAction);\n        }\n    }\n    function replace(to, state) {\n        var nextAction = Action.Replace;\n        var nextLocation = getNextLocation(to, state);\n        function retry() {\n            replace(to, state);\n        }\n        if (allowTx(nextAction, nextLocation, retry)) {\n            var _getHistoryStateAndUr2 = getHistoryStateAndUrl(nextLocation, index), historyState = _getHistoryStateAndUr2[0], url = _getHistoryStateAndUr2[1]; // TODO: Support forced reloading\n            globalHistory.replaceState(historyState, \"\", url);\n            applyTx(nextAction);\n        }\n    }\n    function go(delta) {\n        globalHistory.go(delta);\n    }\n    var history = {\n        get action () {\n            return action;\n        },\n        get location () {\n            return location;\n        },\n        createHref: createHref,\n        push: push,\n        replace: replace,\n        go: go,\n        back: function back() {\n            go(-1);\n        },\n        forward: function forward() {\n            go(1);\n        },\n        listen: function listen(listener) {\n            return listeners.push(listener);\n        },\n        block: function block(blocker) {\n            var unblock = blockers.push(blocker);\n            if (blockers.length === 1) {\n                window.addEventListener(BeforeUnloadEventType, promptBeforeUnload);\n            }\n            return function() {\n                unblock(); // Remove the beforeunload listener so the document may\n                // still be salvageable in the pagehide event.\n                // See https://html.spec.whatwg.org/#unloading-documents\n                if (!blockers.length) {\n                    window.removeEventListener(BeforeUnloadEventType, promptBeforeUnload);\n                }\n            };\n        }\n    };\n    return history;\n}\n/**\r\n * Hash history stores the location in window.location.hash. This makes it ideal\r\n * for situations where you don't want to send the location to the server for\r\n * some reason, either because you do cannot configure it or the URL space is\r\n * reserved for something else.\r\n *\r\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createhashhistory\r\n */ function createHashHistory(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    var _options2 = options, _options2$window = _options2.window, window = _options2$window === void 0 ? document.defaultView : _options2$window;\n    var globalHistory = window.history;\n    function getIndexAndLocation() {\n        var _parsePath = parsePath(window.location.hash.substr(1)), _parsePath$pathname = _parsePath.pathname, pathname = _parsePath$pathname === void 0 ? \"/\" : _parsePath$pathname, _parsePath$search = _parsePath.search, search = _parsePath$search === void 0 ? \"\" : _parsePath$search, _parsePath$hash = _parsePath.hash, hash = _parsePath$hash === void 0 ? \"\" : _parsePath$hash;\n        var state = globalHistory.state || {};\n        return [\n            state.idx,\n            readOnly({\n                pathname: pathname,\n                search: search,\n                hash: hash,\n                state: state.usr || null,\n                key: state.key || \"default\"\n            })\n        ];\n    }\n    var blockedPopTx = null;\n    function handlePop() {\n        if (blockedPopTx) {\n            blockers.call(blockedPopTx);\n            blockedPopTx = null;\n        } else {\n            var nextAction = Action.Pop;\n            var _getIndexAndLocation4 = getIndexAndLocation(), nextIndex = _getIndexAndLocation4[0], nextLocation = _getIndexAndLocation4[1];\n            if (blockers.length) {\n                if (nextIndex != null) {\n                    var delta = index - nextIndex;\n                    if (delta) {\n                        // Revert the POP\n                        blockedPopTx = {\n                            action: nextAction,\n                            location: nextLocation,\n                            retry: function retry() {\n                                go(delta * -1);\n                            }\n                        };\n                        go(delta);\n                    }\n                } else {\n                    // Trying to POP to a location with no index. We did not create\n                    // this location, so we can't effectively block the navigation.\n                     true ? warning(false, // detail and link to it here so people can understand better\n                    // what is going on and how to avoid it.\n                    \"You are trying to block a POP navigation to a location that was not \" + \"created by the history library. The block will fail silently in \" + \"production, but in general you should do all navigation with the \" + \"history library (instead of using window.history.pushState directly) \" + \"to avoid this situation.\") : 0;\n                }\n            } else {\n                applyTx(nextAction);\n            }\n        }\n    }\n    window.addEventListener(PopStateEventType, handlePop); // popstate does not fire on hashchange in IE 11 and old (trident) Edge\n    // https://developer.mozilla.org/de/docs/Web/API/Window/popstate_event\n    window.addEventListener(HashChangeEventType, function() {\n        var _getIndexAndLocation5 = getIndexAndLocation(), nextLocation = _getIndexAndLocation5[1]; // Ignore extraneous hashchange events.\n        if (createPath(nextLocation) !== createPath(location)) {\n            handlePop();\n        }\n    });\n    var action = Action.Pop;\n    var _getIndexAndLocation6 = getIndexAndLocation(), index = _getIndexAndLocation6[0], location = _getIndexAndLocation6[1];\n    var listeners = createEvents();\n    var blockers = createEvents();\n    if (index == null) {\n        index = 0;\n        globalHistory.replaceState((0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, globalHistory.state, {\n            idx: index\n        }), \"\");\n    }\n    function getBaseHref() {\n        var base = document.querySelector(\"base\");\n        var href = \"\";\n        if (base && base.getAttribute(\"href\")) {\n            var url = window.location.href;\n            var hashIndex = url.indexOf(\"#\");\n            href = hashIndex === -1 ? url : url.slice(0, hashIndex);\n        }\n        return href;\n    }\n    function createHref(to) {\n        return getBaseHref() + \"#\" + (typeof to === \"string\" ? to : createPath(to));\n    }\n    function getNextLocation(to, state) {\n        if (state === void 0) {\n            state = null;\n        }\n        return readOnly((0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n            pathname: location.pathname,\n            hash: \"\",\n            search: \"\"\n        }, typeof to === \"string\" ? parsePath(to) : to, {\n            state: state,\n            key: createKey()\n        }));\n    }\n    function getHistoryStateAndUrl(nextLocation, index) {\n        return [\n            {\n                usr: nextLocation.state,\n                key: nextLocation.key,\n                idx: index\n            },\n            createHref(nextLocation)\n        ];\n    }\n    function allowTx(action, location, retry) {\n        return !blockers.length || (blockers.call({\n            action: action,\n            location: location,\n            retry: retry\n        }), false);\n    }\n    function applyTx(nextAction) {\n        action = nextAction;\n        var _getIndexAndLocation7 = getIndexAndLocation();\n        index = _getIndexAndLocation7[0];\n        location = _getIndexAndLocation7[1];\n        listeners.call({\n            action: action,\n            location: location\n        });\n    }\n    function push(to, state) {\n        var nextAction = Action.Push;\n        var nextLocation = getNextLocation(to, state);\n        function retry() {\n            push(to, state);\n        }\n         true ? warning(nextLocation.pathname.charAt(0) === \"/\", \"Relative pathnames are not supported in hash history.push(\" + JSON.stringify(to) + \")\") : 0;\n        if (allowTx(nextAction, nextLocation, retry)) {\n            var _getHistoryStateAndUr3 = getHistoryStateAndUrl(nextLocation, index + 1), historyState = _getHistoryStateAndUr3[0], url = _getHistoryStateAndUr3[1]; // TODO: Support forced reloading\n            // try...catch because iOS limits us to 100 pushState calls :/\n            try {\n                globalHistory.pushState(historyState, \"\", url);\n            } catch (error) {\n                // They are going to lose state here, but there is no real\n                // way to warn them about it since the page will refresh...\n                window.location.assign(url);\n            }\n            applyTx(nextAction);\n        }\n    }\n    function replace(to, state) {\n        var nextAction = Action.Replace;\n        var nextLocation = getNextLocation(to, state);\n        function retry() {\n            replace(to, state);\n        }\n         true ? warning(nextLocation.pathname.charAt(0) === \"/\", \"Relative pathnames are not supported in hash history.replace(\" + JSON.stringify(to) + \")\") : 0;\n        if (allowTx(nextAction, nextLocation, retry)) {\n            var _getHistoryStateAndUr4 = getHistoryStateAndUrl(nextLocation, index), historyState = _getHistoryStateAndUr4[0], url = _getHistoryStateAndUr4[1]; // TODO: Support forced reloading\n            globalHistory.replaceState(historyState, \"\", url);\n            applyTx(nextAction);\n        }\n    }\n    function go(delta) {\n        globalHistory.go(delta);\n    }\n    var history = {\n        get action () {\n            return action;\n        },\n        get location () {\n            return location;\n        },\n        createHref: createHref,\n        push: push,\n        replace: replace,\n        go: go,\n        back: function back() {\n            go(-1);\n        },\n        forward: function forward() {\n            go(1);\n        },\n        listen: function listen(listener) {\n            return listeners.push(listener);\n        },\n        block: function block(blocker) {\n            var unblock = blockers.push(blocker);\n            if (blockers.length === 1) {\n                window.addEventListener(BeforeUnloadEventType, promptBeforeUnload);\n            }\n            return function() {\n                unblock(); // Remove the beforeunload listener so the document may\n                // still be salvageable in the pagehide event.\n                // See https://html.spec.whatwg.org/#unloading-documents\n                if (!blockers.length) {\n                    window.removeEventListener(BeforeUnloadEventType, promptBeforeUnload);\n                }\n            };\n        }\n    };\n    return history;\n}\n/**\r\n * Memory history stores the current location in memory. It is designed for use\r\n * in stateful non-browser environments like tests and React Native.\r\n *\r\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#creatememoryhistory\r\n */ function createMemoryHistory(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    var _options3 = options, _options3$initialEntr = _options3.initialEntries, initialEntries = _options3$initialEntr === void 0 ? [\n        \"/\"\n    ] : _options3$initialEntr, initialIndex = _options3.initialIndex;\n    var entries = initialEntries.map(function(entry) {\n        var location = readOnly((0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n            pathname: \"/\",\n            search: \"\",\n            hash: \"\",\n            state: null,\n            key: createKey()\n        }, typeof entry === \"string\" ? parsePath(entry) : entry));\n         true ? warning(location.pathname.charAt(0) === \"/\", \"Relative pathnames are not supported in createMemoryHistory({ initialEntries }) (invalid entry: \" + JSON.stringify(entry) + \")\") : 0;\n        return location;\n    });\n    var index = clamp(initialIndex == null ? entries.length - 1 : initialIndex, 0, entries.length - 1);\n    var action = Action.Pop;\n    var location = entries[index];\n    var listeners = createEvents();\n    var blockers = createEvents();\n    function createHref(to) {\n        return typeof to === \"string\" ? to : createPath(to);\n    }\n    function getNextLocation(to, state) {\n        if (state === void 0) {\n            state = null;\n        }\n        return readOnly((0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n            pathname: location.pathname,\n            search: \"\",\n            hash: \"\"\n        }, typeof to === \"string\" ? parsePath(to) : to, {\n            state: state,\n            key: createKey()\n        }));\n    }\n    function allowTx(action, location, retry) {\n        return !blockers.length || (blockers.call({\n            action: action,\n            location: location,\n            retry: retry\n        }), false);\n    }\n    function applyTx(nextAction, nextLocation) {\n        action = nextAction;\n        location = nextLocation;\n        listeners.call({\n            action: action,\n            location: location\n        });\n    }\n    function push(to, state) {\n        var nextAction = Action.Push;\n        var nextLocation = getNextLocation(to, state);\n        function retry() {\n            push(to, state);\n        }\n         true ? warning(location.pathname.charAt(0) === \"/\", \"Relative pathnames are not supported in memory history.push(\" + JSON.stringify(to) + \")\") : 0;\n        if (allowTx(nextAction, nextLocation, retry)) {\n            index += 1;\n            entries.splice(index, entries.length, nextLocation);\n            applyTx(nextAction, nextLocation);\n        }\n    }\n    function replace(to, state) {\n        var nextAction = Action.Replace;\n        var nextLocation = getNextLocation(to, state);\n        function retry() {\n            replace(to, state);\n        }\n         true ? warning(location.pathname.charAt(0) === \"/\", \"Relative pathnames are not supported in memory history.replace(\" + JSON.stringify(to) + \")\") : 0;\n        if (allowTx(nextAction, nextLocation, retry)) {\n            entries[index] = nextLocation;\n            applyTx(nextAction, nextLocation);\n        }\n    }\n    function go(delta) {\n        var nextIndex = clamp(index + delta, 0, entries.length - 1);\n        var nextAction = Action.Pop;\n        var nextLocation = entries[nextIndex];\n        function retry() {\n            go(delta);\n        }\n        if (allowTx(nextAction, nextLocation, retry)) {\n            index = nextIndex;\n            applyTx(nextAction, nextLocation);\n        }\n    }\n    var history = {\n        get index () {\n            return index;\n        },\n        get action () {\n            return action;\n        },\n        get location () {\n            return location;\n        },\n        createHref: createHref,\n        push: push,\n        replace: replace,\n        go: go,\n        back: function back() {\n            go(-1);\n        },\n        forward: function forward() {\n            go(1);\n        },\n        listen: function listen(listener) {\n            return listeners.push(listener);\n        },\n        block: function block(blocker) {\n            return blockers.push(blocker);\n        }\n    };\n    return history;\n} ////////////////////////////////////////////////////////////////////////////////\n// UTILS\n////////////////////////////////////////////////////////////////////////////////\nfunction clamp(n, lowerBound, upperBound) {\n    return Math.min(Math.max(n, lowerBound), upperBound);\n}\nfunction promptBeforeUnload(event) {\n    // Cancel the event.\n    event.preventDefault(); // Chrome (and legacy IE) requires returnValue to be set.\n    event.returnValue = \"\";\n}\nfunction createEvents() {\n    var handlers = [];\n    return {\n        get length () {\n            return handlers.length;\n        },\n        push: function push(fn) {\n            handlers.push(fn);\n            return function() {\n                handlers = handlers.filter(function(handler) {\n                    return handler !== fn;\n                });\n            };\n        },\n        call: function call(arg) {\n            handlers.forEach(function(fn) {\n                return fn && fn(arg);\n            });\n        }\n    };\n}\nfunction createKey() {\n    return Math.random().toString(36).substr(2, 8);\n}\n/**\r\n * Creates a string URL path from the given pathname, search, and hash components.\r\n *\r\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createpath\r\n */ function createPath(_ref) {\n    var _ref$pathname = _ref.pathname, pathname = _ref$pathname === void 0 ? \"/\" : _ref$pathname, _ref$search = _ref.search, search = _ref$search === void 0 ? \"\" : _ref$search, _ref$hash = _ref.hash, hash = _ref$hash === void 0 ? \"\" : _ref$hash;\n    if (search && search !== \"?\") pathname += search.charAt(0) === \"?\" ? search : \"?\" + search;\n    if (hash && hash !== \"#\") pathname += hash.charAt(0) === \"#\" ? hash : \"#\" + hash;\n    return pathname;\n}\n/**\r\n * Parses a string URL path into its separate pathname, search, and hash components.\r\n *\r\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#parsepath\r\n */ function parsePath(path) {\n    var parsedPath = {};\n    if (path) {\n        var hashIndex = path.indexOf(\"#\");\n        if (hashIndex >= 0) {\n            parsedPath.hash = path.substr(hashIndex);\n            path = path.substr(0, hashIndex);\n        }\n        var searchIndex = path.indexOf(\"?\");\n        if (searchIndex >= 0) {\n            parsedPath.search = path.substr(searchIndex);\n            path = path.substr(0, searchIndex);\n        }\n        if (path) {\n            parsedPath.pathname = path;\n        }\n    }\n    return parsedPath;\n}\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LFNBQVMsS0FBS0YsWUFBWUUsS0FBSzJFLE1BQU0sQ0FBQyxPQUFPLE1BQU0zRSxPQUFPLE1BQU1BO0lBQzVFLE9BQU9GO0FBQ1Q7QUFDQTs7OztDQUlDLEdBRUQsU0FBU2dDLFVBQVVpRixJQUFJO0lBQ3JCLElBQUlDLGFBQWEsQ0FBQztJQUVsQixJQUFJRCxNQUFNO1FBQ1IsSUFBSXhDLFlBQVl3QyxLQUFLdkMsT0FBTyxDQUFDO1FBRTdCLElBQUlELGFBQWEsR0FBRztZQUNsQnlDLFdBQVdoSCxJQUFJLEdBQUcrRyxLQUFLcEQsTUFBTSxDQUFDWTtZQUM5QndDLE9BQU9BLEtBQUtwRCxNQUFNLENBQUMsR0FBR1k7UUFDeEI7UUFFQSxJQUFJMEMsY0FBY0YsS0FBS3ZDLE9BQU8sQ0FBQztRQUUvQixJQUFJeUMsZUFBZSxHQUFHO1lBQ3BCRCxXQUFXakgsTUFBTSxHQUFHZ0gsS0FBS3BELE1BQU0sQ0FBQ3NEO1lBQ2hDRixPQUFPQSxLQUFLcEQsTUFBTSxDQUFDLEdBQUdzRDtRQUN4QjtRQUVBLElBQUlGLE1BQU07WUFDUkMsV0FBV2xILFFBQVEsR0FBR2lIO1FBQ3hCO0lBQ0Y7SUFFQSxPQUFPQztBQUNUO0FBRXVHLENBQ3ZHLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL29saS1jcm9zc2xhbmQtdmlkZW9ncmFwaHkvLi9ub2RlX21vZHVsZXMvaGlzdG9yeS9pbmRleC5qcz9lMWZhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBfZXh0ZW5kcyBmcm9tICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzJztcblxuLyoqXHJcbiAqIEFjdGlvbnMgcmVwcmVzZW50IHRoZSB0eXBlIG9mIGNoYW5nZSB0byBhIGxvY2F0aW9uIHZhbHVlLlxyXG4gKlxyXG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9yZW1peC1ydW4vaGlzdG9yeS90cmVlL21haW4vZG9jcy9hcGktcmVmZXJlbmNlLm1kI2FjdGlvblxyXG4gKi9cbnZhciBBY3Rpb247XG5cbihmdW5jdGlvbiAoQWN0aW9uKSB7XG4gIC8qKlxyXG4gICAqIEEgUE9QIGluZGljYXRlcyBhIGNoYW5nZSB0byBhbiBhcmJpdHJhcnkgaW5kZXggaW4gdGhlIGhpc3Rvcnkgc3RhY2ssIHN1Y2hcclxuICAgKiBhcyBhIGJhY2sgb3IgZm9yd2FyZCBuYXZpZ2F0aW9uLiBJdCBkb2VzIG5vdCBkZXNjcmliZSB0aGUgZGlyZWN0aW9uIG9mIHRoZVxyXG4gICAqIG5hdmlnYXRpb24sIG9ubHkgdGhhdCB0aGUgY3VycmVudCBpbmRleCBjaGFuZ2VkLlxyXG4gICAqXHJcbiAgICogTm90ZTogVGhpcyBpcyB0aGUgZGVmYXVsdCBhY3Rpb24gZm9yIG5ld2x5IGNyZWF0ZWQgaGlzdG9yeSBvYmplY3RzLlxyXG4gICAqL1xuICBBY3Rpb25bXCJQb3BcIl0gPSBcIlBPUFwiO1xuICAvKipcclxuICAgKiBBIFBVU0ggaW5kaWNhdGVzIGEgbmV3IGVudHJ5IGJlaW5nIGFkZGVkIHRvIHRoZSBoaXN0b3J5IHN0YWNrLCBzdWNoIGFzIHdoZW5cclxuICAgKiBhIGxpbmsgaXMgY2xpY2tlZCBhbmQgYSBuZXcgcGFnZSBsb2Fkcy4gV2hlbiB0aGlzIGhhcHBlbnMsIGFsbCBzdWJzZXF1ZW50XHJcbiAgICogZW50cmllcyBpbiB0aGUgc3RhY2sgYXJlIGxvc3QuXHJcbiAgICovXG5cbiAgQWN0aW9uW1wiUHVzaFwiXSA9IFwiUFVTSFwiO1xuICAvKipcclxuICAgKiBBIFJFUExBQ0UgaW5kaWNhdGVzIHRoZSBlbnRyeSBhdCB0aGUgY3VycmVudCBpbmRleCBpbiB0aGUgaGlzdG9yeSBzdGFja1xyXG4gICAqIGJlaW5nIHJlcGxhY2VkIGJ5IGEgbmV3IG9uZS5cclxuICAgKi9cblxuICBBY3Rpb25bXCJSZXBsYWNlXCJdID0gXCJSRVBMQUNFXCI7XG59KShBY3Rpb24gfHwgKEFjdGlvbiA9IHt9KSk7XG5cbnZhciByZWFkT25seSA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIE9iamVjdC5mcmVlemUob2JqKTtcbn0gOiBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiBvYmo7XG59O1xuXG5mdW5jdGlvbiB3YXJuaW5nKGNvbmQsIG1lc3NhZ2UpIHtcbiAgaWYgKCFjb25kKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSBjb25zb2xlLndhcm4obWVzc2FnZSk7XG5cbiAgICB0cnkge1xuICAgICAgLy8gV2VsY29tZSB0byBkZWJ1Z2dpbmcgaGlzdG9yeSFcbiAgICAgIC8vXG4gICAgICAvLyBUaGlzIGVycm9yIGlzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHlvdSBjYW4gbW9yZSBlYXNpbHlcbiAgICAgIC8vIGZpbmQgdGhlIHNvdXJjZSBmb3IgYSB3YXJuaW5nIHRoYXQgYXBwZWFycyBpbiB0aGUgY29uc29sZSBieVxuICAgICAgLy8gZW5hYmxpbmcgXCJwYXVzZSBvbiBleGNlcHRpb25zXCIgaW4geW91ciBKYXZhU2NyaXB0IGRlYnVnZ2VyLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZW1wdHlcbiAgICB9IGNhdGNoIChlKSB7fVxuICB9XG59XG5cbnZhciBCZWZvcmVVbmxvYWRFdmVudFR5cGUgPSAnYmVmb3JldW5sb2FkJztcbnZhciBIYXNoQ2hhbmdlRXZlbnRUeXBlID0gJ2hhc2hjaGFuZ2UnO1xudmFyIFBvcFN0YXRlRXZlbnRUeXBlID0gJ3BvcHN0YXRlJztcbi8qKlxyXG4gKiBCcm93c2VyIGhpc3Rvcnkgc3RvcmVzIHRoZSBsb2NhdGlvbiBpbiByZWd1bGFyIFVSTHMuIFRoaXMgaXMgdGhlIHN0YW5kYXJkIGZvclxyXG4gKiBtb3N0IHdlYiBhcHBzLCBidXQgaXQgcmVxdWlyZXMgc29tZSBjb25maWd1cmF0aW9uIG9uIHRoZSBzZXJ2ZXIgdG8gZW5zdXJlIHlvdVxyXG4gKiBzZXJ2ZSB0aGUgc2FtZSBhcHAgYXQgbXVsdGlwbGUgVVJMcy5cclxuICpcclxuICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vcmVtaXgtcnVuL2hpc3RvcnkvdHJlZS9tYWluL2RvY3MvYXBpLXJlZmVyZW5jZS5tZCNjcmVhdGVicm93c2VyaGlzdG9yeVxyXG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlQnJvd3Nlckhpc3Rvcnkob3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgdmFyIF9vcHRpb25zID0gb3B0aW9ucyxcbiAgICAgIF9vcHRpb25zJHdpbmRvdyA9IF9vcHRpb25zLndpbmRvdyxcbiAgICAgIHdpbmRvdyA9IF9vcHRpb25zJHdpbmRvdyA9PT0gdm9pZCAwID8gZG9jdW1lbnQuZGVmYXVsdFZpZXcgOiBfb3B0aW9ucyR3aW5kb3c7XG4gIHZhciBnbG9iYWxIaXN0b3J5ID0gd2luZG93Lmhpc3Rvcnk7XG5cbiAgZnVuY3Rpb24gZ2V0SW5kZXhBbmRMb2NhdGlvbigpIHtcbiAgICB2YXIgX3dpbmRvdyRsb2NhdGlvbiA9IHdpbmRvdy5sb2NhdGlvbixcbiAgICAgICAgcGF0aG5hbWUgPSBfd2luZG93JGxvY2F0aW9uLnBhdGhuYW1lLFxuICAgICAgICBzZWFyY2ggPSBfd2luZG93JGxvY2F0aW9uLnNlYXJjaCxcbiAgICAgICAgaGFzaCA9IF93aW5kb3ckbG9jYXRpb24uaGFzaDtcbiAgICB2YXIgc3RhdGUgPSBnbG9iYWxIaXN0b3J5LnN0YXRlIHx8IHt9O1xuICAgIHJldHVybiBbc3RhdGUuaWR4LCByZWFkT25seSh7XG4gICAgICBwYXRobmFtZTogcGF0aG5hbWUsXG4gICAgICBzZWFyY2g6IHNlYXJjaCxcbiAgICAgIGhhc2g6IGhhc2gsXG4gICAgICBzdGF0ZTogc3RhdGUudXNyIHx8IG51bGwsXG4gICAgICBrZXk6IHN0YXRlLmtleSB8fCAnZGVmYXVsdCdcbiAgICB9KV07XG4gIH1cblxuICB2YXIgYmxvY2tlZFBvcFR4ID0gbnVsbDtcblxuICBmdW5jdGlvbiBoYW5kbGVQb3AoKSB7XG4gICAgaWYgKGJsb2NrZWRQb3BUeCkge1xuICAgICAgYmxvY2tlcnMuY2FsbChibG9ja2VkUG9wVHgpO1xuICAgICAgYmxvY2tlZFBvcFR4ID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG5leHRBY3Rpb24gPSBBY3Rpb24uUG9wO1xuXG4gICAgICB2YXIgX2dldEluZGV4QW5kTG9jYXRpb24gPSBnZXRJbmRleEFuZExvY2F0aW9uKCksXG4gICAgICAgICAgbmV4dEluZGV4ID0gX2dldEluZGV4QW5kTG9jYXRpb25bMF0sXG4gICAgICAgICAgbmV4dExvY2F0aW9uID0gX2dldEluZGV4QW5kTG9jYXRpb25bMV07XG5cbiAgICAgIGlmIChibG9ja2Vycy5sZW5ndGgpIHtcbiAgICAgICAgaWYgKG5leHRJbmRleCAhPSBudWxsKSB7XG4gICAgICAgICAgdmFyIGRlbHRhID0gaW5kZXggLSBuZXh0SW5kZXg7XG5cbiAgICAgICAgICBpZiAoZGVsdGEpIHtcbiAgICAgICAgICAgIC8vIFJldmVydCB0aGUgUE9QXG4gICAgICAgICAgICBibG9ja2VkUG9wVHggPSB7XG4gICAgICAgICAgICAgIGFjdGlvbjogbmV4dEFjdGlvbixcbiAgICAgICAgICAgICAgbG9jYXRpb246IG5leHRMb2NhdGlvbixcbiAgICAgICAgICAgICAgcmV0cnk6IGZ1bmN0aW9uIHJldHJ5KCkge1xuICAgICAgICAgICAgICAgIGdvKGRlbHRhICogLTEpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZ28oZGVsdGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBUcnlpbmcgdG8gUE9QIHRvIGEgbG9jYXRpb24gd2l0aCBubyBpbmRleC4gV2UgZGlkIG5vdCBjcmVhdGVcbiAgICAgICAgICAvLyB0aGlzIGxvY2F0aW9uLCBzbyB3ZSBjYW4ndCBlZmZlY3RpdmVseSBibG9jayB0aGUgbmF2aWdhdGlvbi5cbiAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKGZhbHNlLCAvLyBUT0RPOiBXcml0ZSB1cCBhIGRvYyB0aGF0IGV4cGxhaW5zIG91ciBibG9ja2luZyBzdHJhdGVneSBpblxuICAgICAgICAgIC8vIGRldGFpbCBhbmQgbGluayB0byBpdCBoZXJlIHNvIHBlb3BsZSBjYW4gdW5kZXJzdGFuZCBiZXR0ZXIgd2hhdFxuICAgICAgICAgIC8vIGlzIGdvaW5nIG9uIGFuZCBob3cgdG8gYXZvaWQgaXQuXG4gICAgICAgICAgXCJZb3UgYXJlIHRyeWluZyB0byBibG9jayBhIFBPUCBuYXZpZ2F0aW9uIHRvIGEgbG9jYXRpb24gdGhhdCB3YXMgbm90IFwiICsgXCJjcmVhdGVkIGJ5IHRoZSBoaXN0b3J5IGxpYnJhcnkuIFRoZSBibG9jayB3aWxsIGZhaWwgc2lsZW50bHkgaW4gXCIgKyBcInByb2R1Y3Rpb24sIGJ1dCBpbiBnZW5lcmFsIHlvdSBzaG91bGQgZG8gYWxsIG5hdmlnYXRpb24gd2l0aCB0aGUgXCIgKyBcImhpc3RvcnkgbGlicmFyeSAoaW5zdGVhZCBvZiB1c2luZyB3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUgZGlyZWN0bHkpIFwiICsgXCJ0byBhdm9pZCB0aGlzIHNpdHVhdGlvbi5cIikgOiB2b2lkIDA7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFwcGx5VHgobmV4dEFjdGlvbik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoUG9wU3RhdGVFdmVudFR5cGUsIGhhbmRsZVBvcCk7XG4gIHZhciBhY3Rpb24gPSBBY3Rpb24uUG9wO1xuXG4gIHZhciBfZ2V0SW5kZXhBbmRMb2NhdGlvbjIgPSBnZXRJbmRleEFuZExvY2F0aW9uKCksXG4gICAgICBpbmRleCA9IF9nZXRJbmRleEFuZExvY2F0aW9uMlswXSxcbiAgICAgIGxvY2F0aW9uID0gX2dldEluZGV4QW5kTG9jYXRpb24yWzFdO1xuXG4gIHZhciBsaXN0ZW5lcnMgPSBjcmVhdGVFdmVudHMoKTtcbiAgdmFyIGJsb2NrZXJzID0gY3JlYXRlRXZlbnRzKCk7XG5cbiAgaWYgKGluZGV4ID09IG51bGwpIHtcbiAgICBpbmRleCA9IDA7XG4gICAgZ2xvYmFsSGlzdG9yeS5yZXBsYWNlU3RhdGUoX2V4dGVuZHMoe30sIGdsb2JhbEhpc3Rvcnkuc3RhdGUsIHtcbiAgICAgIGlkeDogaW5kZXhcbiAgICB9KSwgJycpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlSHJlZih0bykge1xuICAgIHJldHVybiB0eXBlb2YgdG8gPT09ICdzdHJpbmcnID8gdG8gOiBjcmVhdGVQYXRoKHRvKTtcbiAgfSAvLyBzdGF0ZSBkZWZhdWx0cyB0byBgbnVsbGAgYmVjYXVzZSBgd2luZG93Lmhpc3Rvcnkuc3RhdGVgIGRvZXNcblxuXG4gIGZ1bmN0aW9uIGdldE5leHRMb2NhdGlvbih0bywgc3RhdGUpIHtcbiAgICBpZiAoc3RhdGUgPT09IHZvaWQgMCkge1xuICAgICAgc3RhdGUgPSBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiByZWFkT25seShfZXh0ZW5kcyh7XG4gICAgICBwYXRobmFtZTogbG9jYXRpb24ucGF0aG5hbWUsXG4gICAgICBoYXNoOiAnJyxcbiAgICAgIHNlYXJjaDogJydcbiAgICB9LCB0eXBlb2YgdG8gPT09ICdzdHJpbmcnID8gcGFyc2VQYXRoKHRvKSA6IHRvLCB7XG4gICAgICBzdGF0ZTogc3RhdGUsXG4gICAgICBrZXk6IGNyZWF0ZUtleSgpXG4gICAgfSkpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0SGlzdG9yeVN0YXRlQW5kVXJsKG5leHRMb2NhdGlvbiwgaW5kZXgpIHtcbiAgICByZXR1cm4gW3tcbiAgICAgIHVzcjogbmV4dExvY2F0aW9uLnN0YXRlLFxuICAgICAga2V5OiBuZXh0TG9jYXRpb24ua2V5LFxuICAgICAgaWR4OiBpbmRleFxuICAgIH0sIGNyZWF0ZUhyZWYobmV4dExvY2F0aW9uKV07XG4gIH1cblxuICBmdW5jdGlvbiBhbGxvd1R4KGFjdGlvbiwgbG9jYXRpb24sIHJldHJ5KSB7XG4gICAgcmV0dXJuICFibG9ja2Vycy5sZW5ndGggfHwgKGJsb2NrZXJzLmNhbGwoe1xuICAgICAgYWN0aW9uOiBhY3Rpb24sXG4gICAgICBsb2NhdGlvbjogbG9jYXRpb24sXG4gICAgICByZXRyeTogcmV0cnlcbiAgICB9KSwgZmFsc2UpO1xuICB9XG5cbiAgZnVuY3Rpb24gYXBwbHlUeChuZXh0QWN0aW9uKSB7XG4gICAgYWN0aW9uID0gbmV4dEFjdGlvbjtcblxuICAgIHZhciBfZ2V0SW5kZXhBbmRMb2NhdGlvbjMgPSBnZXRJbmRleEFuZExvY2F0aW9uKCk7XG5cbiAgICBpbmRleCA9IF9nZXRJbmRleEFuZExvY2F0aW9uM1swXTtcbiAgICBsb2NhdGlvbiA9IF9nZXRJbmRleEFuZExvY2F0aW9uM1sxXTtcbiAgICBsaXN0ZW5lcnMuY2FsbCh7XG4gICAgICBhY3Rpb246IGFjdGlvbixcbiAgICAgIGxvY2F0aW9uOiBsb2NhdGlvblxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gcHVzaCh0bywgc3RhdGUpIHtcbiAgICB2YXIgbmV4dEFjdGlvbiA9IEFjdGlvbi5QdXNoO1xuICAgIHZhciBuZXh0TG9jYXRpb24gPSBnZXROZXh0TG9jYXRpb24odG8sIHN0YXRlKTtcblxuICAgIGZ1bmN0aW9uIHJldHJ5KCkge1xuICAgICAgcHVzaCh0bywgc3RhdGUpO1xuICAgIH1cblxuICAgIGlmIChhbGxvd1R4KG5leHRBY3Rpb24sIG5leHRMb2NhdGlvbiwgcmV0cnkpKSB7XG4gICAgICB2YXIgX2dldEhpc3RvcnlTdGF0ZUFuZFVyID0gZ2V0SGlzdG9yeVN0YXRlQW5kVXJsKG5leHRMb2NhdGlvbiwgaW5kZXggKyAxKSxcbiAgICAgICAgICBoaXN0b3J5U3RhdGUgPSBfZ2V0SGlzdG9yeVN0YXRlQW5kVXJbMF0sXG4gICAgICAgICAgdXJsID0gX2dldEhpc3RvcnlTdGF0ZUFuZFVyWzFdOyAvLyBUT0RPOiBTdXBwb3J0IGZvcmNlZCByZWxvYWRpbmdcbiAgICAgIC8vIHRyeS4uLmNhdGNoIGJlY2F1c2UgaU9TIGxpbWl0cyB1cyB0byAxMDAgcHVzaFN0YXRlIGNhbGxzIDovXG5cblxuICAgICAgdHJ5IHtcbiAgICAgICAgZ2xvYmFsSGlzdG9yeS5wdXNoU3RhdGUoaGlzdG9yeVN0YXRlLCAnJywgdXJsKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIC8vIFRoZXkgYXJlIGdvaW5nIHRvIGxvc2Ugc3RhdGUgaGVyZSwgYnV0IHRoZXJlIGlzIG5vIHJlYWxcbiAgICAgICAgLy8gd2F5IHRvIHdhcm4gdGhlbSBhYm91dCBpdCBzaW5jZSB0aGUgcGFnZSB3aWxsIHJlZnJlc2guLi5cbiAgICAgICAgd2luZG93LmxvY2F0aW9uLmFzc2lnbih1cmwpO1xuICAgICAgfVxuXG4gICAgICBhcHBseVR4KG5leHRBY3Rpb24pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlcGxhY2UodG8sIHN0YXRlKSB7XG4gICAgdmFyIG5leHRBY3Rpb24gPSBBY3Rpb24uUmVwbGFjZTtcbiAgICB2YXIgbmV4dExvY2F0aW9uID0gZ2V0TmV4dExvY2F0aW9uKHRvLCBzdGF0ZSk7XG5cbiAgICBmdW5jdGlvbiByZXRyeSgpIHtcbiAgICAgIHJlcGxhY2UodG8sIHN0YXRlKTtcbiAgICB9XG5cbiAgICBpZiAoYWxsb3dUeChuZXh0QWN0aW9uLCBuZXh0TG9jYXRpb24sIHJldHJ5KSkge1xuICAgICAgdmFyIF9nZXRIaXN0b3J5U3RhdGVBbmRVcjIgPSBnZXRIaXN0b3J5U3RhdGVBbmRVcmwobmV4dExvY2F0aW9uLCBpbmRleCksXG4gICAgICAgICAgaGlzdG9yeVN0YXRlID0gX2dldEhpc3RvcnlTdGF0ZUFuZFVyMlswXSxcbiAgICAgICAgICB1cmwgPSBfZ2V0SGlzdG9yeVN0YXRlQW5kVXIyWzFdOyAvLyBUT0RPOiBTdXBwb3J0IGZvcmNlZCByZWxvYWRpbmdcblxuXG4gICAgICBnbG9iYWxIaXN0b3J5LnJlcGxhY2VTdGF0ZShoaXN0b3J5U3RhdGUsICcnLCB1cmwpO1xuICAgICAgYXBwbHlUeChuZXh0QWN0aW9uKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnbyhkZWx0YSkge1xuICAgIGdsb2JhbEhpc3RvcnkuZ28oZGVsdGEpO1xuICB9XG5cbiAgdmFyIGhpc3RvcnkgPSB7XG4gICAgZ2V0IGFjdGlvbigpIHtcbiAgICAgIHJldHVybiBhY3Rpb247XG4gICAgfSxcblxuICAgIGdldCBsb2NhdGlvbigpIHtcbiAgICAgIHJldHVybiBsb2NhdGlvbjtcbiAgICB9LFxuXG4gICAgY3JlYXRlSHJlZjogY3JlYXRlSHJlZixcbiAgICBwdXNoOiBwdXNoLFxuICAgIHJlcGxhY2U6IHJlcGxhY2UsXG4gICAgZ286IGdvLFxuICAgIGJhY2s6IGZ1bmN0aW9uIGJhY2soKSB7XG4gICAgICBnbygtMSk7XG4gICAgfSxcbiAgICBmb3J3YXJkOiBmdW5jdGlvbiBmb3J3YXJkKCkge1xuICAgICAgZ28oMSk7XG4gICAgfSxcbiAgICBsaXN0ZW46IGZ1bmN0aW9uIGxpc3RlbihsaXN0ZW5lcikge1xuICAgICAgcmV0dXJuIGxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICB9LFxuICAgIGJsb2NrOiBmdW5jdGlvbiBibG9jayhibG9ja2VyKSB7XG4gICAgICB2YXIgdW5ibG9jayA9IGJsb2NrZXJzLnB1c2goYmxvY2tlcik7XG5cbiAgICAgIGlmIChibG9ja2Vycy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoQmVmb3JlVW5sb2FkRXZlbnRUeXBlLCBwcm9tcHRCZWZvcmVVbmxvYWQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB1bmJsb2NrKCk7IC8vIFJlbW92ZSB0aGUgYmVmb3JldW5sb2FkIGxpc3RlbmVyIHNvIHRoZSBkb2N1bWVudCBtYXlcbiAgICAgICAgLy8gc3RpbGwgYmUgc2FsdmFnZWFibGUgaW4gdGhlIHBhZ2VoaWRlIGV2ZW50LlxuICAgICAgICAvLyBTZWUgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy8jdW5sb2FkaW5nLWRvY3VtZW50c1xuXG4gICAgICAgIGlmICghYmxvY2tlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoQmVmb3JlVW5sb2FkRXZlbnRUeXBlLCBwcm9tcHRCZWZvcmVVbmxvYWQpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIGhpc3Rvcnk7XG59XG4vKipcclxuICogSGFzaCBoaXN0b3J5IHN0b3JlcyB0aGUgbG9jYXRpb24gaW4gd2luZG93LmxvY2F0aW9uLmhhc2guIFRoaXMgbWFrZXMgaXQgaWRlYWxcclxuICogZm9yIHNpdHVhdGlvbnMgd2hlcmUgeW91IGRvbid0IHdhbnQgdG8gc2VuZCB0aGUgbG9jYXRpb24gdG8gdGhlIHNlcnZlciBmb3JcclxuICogc29tZSByZWFzb24sIGVpdGhlciBiZWNhdXNlIHlvdSBkbyBjYW5ub3QgY29uZmlndXJlIGl0IG9yIHRoZSBVUkwgc3BhY2UgaXNcclxuICogcmVzZXJ2ZWQgZm9yIHNvbWV0aGluZyBlbHNlLlxyXG4gKlxyXG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9yZW1peC1ydW4vaGlzdG9yeS90cmVlL21haW4vZG9jcy9hcGktcmVmZXJlbmNlLm1kI2NyZWF0ZWhhc2hoaXN0b3J5XHJcbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVIYXNoSGlzdG9yeShvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICB2YXIgX29wdGlvbnMyID0gb3B0aW9ucyxcbiAgICAgIF9vcHRpb25zMiR3aW5kb3cgPSBfb3B0aW9uczIud2luZG93LFxuICAgICAgd2luZG93ID0gX29wdGlvbnMyJHdpbmRvdyA9PT0gdm9pZCAwID8gZG9jdW1lbnQuZGVmYXVsdFZpZXcgOiBfb3B0aW9uczIkd2luZG93O1xuICB2YXIgZ2xvYmFsSGlzdG9yeSA9IHdpbmRvdy5oaXN0b3J5O1xuXG4gIGZ1bmN0aW9uIGdldEluZGV4QW5kTG9jYXRpb24oKSB7XG4gICAgdmFyIF9wYXJzZVBhdGggPSBwYXJzZVBhdGgod2luZG93LmxvY2F0aW9uLmhhc2guc3Vic3RyKDEpKSxcbiAgICAgICAgX3BhcnNlUGF0aCRwYXRobmFtZSA9IF9wYXJzZVBhdGgucGF0aG5hbWUsXG4gICAgICAgIHBhdGhuYW1lID0gX3BhcnNlUGF0aCRwYXRobmFtZSA9PT0gdm9pZCAwID8gJy8nIDogX3BhcnNlUGF0aCRwYXRobmFtZSxcbiAgICAgICAgX3BhcnNlUGF0aCRzZWFyY2ggPSBfcGFyc2VQYXRoLnNlYXJjaCxcbiAgICAgICAgc2VhcmNoID0gX3BhcnNlUGF0aCRzZWFyY2ggPT09IHZvaWQgMCA/ICcnIDogX3BhcnNlUGF0aCRzZWFyY2gsXG4gICAgICAgIF9wYXJzZVBhdGgkaGFzaCA9IF9wYXJzZVBhdGguaGFzaCxcbiAgICAgICAgaGFzaCA9IF9wYXJzZVBhdGgkaGFzaCA9PT0gdm9pZCAwID8gJycgOiBfcGFyc2VQYXRoJGhhc2g7XG5cbiAgICB2YXIgc3RhdGUgPSBnbG9iYWxIaXN0b3J5LnN0YXRlIHx8IHt9O1xuICAgIHJldHVybiBbc3RhdGUuaWR4LCByZWFkT25seSh7XG4gICAgICBwYXRobmFtZTogcGF0aG5hbWUsXG4gICAgICBzZWFyY2g6IHNlYXJjaCxcbiAgICAgIGhhc2g6IGhhc2gsXG4gICAgICBzdGF0ZTogc3RhdGUudXNyIHx8IG51bGwsXG4gICAgICBrZXk6IHN0YXRlLmtleSB8fCAnZGVmYXVsdCdcbiAgICB9KV07XG4gIH1cblxuICB2YXIgYmxvY2tlZFBvcFR4ID0gbnVsbDtcblxuICBmdW5jdGlvbiBoYW5kbGVQb3AoKSB7XG4gICAgaWYgKGJsb2NrZWRQb3BUeCkge1xuICAgICAgYmxvY2tlcnMuY2FsbChibG9ja2VkUG9wVHgpO1xuICAgICAgYmxvY2tlZFBvcFR4ID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG5leHRBY3Rpb24gPSBBY3Rpb24uUG9wO1xuXG4gICAgICB2YXIgX2dldEluZGV4QW5kTG9jYXRpb240ID0gZ2V0SW5kZXhBbmRMb2NhdGlvbigpLFxuICAgICAgICAgIG5leHRJbmRleCA9IF9nZXRJbmRleEFuZExvY2F0aW9uNFswXSxcbiAgICAgICAgICBuZXh0TG9jYXRpb24gPSBfZ2V0SW5kZXhBbmRMb2NhdGlvbjRbMV07XG5cbiAgICAgIGlmIChibG9ja2Vycy5sZW5ndGgpIHtcbiAgICAgICAgaWYgKG5leHRJbmRleCAhPSBudWxsKSB7XG4gICAgICAgICAgdmFyIGRlbHRhID0gaW5kZXggLSBuZXh0SW5kZXg7XG5cbiAgICAgICAgICBpZiAoZGVsdGEpIHtcbiAgICAgICAgICAgIC8vIFJldmVydCB0aGUgUE9QXG4gICAgICAgICAgICBibG9ja2VkUG9wVHggPSB7XG4gICAgICAgICAgICAgIGFjdGlvbjogbmV4dEFjdGlvbixcbiAgICAgICAgICAgICAgbG9jYXRpb246IG5leHRMb2NhdGlvbixcbiAgICAgICAgICAgICAgcmV0cnk6IGZ1bmN0aW9uIHJldHJ5KCkge1xuICAgICAgICAgICAgICAgIGdvKGRlbHRhICogLTEpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZ28oZGVsdGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBUcnlpbmcgdG8gUE9QIHRvIGEgbG9jYXRpb24gd2l0aCBubyBpbmRleC4gV2UgZGlkIG5vdCBjcmVhdGVcbiAgICAgICAgICAvLyB0aGlzIGxvY2F0aW9uLCBzbyB3ZSBjYW4ndCBlZmZlY3RpdmVseSBibG9jayB0aGUgbmF2aWdhdGlvbi5cbiAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKGZhbHNlLCAvLyBUT0RPOiBXcml0ZSB1cCBhIGRvYyB0aGF0IGV4cGxhaW5zIG91ciBibG9ja2luZyBzdHJhdGVneSBpblxuICAgICAgICAgIC8vIGRldGFpbCBhbmQgbGluayB0byBpdCBoZXJlIHNvIHBlb3BsZSBjYW4gdW5kZXJzdGFuZCBiZXR0ZXJcbiAgICAgICAgICAvLyB3aGF0IGlzIGdvaW5nIG9uIGFuZCBob3cgdG8gYXZvaWQgaXQuXG4gICAgICAgICAgXCJZb3UgYXJlIHRyeWluZyB0byBibG9jayBhIFBPUCBuYXZpZ2F0aW9uIHRvIGEgbG9jYXRpb24gdGhhdCB3YXMgbm90IFwiICsgXCJjcmVhdGVkIGJ5IHRoZSBoaXN0b3J5IGxpYnJhcnkuIFRoZSBibG9jayB3aWxsIGZhaWwgc2lsZW50bHkgaW4gXCIgKyBcInByb2R1Y3Rpb24sIGJ1dCBpbiBnZW5lcmFsIHlvdSBzaG91bGQgZG8gYWxsIG5hdmlnYXRpb24gd2l0aCB0aGUgXCIgKyBcImhpc3RvcnkgbGlicmFyeSAoaW5zdGVhZCBvZiB1c2luZyB3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUgZGlyZWN0bHkpIFwiICsgXCJ0byBhdm9pZCB0aGlzIHNpdHVhdGlvbi5cIikgOiB2b2lkIDA7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFwcGx5VHgobmV4dEFjdGlvbik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoUG9wU3RhdGVFdmVudFR5cGUsIGhhbmRsZVBvcCk7IC8vIHBvcHN0YXRlIGRvZXMgbm90IGZpcmUgb24gaGFzaGNoYW5nZSBpbiBJRSAxMSBhbmQgb2xkICh0cmlkZW50KSBFZGdlXG4gIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RlL2RvY3MvV2ViL0FQSS9XaW5kb3cvcG9wc3RhdGVfZXZlbnRcblxuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihIYXNoQ2hhbmdlRXZlbnRUeXBlLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9nZXRJbmRleEFuZExvY2F0aW9uNSA9IGdldEluZGV4QW5kTG9jYXRpb24oKSxcbiAgICAgICAgbmV4dExvY2F0aW9uID0gX2dldEluZGV4QW5kTG9jYXRpb241WzFdOyAvLyBJZ25vcmUgZXh0cmFuZW91cyBoYXNoY2hhbmdlIGV2ZW50cy5cblxuXG4gICAgaWYgKGNyZWF0ZVBhdGgobmV4dExvY2F0aW9uKSAhPT0gY3JlYXRlUGF0aChsb2NhdGlvbikpIHtcbiAgICAgIGhhbmRsZVBvcCgpO1xuICAgIH1cbiAgfSk7XG4gIHZhciBhY3Rpb24gPSBBY3Rpb24uUG9wO1xuXG4gIHZhciBfZ2V0SW5kZXhBbmRMb2NhdGlvbjYgPSBnZXRJbmRleEFuZExvY2F0aW9uKCksXG4gICAgICBpbmRleCA9IF9nZXRJbmRleEFuZExvY2F0aW9uNlswXSxcbiAgICAgIGxvY2F0aW9uID0gX2dldEluZGV4QW5kTG9jYXRpb242WzFdO1xuXG4gIHZhciBsaXN0ZW5lcnMgPSBjcmVhdGVFdmVudHMoKTtcbiAgdmFyIGJsb2NrZXJzID0gY3JlYXRlRXZlbnRzKCk7XG5cbiAgaWYgKGluZGV4ID09IG51bGwpIHtcbiAgICBpbmRleCA9IDA7XG4gICAgZ2xvYmFsSGlzdG9yeS5yZXBsYWNlU3RhdGUoX2V4dGVuZHMoe30sIGdsb2JhbEhpc3Rvcnkuc3RhdGUsIHtcbiAgICAgIGlkeDogaW5kZXhcbiAgICB9KSwgJycpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0QmFzZUhyZWYoKSB7XG4gICAgdmFyIGJhc2UgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdiYXNlJyk7XG4gICAgdmFyIGhyZWYgPSAnJztcblxuICAgIGlmIChiYXNlICYmIGJhc2UuZ2V0QXR0cmlidXRlKCdocmVmJykpIHtcbiAgICAgIHZhciB1cmwgPSB3aW5kb3cubG9jYXRpb24uaHJlZjtcbiAgICAgIHZhciBoYXNoSW5kZXggPSB1cmwuaW5kZXhPZignIycpO1xuICAgICAgaHJlZiA9IGhhc2hJbmRleCA9PT0gLTEgPyB1cmwgOiB1cmwuc2xpY2UoMCwgaGFzaEluZGV4KTtcbiAgICB9XG5cbiAgICByZXR1cm4gaHJlZjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUhyZWYodG8pIHtcbiAgICByZXR1cm4gZ2V0QmFzZUhyZWYoKSArICcjJyArICh0eXBlb2YgdG8gPT09ICdzdHJpbmcnID8gdG8gOiBjcmVhdGVQYXRoKHRvKSk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXROZXh0TG9jYXRpb24odG8sIHN0YXRlKSB7XG4gICAgaWYgKHN0YXRlID09PSB2b2lkIDApIHtcbiAgICAgIHN0YXRlID0gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVhZE9ubHkoX2V4dGVuZHMoe1xuICAgICAgcGF0aG5hbWU6IGxvY2F0aW9uLnBhdGhuYW1lLFxuICAgICAgaGFzaDogJycsXG4gICAgICBzZWFyY2g6ICcnXG4gICAgfSwgdHlwZW9mIHRvID09PSAnc3RyaW5nJyA/IHBhcnNlUGF0aCh0bykgOiB0bywge1xuICAgICAgc3RhdGU6IHN0YXRlLFxuICAgICAga2V5OiBjcmVhdGVLZXkoKVxuICAgIH0pKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEhpc3RvcnlTdGF0ZUFuZFVybChuZXh0TG9jYXRpb24sIGluZGV4KSB7XG4gICAgcmV0dXJuIFt7XG4gICAgICB1c3I6IG5leHRMb2NhdGlvbi5zdGF0ZSxcbiAgICAgIGtleTogbmV4dExvY2F0aW9uLmtleSxcbiAgICAgIGlkeDogaW5kZXhcbiAgICB9LCBjcmVhdGVIcmVmKG5leHRMb2NhdGlvbildO1xuICB9XG5cbiAgZnVuY3Rpb24gYWxsb3dUeChhY3Rpb24sIGxvY2F0aW9uLCByZXRyeSkge1xuICAgIHJldHVybiAhYmxvY2tlcnMubGVuZ3RoIHx8IChibG9ja2Vycy5jYWxsKHtcbiAgICAgIGFjdGlvbjogYWN0aW9uLFxuICAgICAgbG9jYXRpb246IGxvY2F0aW9uLFxuICAgICAgcmV0cnk6IHJldHJ5XG4gICAgfSksIGZhbHNlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFwcGx5VHgobmV4dEFjdGlvbikge1xuICAgIGFjdGlvbiA9IG5leHRBY3Rpb247XG5cbiAgICB2YXIgX2dldEluZGV4QW5kTG9jYXRpb243ID0gZ2V0SW5kZXhBbmRMb2NhdGlvbigpO1xuXG4gICAgaW5kZXggPSBfZ2V0SW5kZXhBbmRMb2NhdGlvbjdbMF07XG4gICAgbG9jYXRpb24gPSBfZ2V0SW5kZXhBbmRMb2NhdGlvbjdbMV07XG4gICAgbGlzdGVuZXJzLmNhbGwoe1xuICAgICAgYWN0aW9uOiBhY3Rpb24sXG4gICAgICBsb2NhdGlvbjogbG9jYXRpb25cbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHB1c2godG8sIHN0YXRlKSB7XG4gICAgdmFyIG5leHRBY3Rpb24gPSBBY3Rpb24uUHVzaDtcbiAgICB2YXIgbmV4dExvY2F0aW9uID0gZ2V0TmV4dExvY2F0aW9uKHRvLCBzdGF0ZSk7XG5cbiAgICBmdW5jdGlvbiByZXRyeSgpIHtcbiAgICAgIHB1c2godG8sIHN0YXRlKTtcbiAgICB9XG5cbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKG5leHRMb2NhdGlvbi5wYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJywgXCJSZWxhdGl2ZSBwYXRobmFtZXMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gaGFzaCBoaXN0b3J5LnB1c2goXCIgKyBKU09OLnN0cmluZ2lmeSh0bykgKyBcIilcIikgOiB2b2lkIDA7XG5cbiAgICBpZiAoYWxsb3dUeChuZXh0QWN0aW9uLCBuZXh0TG9jYXRpb24sIHJldHJ5KSkge1xuICAgICAgdmFyIF9nZXRIaXN0b3J5U3RhdGVBbmRVcjMgPSBnZXRIaXN0b3J5U3RhdGVBbmRVcmwobmV4dExvY2F0aW9uLCBpbmRleCArIDEpLFxuICAgICAgICAgIGhpc3RvcnlTdGF0ZSA9IF9nZXRIaXN0b3J5U3RhdGVBbmRVcjNbMF0sXG4gICAgICAgICAgdXJsID0gX2dldEhpc3RvcnlTdGF0ZUFuZFVyM1sxXTsgLy8gVE9ETzogU3VwcG9ydCBmb3JjZWQgcmVsb2FkaW5nXG4gICAgICAvLyB0cnkuLi5jYXRjaCBiZWNhdXNlIGlPUyBsaW1pdHMgdXMgdG8gMTAwIHB1c2hTdGF0ZSBjYWxscyA6L1xuXG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGdsb2JhbEhpc3RvcnkucHVzaFN0YXRlKGhpc3RvcnlTdGF0ZSwgJycsIHVybCk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAvLyBUaGV5IGFyZSBnb2luZyB0byBsb3NlIHN0YXRlIGhlcmUsIGJ1dCB0aGVyZSBpcyBubyByZWFsXG4gICAgICAgIC8vIHdheSB0byB3YXJuIHRoZW0gYWJvdXQgaXQgc2luY2UgdGhlIHBhZ2Ugd2lsbCByZWZyZXNoLi4uXG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5hc3NpZ24odXJsKTtcbiAgICAgIH1cblxuICAgICAgYXBwbHlUeChuZXh0QWN0aW9uKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZXBsYWNlKHRvLCBzdGF0ZSkge1xuICAgIHZhciBuZXh0QWN0aW9uID0gQWN0aW9uLlJlcGxhY2U7XG4gICAgdmFyIG5leHRMb2NhdGlvbiA9IGdldE5leHRMb2NhdGlvbih0bywgc3RhdGUpO1xuXG4gICAgZnVuY3Rpb24gcmV0cnkoKSB7XG4gICAgICByZXBsYWNlKHRvLCBzdGF0ZSk7XG4gICAgfVxuXG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhuZXh0TG9jYXRpb24ucGF0aG5hbWUuY2hhckF0KDApID09PSAnLycsIFwiUmVsYXRpdmUgcGF0aG5hbWVzIGFyZSBub3Qgc3VwcG9ydGVkIGluIGhhc2ggaGlzdG9yeS5yZXBsYWNlKFwiICsgSlNPTi5zdHJpbmdpZnkodG8pICsgXCIpXCIpIDogdm9pZCAwO1xuXG4gICAgaWYgKGFsbG93VHgobmV4dEFjdGlvbiwgbmV4dExvY2F0aW9uLCByZXRyeSkpIHtcbiAgICAgIHZhciBfZ2V0SGlzdG9yeVN0YXRlQW5kVXI0ID0gZ2V0SGlzdG9yeVN0YXRlQW5kVXJsKG5leHRMb2NhdGlvbiwgaW5kZXgpLFxuICAgICAgICAgIGhpc3RvcnlTdGF0ZSA9IF9nZXRIaXN0b3J5U3RhdGVBbmRVcjRbMF0sXG4gICAgICAgICAgdXJsID0gX2dldEhpc3RvcnlTdGF0ZUFuZFVyNFsxXTsgLy8gVE9ETzogU3VwcG9ydCBmb3JjZWQgcmVsb2FkaW5nXG5cblxuICAgICAgZ2xvYmFsSGlzdG9yeS5yZXBsYWNlU3RhdGUoaGlzdG9yeVN0YXRlLCAnJywgdXJsKTtcbiAgICAgIGFwcGx5VHgobmV4dEFjdGlvbik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ28oZGVsdGEpIHtcbiAgICBnbG9iYWxIaXN0b3J5LmdvKGRlbHRhKTtcbiAgfVxuXG4gIHZhciBoaXN0b3J5ID0ge1xuICAgIGdldCBhY3Rpb24oKSB7XG4gICAgICByZXR1cm4gYWN0aW9uO1xuICAgIH0sXG5cbiAgICBnZXQgbG9jYXRpb24oKSB7XG4gICAgICByZXR1cm4gbG9jYXRpb247XG4gICAgfSxcblxuICAgIGNyZWF0ZUhyZWY6IGNyZWF0ZUhyZWYsXG4gICAgcHVzaDogcHVzaCxcbiAgICByZXBsYWNlOiByZXBsYWNlLFxuICAgIGdvOiBnbyxcbiAgICBiYWNrOiBmdW5jdGlvbiBiYWNrKCkge1xuICAgICAgZ28oLTEpO1xuICAgIH0sXG4gICAgZm9yd2FyZDogZnVuY3Rpb24gZm9yd2FyZCgpIHtcbiAgICAgIGdvKDEpO1xuICAgIH0sXG4gICAgbGlzdGVuOiBmdW5jdGlvbiBsaXN0ZW4obGlzdGVuZXIpIHtcbiAgICAgIHJldHVybiBsaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gICAgfSxcbiAgICBibG9jazogZnVuY3Rpb24gYmxvY2soYmxvY2tlcikge1xuICAgICAgdmFyIHVuYmxvY2sgPSBibG9ja2Vycy5wdXNoKGJsb2NrZXIpO1xuXG4gICAgICBpZiAoYmxvY2tlcnMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKEJlZm9yZVVubG9hZEV2ZW50VHlwZSwgcHJvbXB0QmVmb3JlVW5sb2FkKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdW5ibG9jaygpOyAvLyBSZW1vdmUgdGhlIGJlZm9yZXVubG9hZCBsaXN0ZW5lciBzbyB0aGUgZG9jdW1lbnQgbWF5XG4gICAgICAgIC8vIHN0aWxsIGJlIHNhbHZhZ2VhYmxlIGluIHRoZSBwYWdlaGlkZSBldmVudC5cbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvI3VubG9hZGluZy1kb2N1bWVudHNcblxuICAgICAgICBpZiAoIWJsb2NrZXJzLmxlbmd0aCkge1xuICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKEJlZm9yZVVubG9hZEV2ZW50VHlwZSwgcHJvbXB0QmVmb3JlVW5sb2FkKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBoaXN0b3J5O1xufVxuLyoqXHJcbiAqIE1lbW9yeSBoaXN0b3J5IHN0b3JlcyB0aGUgY3VycmVudCBsb2NhdGlvbiBpbiBtZW1vcnkuIEl0IGlzIGRlc2lnbmVkIGZvciB1c2VcclxuICogaW4gc3RhdGVmdWwgbm9uLWJyb3dzZXIgZW52aXJvbm1lbnRzIGxpa2UgdGVzdHMgYW5kIFJlYWN0IE5hdGl2ZS5cclxuICpcclxuICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vcmVtaXgtcnVuL2hpc3RvcnkvdHJlZS9tYWluL2RvY3MvYXBpLXJlZmVyZW5jZS5tZCNjcmVhdGVtZW1vcnloaXN0b3J5XHJcbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVNZW1vcnlIaXN0b3J5KG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIHZhciBfb3B0aW9uczMgPSBvcHRpb25zLFxuICAgICAgX29wdGlvbnMzJGluaXRpYWxFbnRyID0gX29wdGlvbnMzLmluaXRpYWxFbnRyaWVzLFxuICAgICAgaW5pdGlhbEVudHJpZXMgPSBfb3B0aW9uczMkaW5pdGlhbEVudHIgPT09IHZvaWQgMCA/IFsnLyddIDogX29wdGlvbnMzJGluaXRpYWxFbnRyLFxuICAgICAgaW5pdGlhbEluZGV4ID0gX29wdGlvbnMzLmluaXRpYWxJbmRleDtcbiAgdmFyIGVudHJpZXMgPSBpbml0aWFsRW50cmllcy5tYXAoZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgdmFyIGxvY2F0aW9uID0gcmVhZE9ubHkoX2V4dGVuZHMoe1xuICAgICAgcGF0aG5hbWU6ICcvJyxcbiAgICAgIHNlYXJjaDogJycsXG4gICAgICBoYXNoOiAnJyxcbiAgICAgIHN0YXRlOiBudWxsLFxuICAgICAga2V5OiBjcmVhdGVLZXkoKVxuICAgIH0sIHR5cGVvZiBlbnRyeSA9PT0gJ3N0cmluZycgPyBwYXJzZVBhdGgoZW50cnkpIDogZW50cnkpKTtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKGxvY2F0aW9uLnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nLCBcIlJlbGF0aXZlIHBhdGhuYW1lcyBhcmUgbm90IHN1cHBvcnRlZCBpbiBjcmVhdGVNZW1vcnlIaXN0b3J5KHsgaW5pdGlhbEVudHJpZXMgfSkgKGludmFsaWQgZW50cnk6IFwiICsgSlNPTi5zdHJpbmdpZnkoZW50cnkpICsgXCIpXCIpIDogdm9pZCAwO1xuICAgIHJldHVybiBsb2NhdGlvbjtcbiAgfSk7XG4gIHZhciBpbmRleCA9IGNsYW1wKGluaXRpYWxJbmRleCA9PSBudWxsID8gZW50cmllcy5sZW5ndGggLSAxIDogaW5pdGlhbEluZGV4LCAwLCBlbnRyaWVzLmxlbmd0aCAtIDEpO1xuICB2YXIgYWN0aW9uID0gQWN0aW9uLlBvcDtcbiAgdmFyIGxvY2F0aW9uID0gZW50cmllc1tpbmRleF07XG4gIHZhciBsaXN0ZW5lcnMgPSBjcmVhdGVFdmVudHMoKTtcbiAgdmFyIGJsb2NrZXJzID0gY3JlYXRlRXZlbnRzKCk7XG5cbiAgZnVuY3Rpb24gY3JlYXRlSHJlZih0bykge1xuICAgIHJldHVybiB0eXBlb2YgdG8gPT09ICdzdHJpbmcnID8gdG8gOiBjcmVhdGVQYXRoKHRvKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldE5leHRMb2NhdGlvbih0bywgc3RhdGUpIHtcbiAgICBpZiAoc3RhdGUgPT09IHZvaWQgMCkge1xuICAgICAgc3RhdGUgPSBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiByZWFkT25seShfZXh0ZW5kcyh7XG4gICAgICBwYXRobmFtZTogbG9jYXRpb24ucGF0aG5hbWUsXG4gICAgICBzZWFyY2g6ICcnLFxuICAgICAgaGFzaDogJydcbiAgICB9LCB0eXBlb2YgdG8gPT09ICdzdHJpbmcnID8gcGFyc2VQYXRoKHRvKSA6IHRvLCB7XG4gICAgICBzdGF0ZTogc3RhdGUsXG4gICAgICBrZXk6IGNyZWF0ZUtleSgpXG4gICAgfSkpO1xuICB9XG5cbiAgZnVuY3Rpb24gYWxsb3dUeChhY3Rpb24sIGxvY2F0aW9uLCByZXRyeSkge1xuICAgIHJldHVybiAhYmxvY2tlcnMubGVuZ3RoIHx8IChibG9ja2Vycy5jYWxsKHtcbiAgICAgIGFjdGlvbjogYWN0aW9uLFxuICAgICAgbG9jYXRpb246IGxvY2F0aW9uLFxuICAgICAgcmV0cnk6IHJldHJ5XG4gICAgfSksIGZhbHNlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFwcGx5VHgobmV4dEFjdGlvbiwgbmV4dExvY2F0aW9uKSB7XG4gICAgYWN0aW9uID0gbmV4dEFjdGlvbjtcbiAgICBsb2NhdGlvbiA9IG5leHRMb2NhdGlvbjtcbiAgICBsaXN0ZW5lcnMuY2FsbCh7XG4gICAgICBhY3Rpb246IGFjdGlvbixcbiAgICAgIGxvY2F0aW9uOiBsb2NhdGlvblxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gcHVzaCh0bywgc3RhdGUpIHtcbiAgICB2YXIgbmV4dEFjdGlvbiA9IEFjdGlvbi5QdXNoO1xuICAgIHZhciBuZXh0TG9jYXRpb24gPSBnZXROZXh0TG9jYXRpb24odG8sIHN0YXRlKTtcblxuICAgIGZ1bmN0aW9uIHJldHJ5KCkge1xuICAgICAgcHVzaCh0bywgc3RhdGUpO1xuICAgIH1cblxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcobG9jYXRpb24ucGF0aG5hbWUuY2hhckF0KDApID09PSAnLycsIFwiUmVsYXRpdmUgcGF0aG5hbWVzIGFyZSBub3Qgc3VwcG9ydGVkIGluIG1lbW9yeSBoaXN0b3J5LnB1c2goXCIgKyBKU09OLnN0cmluZ2lmeSh0bykgKyBcIilcIikgOiB2b2lkIDA7XG5cbiAgICBpZiAoYWxsb3dUeChuZXh0QWN0aW9uLCBuZXh0TG9jYXRpb24sIHJldHJ5KSkge1xuICAgICAgaW5kZXggKz0gMTtcbiAgICAgIGVudHJpZXMuc3BsaWNlKGluZGV4LCBlbnRyaWVzLmxlbmd0aCwgbmV4dExvY2F0aW9uKTtcbiAgICAgIGFwcGx5VHgobmV4dEFjdGlvbiwgbmV4dExvY2F0aW9uKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZXBsYWNlKHRvLCBzdGF0ZSkge1xuICAgIHZhciBuZXh0QWN0aW9uID0gQWN0aW9uLlJlcGxhY2U7XG4gICAgdmFyIG5leHRMb2NhdGlvbiA9IGdldE5leHRMb2NhdGlvbih0bywgc3RhdGUpO1xuXG4gICAgZnVuY3Rpb24gcmV0cnkoKSB7XG4gICAgICByZXBsYWNlKHRvLCBzdGF0ZSk7XG4gICAgfVxuXG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhsb2NhdGlvbi5wYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJywgXCJSZWxhdGl2ZSBwYXRobmFtZXMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gbWVtb3J5IGhpc3RvcnkucmVwbGFjZShcIiArIEpTT04uc3RyaW5naWZ5KHRvKSArIFwiKVwiKSA6IHZvaWQgMDtcblxuICAgIGlmIChhbGxvd1R4KG5leHRBY3Rpb24sIG5leHRMb2NhdGlvbiwgcmV0cnkpKSB7XG4gICAgICBlbnRyaWVzW2luZGV4XSA9IG5leHRMb2NhdGlvbjtcbiAgICAgIGFwcGx5VHgobmV4dEFjdGlvbiwgbmV4dExvY2F0aW9uKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnbyhkZWx0YSkge1xuICAgIHZhciBuZXh0SW5kZXggPSBjbGFtcChpbmRleCArIGRlbHRhLCAwLCBlbnRyaWVzLmxlbmd0aCAtIDEpO1xuICAgIHZhciBuZXh0QWN0aW9uID0gQWN0aW9uLlBvcDtcbiAgICB2YXIgbmV4dExvY2F0aW9uID0gZW50cmllc1tuZXh0SW5kZXhdO1xuXG4gICAgZnVuY3Rpb24gcmV0cnkoKSB7XG4gICAgICBnbyhkZWx0YSk7XG4gICAgfVxuXG4gICAgaWYgKGFsbG93VHgobmV4dEFjdGlvbiwgbmV4dExvY2F0aW9uLCByZXRyeSkpIHtcbiAgICAgIGluZGV4ID0gbmV4dEluZGV4O1xuICAgICAgYXBwbHlUeChuZXh0QWN0aW9uLCBuZXh0TG9jYXRpb24pO1xuICAgIH1cbiAgfVxuXG4gIHZhciBoaXN0b3J5ID0ge1xuICAgIGdldCBpbmRleCgpIHtcbiAgICAgIHJldHVybiBpbmRleDtcbiAgICB9LFxuXG4gICAgZ2V0IGFjdGlvbigpIHtcbiAgICAgIHJldHVybiBhY3Rpb247XG4gICAgfSxcblxuICAgIGdldCBsb2NhdGlvbigpIHtcbiAgICAgIHJldHVybiBsb2NhdGlvbjtcbiAgICB9LFxuXG4gICAgY3JlYXRlSHJlZjogY3JlYXRlSHJlZixcbiAgICBwdXNoOiBwdXNoLFxuICAgIHJlcGxhY2U6IHJlcGxhY2UsXG4gICAgZ286IGdvLFxuICAgIGJhY2s6IGZ1bmN0aW9uIGJhY2soKSB7XG4gICAgICBnbygtMSk7XG4gICAgfSxcbiAgICBmb3J3YXJkOiBmdW5jdGlvbiBmb3J3YXJkKCkge1xuICAgICAgZ28oMSk7XG4gICAgfSxcbiAgICBsaXN0ZW46IGZ1bmN0aW9uIGxpc3RlbihsaXN0ZW5lcikge1xuICAgICAgcmV0dXJuIGxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICB9LFxuICAgIGJsb2NrOiBmdW5jdGlvbiBibG9jayhibG9ja2VyKSB7XG4gICAgICByZXR1cm4gYmxvY2tlcnMucHVzaChibG9ja2VyKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBoaXN0b3J5O1xufSAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gVVRJTFNcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbmZ1bmN0aW9uIGNsYW1wKG4sIGxvd2VyQm91bmQsIHVwcGVyQm91bmQpIHtcbiAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KG4sIGxvd2VyQm91bmQpLCB1cHBlckJvdW5kKTtcbn1cblxuZnVuY3Rpb24gcHJvbXB0QmVmb3JlVW5sb2FkKGV2ZW50KSB7XG4gIC8vIENhbmNlbCB0aGUgZXZlbnQuXG4gIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7IC8vIENocm9tZSAoYW5kIGxlZ2FjeSBJRSkgcmVxdWlyZXMgcmV0dXJuVmFsdWUgdG8gYmUgc2V0LlxuXG4gIGV2ZW50LnJldHVyblZhbHVlID0gJyc7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUV2ZW50cygpIHtcbiAgdmFyIGhhbmRsZXJzID0gW107XG4gIHJldHVybiB7XG4gICAgZ2V0IGxlbmd0aCgpIHtcbiAgICAgIHJldHVybiBoYW5kbGVycy5sZW5ndGg7XG4gICAgfSxcblxuICAgIHB1c2g6IGZ1bmN0aW9uIHB1c2goZm4pIHtcbiAgICAgIGhhbmRsZXJzLnB1c2goZm4pO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaGFuZGxlcnMgPSBoYW5kbGVycy5maWx0ZXIoZnVuY3Rpb24gKGhhbmRsZXIpIHtcbiAgICAgICAgICByZXR1cm4gaGFuZGxlciAhPT0gZm47XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICB9LFxuICAgIGNhbGw6IGZ1bmN0aW9uIGNhbGwoYXJnKSB7XG4gICAgICBoYW5kbGVycy5mb3JFYWNoKGZ1bmN0aW9uIChmbikge1xuICAgICAgICByZXR1cm4gZm4gJiYgZm4oYXJnKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlS2V5KCkge1xuICByZXR1cm4gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyKDIsIDgpO1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBzdHJpbmcgVVJMIHBhdGggZnJvbSB0aGUgZ2l2ZW4gcGF0aG5hbWUsIHNlYXJjaCwgYW5kIGhhc2ggY29tcG9uZW50cy5cclxuICpcclxuICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vcmVtaXgtcnVuL2hpc3RvcnkvdHJlZS9tYWluL2RvY3MvYXBpLXJlZmVyZW5jZS5tZCNjcmVhdGVwYXRoXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGNyZWF0ZVBhdGgoX3JlZikge1xuICB2YXIgX3JlZiRwYXRobmFtZSA9IF9yZWYucGF0aG5hbWUsXG4gICAgICBwYXRobmFtZSA9IF9yZWYkcGF0aG5hbWUgPT09IHZvaWQgMCA/ICcvJyA6IF9yZWYkcGF0aG5hbWUsXG4gICAgICBfcmVmJHNlYXJjaCA9IF9yZWYuc2VhcmNoLFxuICAgICAgc2VhcmNoID0gX3JlZiRzZWFyY2ggPT09IHZvaWQgMCA/ICcnIDogX3JlZiRzZWFyY2gsXG4gICAgICBfcmVmJGhhc2ggPSBfcmVmLmhhc2gsXG4gICAgICBoYXNoID0gX3JlZiRoYXNoID09PSB2b2lkIDAgPyAnJyA6IF9yZWYkaGFzaDtcbiAgaWYgKHNlYXJjaCAmJiBzZWFyY2ggIT09ICc/JykgcGF0aG5hbWUgKz0gc2VhcmNoLmNoYXJBdCgwKSA9PT0gJz8nID8gc2VhcmNoIDogJz8nICsgc2VhcmNoO1xuICBpZiAoaGFzaCAmJiBoYXNoICE9PSAnIycpIHBhdGhuYW1lICs9IGhhc2guY2hhckF0KDApID09PSAnIycgPyBoYXNoIDogJyMnICsgaGFzaDtcbiAgcmV0dXJuIHBhdGhuYW1lO1xufVxuLyoqXHJcbiAqIFBhcnNlcyBhIHN0cmluZyBVUkwgcGF0aCBpbnRvIGl0cyBzZXBhcmF0ZSBwYXRobmFtZSwgc2VhcmNoLCBhbmQgaGFzaCBjb21wb25lbnRzLlxyXG4gKlxyXG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9yZW1peC1ydW4vaGlzdG9yeS90cmVlL21haW4vZG9jcy9hcGktcmVmZXJlbmNlLm1kI3BhcnNlcGF0aFxyXG4gKi9cblxuZnVuY3Rpb24gcGFyc2VQYXRoKHBhdGgpIHtcbiAgdmFyIHBhcnNlZFBhdGggPSB7fTtcblxuICBpZiAocGF0aCkge1xuICAgIHZhciBoYXNoSW5kZXggPSBwYXRoLmluZGV4T2YoJyMnKTtcblxuICAgIGlmIChoYXNoSW5kZXggPj0gMCkge1xuICAgICAgcGFyc2VkUGF0aC5oYXNoID0gcGF0aC5zdWJzdHIoaGFzaEluZGV4KTtcbiAgICAgIHBhdGggPSBwYXRoLnN1YnN0cigwLCBoYXNoSW5kZXgpO1xuICAgIH1cblxuICAgIHZhciBzZWFyY2hJbmRleCA9IHBhdGguaW5kZXhPZignPycpO1xuXG4gICAgaWYgKHNlYXJjaEluZGV4ID49IDApIHtcbiAgICAgIHBhcnNlZFBhdGguc2VhcmNoID0gcGF0aC5zdWJzdHIoc2VhcmNoSW5kZXgpO1xuICAgICAgcGF0aCA9IHBhdGguc3Vic3RyKDAsIHNlYXJjaEluZGV4KTtcbiAgICB9XG5cbiAgICBpZiAocGF0aCkge1xuICAgICAgcGFyc2VkUGF0aC5wYXRobmFtZSA9IHBhdGg7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBhcnNlZFBhdGg7XG59XG5cbmV4cG9ydCB7IEFjdGlvbiwgY3JlYXRlQnJvd3Nlckhpc3RvcnksIGNyZWF0ZUhhc2hIaXN0b3J5LCBjcmVhdGVNZW1vcnlIaXN0b3J5LCBjcmVhdGVQYXRoLCBwYXJzZVBhdGggfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbIl9leHRlbmRzIiwiQWN0aW9uIiwicmVhZE9ubHkiLCJwcm9jZXNzIiwib2JqIiwiT2JqZWN0IiwiZnJlZXplIiwid2FybmluZyIsImNvbmQiLCJtZXNzYWdlIiwiY29uc29sZSIsIndhcm4iLCJFcnJvciIsImUiLCJCZWZvcmVVbmxvYWRFdmVudFR5cGUiLCJIYXNoQ2hhbmdlRXZlbnRUeXBlIiwiUG9wU3RhdGVFdmVudFR5cGUiLCJjcmVhdGVCcm93c2VySGlzdG9yeSIsIm9wdGlvbnMiLCJfb3B0aW9ucyIsIl9vcHRpb25zJHdpbmRvdyIsIndpbmRvdyIsImRvY3VtZW50IiwiZGVmYXVsdFZpZXciLCJnbG9iYWxIaXN0b3J5IiwiaGlzdG9yeSIsImdldEluZGV4QW5kTG9jYXRpb24iLCJfd2luZG93JGxvY2F0aW9uIiwibG9jYXRpb24iLCJwYXRobmFtZSIsInNlYXJjaCIsImhhc2giLCJzdGF0ZSIsImlkeCIsInVzciIsImtleSIsImJsb2NrZWRQb3BUeCIsImhhbmRsZVBvcCIsImJsb2NrZXJzIiwiY2FsbCIsIm5leHRBY3Rpb24iLCJQb3AiLCJfZ2V0SW5kZXhBbmRMb2NhdGlvbiIsIm5leHRJbmRleCIsIm5leHRMb2NhdGlvbiIsImxlbmd0aCIsImRlbHRhIiwiaW5kZXgiLCJhY3Rpb24iLCJyZXRyeSIsImdvIiwiYXBwbHlUeCIsImFkZEV2ZW50TGlzdGVuZXIiLCJfZ2V0SW5kZXhBbmRMb2NhdGlvbjIiLCJsaXN0ZW5lcnMiLCJjcmVhdGVFdmVudHMiLCJyZXBsYWNlU3RhdGUiLCJjcmVhdGVIcmVmIiwidG8iLCJjcmVhdGVQYXRoIiwiZ2V0TmV4dExvY2F0aW9uIiwicGFyc2VQYXRoIiwiY3JlYXRlS2V5IiwiZ2V0SGlzdG9yeVN0YXRlQW5kVXJsIiwiYWxsb3dUeCIsIl9nZXRJbmRleEFuZExvY2F0aW9uMyIsInB1c2giLCJQdXNoIiwiX2dldEhpc3RvcnlTdGF0ZUFuZFVyIiwiaGlzdG9yeVN0YXRlIiwidXJsIiwicHVzaFN0YXRlIiwiZXJyb3IiLCJhc3NpZ24iLCJyZXBsYWNlIiwiUmVwbGFjZSIsIl9nZXRIaXN0b3J5U3RhdGVBbmRVcjIiLCJiYWNrIiwiZm9yd2FyZCIsImxpc3RlbiIsImxpc3RlbmVyIiwiYmxvY2siLCJibG9ja2VyIiwidW5ibG9jayIsInByb21wdEJlZm9yZVVubG9hZCIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJjcmVhdGVIYXNoSGlzdG9yeSIsIl9vcHRpb25zMiIsIl9vcHRpb25zMiR3aW5kb3ciLCJfcGFyc2VQYXRoIiwic3Vic3RyIiwiX3BhcnNlUGF0aCRwYXRobmFtZSIsIl9wYXJzZVBhdGgkc2VhcmNoIiwiX3BhcnNlUGF0aCRoYXNoIiwiX2dldEluZGV4QW5kTG9jYXRpb240IiwiX2dldEluZGV4QW5kTG9jYXRpb241IiwiX2dldEluZGV4QW5kTG9jYXRpb242IiwiZ2V0QmFzZUhyZWYiLCJiYXNlIiwicXVlcnlTZWxlY3RvciIsImhyZWYiLCJnZXRBdHRyaWJ1dGUiLCJoYXNoSW5kZXgiLCJpbmRleE9mIiwic2xpY2UiLCJfZ2V0SW5kZXhBbmRMb2NhdGlvbjciLCJjaGFyQXQiLCJKU09OIiwic3RyaW5naWZ5IiwiX2dldEhpc3RvcnlTdGF0ZUFuZFVyMyIsIl9nZXRIaXN0b3J5U3RhdGVBbmRVcjQiLCJjcmVhdGVNZW1vcnlIaXN0b3J5IiwiX29wdGlvbnMzIiwiX29wdGlvbnMzJGluaXRpYWxFbnRyIiwiaW5pdGlhbEVudHJpZXMiLCJpbml0aWFsSW5kZXgiLCJlbnRyaWVzIiwibWFwIiwiZW50cnkiLCJjbGFtcCIsInNwbGljZSIsIm4iLCJsb3dlckJvdW5kIiwidXBwZXJCb3VuZCIsIk1hdGgiLCJtaW4iLCJtYXgiLCJldmVudCIsInByZXZlbnREZWZhdWx0IiwicmV0dXJuVmFsdWUiLCJoYW5kbGVycyIsImZuIiwiZmlsdGVyIiwiaGFuZGxlciIsImFyZyIsImZvckVhY2giLCJyYW5kb20iLCJ0b1N0cmluZyIsIl9yZWYiLCJfcmVmJHBhdGhuYW1lIiwiX3JlZiRzZWFyY2giLCJfcmVmJGhhc2giLCJwYXRoIiwicGFyc2VkUGF0aCIsInNlYXJjaEluZGV4Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/history/index.js\n");

/***/ })

};
;
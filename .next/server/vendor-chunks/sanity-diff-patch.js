"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/sanity-diff-patch";
exports.ids = ["vendor-chunks/sanity-diff-patch"];
exports.modules = {

/***/ "(ssr)/./node_modules/sanity-diff-patch/dist/index.js":
/*!******************************************************!*\
  !*** ./node_modules/sanity-diff-patch/dist/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DiffError: () => (/* binding */ DiffError),\n/* harmony export */   diffItem: () => (/* binding */ diffItem),\n/* harmony export */   diffPatch: () => (/* binding */ diffPatch)\n/* harmony export */ });\n/* harmony import */ var _sanity_diff_match_patch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @sanity/diff-match-patch */ \"(ssr)/./node_modules/@sanity/diff-match-patch/dist/index.js\");\n\nfunction pathToString(path) {\n    return path.reduce((target, segment, i)=>{\n        if (Array.isArray(segment)) {\n            return \"\".concat(target, \"[\").concat(segment.join(\":\"), \"]\");\n        }\n        if (isKeyedObject(segment)) {\n            return \"\".concat(target, '[_key==\"').concat(segment._key, '\"]');\n        }\n        if (typeof segment === \"number\") {\n            return \"\".concat(target, \"[\").concat(segment, \"]\");\n        } else if (typeof segment === \"string\" && /^\\d+$/.test(segment)) {\n            return \"\".concat(target, '[\"').concat(segment, '\"]');\n        }\n        if (typeof segment === \"string\") {\n            const separator = i === 0 ? \"\" : \".\";\n            return \"\".concat(target).concat(separator).concat(segment);\n        }\n        throw new Error('Unsupported path segment \"'.concat(segment, '\"'));\n    }, \"\");\n}\nfunction isKeyedObject(obj) {\n    return typeof obj === \"object\" && typeof obj._key === \"string\";\n}\nclass DiffError extends Error {\n    constructor(message, path, value){\n        const serializedPath = pathToString(path);\n        super(\"\".concat(message, \" (at '\").concat(serializedPath, \"')\"));\n        this.path = path;\n        this.serializedPath = serializedPath;\n        this.value = value;\n    }\n}\nconst idPattern = /^[a-z0-9][a-z0-9_.-]+$/i;\nconst propPattern = /^[a-zA-Z_][a-zA-Z0-9_]*$/;\nconst propStartPattern = /^[a-z_]/i;\nfunction validateProperty(property, value, path) {\n    if (!propStartPattern.test(property)) {\n        throw new DiffError(\"Keys must start with a letter (a-z)\", path.concat(property), value);\n    }\n    if (!propPattern.test(property)) {\n        throw new DiffError(\"Keys can only contain letters, numbers and underscores\", path.concat(property), value);\n    }\n    if (property === \"_key\" || property === \"_ref\" || property === \"_type\") {\n        if (typeof value !== \"string\") {\n            throw new DiffError(\"Keys must be strings\", path.concat(property), value);\n        }\n        if (!idPattern.test(value)) {\n            throw new DiffError(\"Invalid key - use less exotic characters\", path.concat(property), value);\n        }\n    }\n    return property;\n}\nconst ignoredKeys = [\n    \"_id\",\n    \"_type\",\n    \"_createdAt\",\n    \"_updatedAt\",\n    \"_rev\"\n];\nconst defaultOptions = {\n    hideWarnings: false,\n    diffMatchPatch: {\n        enabled: true,\n        // Only use diff-match-patch if target string is longer than this threshold\n        lengthThresholdAbsolute: 30,\n        // Only use generated diff-match-patch if the patch length is less than or equal to\n        // (targetString * relative). Example: A 100 character target with a relative factor\n        // of 1.2 will allow a 120 character diff-match-patch. If larger than this number,\n        // it will fall back to a regular `set` patch.\n        lengthThresholdRelative: 1.2\n    }\n};\nfunction mergeOptions(options) {\n    return {\n        ...defaultOptions,\n        ...options,\n        diffMatchPatch: {\n            ...defaultOptions.diffMatchPatch,\n            ...options.diffMatchPatch || {}\n        }\n    };\n}\nfunction diffPatch(itemA, itemB, opts) {\n    const options = mergeOptions(opts || {});\n    const id = options.id || itemA._id === itemB._id && itemA._id;\n    const revisionLocked = options.ifRevisionID;\n    const ifRevisionID = typeof revisionLocked === \"boolean\" ? itemA._rev : revisionLocked;\n    const basePath = options.basePath || [];\n    if (!id) {\n        throw new Error(\"_id on itemA and itemB not present or differs, specify document id the mutations should be applied to\");\n    }\n    if (revisionLocked === true && !ifRevisionID) {\n        throw new Error(\"`ifRevisionID` is set to `true`, but no `_rev` was passed in item A. Either explicitly set `ifRevisionID` to a revision, or pass `_rev` as part of item A.\");\n    }\n    if (basePath.length === 0 && itemA._type !== itemB._type) {\n        throw new Error(\"_type is immutable and cannot be changed (\".concat(itemA._type, \" => \").concat(itemB._type, \")\"));\n    }\n    const operations = diffItem(itemA, itemB, options, basePath, []);\n    return serializePatches(operations, {\n        id,\n        ifRevisionID: revisionLocked ? ifRevisionID : void 0\n    });\n}\nfunction diffItem(itemA, itemB) {\n    let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultOptions;\n    let path = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n    let patches = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];\n    if (itemA === itemB) {\n        return patches;\n    }\n    const aType = Array.isArray(itemA) ? \"array\" : typeof itemA;\n    const bType = Array.isArray(itemB) ? \"array\" : typeof itemB;\n    const aIsUndefined = aType === \"undefined\";\n    const bIsUndefined = bType === \"undefined\";\n    if (aIsUndefined && !bIsUndefined) {\n        patches.push({\n            op: \"set\",\n            path,\n            value: itemB\n        });\n        return patches;\n    }\n    if (!aIsUndefined && bIsUndefined) {\n        patches.push({\n            op: \"unset\",\n            path\n        });\n        return patches;\n    }\n    const options = mergeOptions(opts);\n    const dataType = aIsUndefined ? bType : aType;\n    const isContainer = dataType === \"object\" || dataType === \"array\";\n    if (!isContainer) {\n        return diffPrimitive(itemA, itemB, options, path, patches);\n    }\n    if (aType !== bType) {\n        patches.push({\n            op: \"set\",\n            path,\n            value: itemB\n        });\n        return patches;\n    }\n    return dataType === \"array\" ? diffArray(itemA, itemB, options, path, patches) : diffObject(itemA, itemB, options, path, patches);\n}\nfunction diffObject(itemA, itemB, options, path, patches) {\n    const atRoot = path.length === 0;\n    const aKeys = Object.keys(itemA).filter(atRoot ? isNotIgnoredKey : yes).map((key)=>validateProperty(key, itemA[key], path));\n    const aKeysLength = aKeys.length;\n    const bKeys = Object.keys(itemB).filter(atRoot ? isNotIgnoredKey : yes).map((key)=>validateProperty(key, itemB[key], path));\n    const bKeysLength = bKeys.length;\n    for(let i = 0; i < aKeysLength; i++){\n        const key = aKeys[i];\n        if (!(key in itemB)) {\n            patches.push({\n                op: \"unset\",\n                path: path.concat(key)\n            });\n        }\n    }\n    for(let i = 0; i < bKeysLength; i++){\n        const key = bKeys[i];\n        diffItem(itemA[key], itemB[key], options, path.concat([\n            key\n        ]), patches);\n    }\n    return patches;\n}\nfunction diffArray(itemA, itemB, options, path, patches) {\n    if (itemB.length > itemA.length) {\n        patches.push({\n            op: \"insert\",\n            after: path.concat([\n                -1\n            ]),\n            items: itemB.slice(itemA.length).map((item, i)=>nullifyUndefined(item, path, i, options))\n        });\n    }\n    if (itemB.length < itemA.length) {\n        const isSingle = itemA.length - itemB.length === 1;\n        const unsetItems = itemA.slice(itemB.length);\n        if (isRevisionLocked(options) || !isUniquelyKeyed(unsetItems)) {\n            patches.push({\n                op: \"unset\",\n                path: path.concat([\n                    isSingle ? itemB.length : [\n                        itemB.length,\n                        \"\"\n                    ]\n                ])\n            });\n        } else {\n            patches.push(...unsetItems.map((item)=>({\n                    op: \"unset\",\n                    path: path.concat({\n                        _key: item._key\n                    })\n                })));\n        }\n    }\n    for(let i = 0; i < itemB.length; i++){\n        if (Array.isArray(itemB[i])) {\n            throw new DiffError(\"Multi-dimensional arrays not supported\", path.concat(i), itemB[i]);\n        }\n    }\n    const overlapping = Math.min(itemA.length, itemB.length);\n    const segmentA = itemA.slice(0, overlapping);\n    const segmentB = itemB.slice(0, overlapping);\n    return isUniquelyKeyed(segmentA) && isUniquelyKeyed(segmentB) ? diffArrayByKey(segmentA, segmentB, options, path, patches) : diffArrayByIndex(segmentA, segmentB, options, path, patches);\n}\nfunction diffArrayByIndex(itemA, itemB, options, path, patches) {\n    for(let i = 0; i < itemA.length; i++){\n        diffItem(itemA[i], nullifyUndefined(itemB[i], path, i, options), options, path.concat(i), patches);\n    }\n    return patches;\n}\nfunction diffArrayByKey(itemA, itemB, options, path, patches) {\n    const keyedA = indexByKey(itemA);\n    const keyedB = indexByKey(itemB);\n    if (!arrayIsEqual(keyedA.keys, keyedB.keys)) {\n        return diffArrayByIndex(itemA, itemB, options, path, patches);\n    }\n    for(let i = 0; i < keyedB.keys.length; i++){\n        const key = keyedB.keys[i];\n        const valueA = keyedA.index[key];\n        const valueB = nullifyUndefined(keyedB.index[key], path, i, options);\n        diffItem(valueA, valueB, options, path.concat({\n            _key: key\n        }), patches);\n    }\n    return patches;\n}\nfunction getDiffMatchPatch(itemA, itemB, options, path) {\n    const { enabled, lengthThresholdRelative, lengthThresholdAbsolute } = options.diffMatchPatch;\n    const segment = path[path.length - 1];\n    if (!enabled || // Don't use for anything but strings\n    typeof itemA !== \"string\" || typeof itemB !== \"string\" || // Don't use for `_key`, `_ref` etc\n    typeof segment === \"string\" && segment[0] === \"_\" || // Don't use on short strings\n    itemB.length < lengthThresholdAbsolute) {\n        return void 0;\n    }\n    let strPatch = \"\";\n    try {\n        const patch = (0,_sanity_diff_match_patch__WEBPACK_IMPORTED_MODULE_0__.makeDiff)(itemA, itemB);\n        const diff = (0,_sanity_diff_match_patch__WEBPACK_IMPORTED_MODULE_0__.cleanupEfficiency)(patch);\n        strPatch = (0,_sanity_diff_match_patch__WEBPACK_IMPORTED_MODULE_0__.stringifyPatches)((0,_sanity_diff_match_patch__WEBPACK_IMPORTED_MODULE_0__.makePatches)(diff));\n    } catch (err) {\n        return void 0;\n    }\n    return strPatch.length > itemB.length * lengthThresholdRelative ? void 0 : {\n        op: \"diffMatchPatch\",\n        path,\n        value: strPatch\n    };\n}\nfunction diffPrimitive(itemA, itemB, options, path, patches) {\n    const dmp = getDiffMatchPatch(itemA, itemB, options, path);\n    patches.push(dmp || {\n        op: \"set\",\n        path,\n        value: itemB\n    });\n    return patches;\n}\nfunction isNotIgnoredKey(key) {\n    return ignoredKeys.indexOf(key) === -1;\n}\nfunction serializePatches(patches, options) {\n    if (patches.length === 0) {\n        return [];\n    }\n    const { id, ifRevisionID } = options;\n    const set = patches.filter((patch)=>patch.op === \"set\");\n    const unset = patches.filter((patch)=>patch.op === \"unset\");\n    const insert = patches.filter((patch)=>patch.op === \"insert\");\n    const dmp = patches.filter((patch)=>patch.op === \"diffMatchPatch\");\n    const withSet = set.length > 0 && set.reduce((patch, item)=>{\n        const path = pathToString(item.path);\n        patch.set[path] = item.value;\n        return patch;\n    }, {\n        id,\n        set: {}\n    });\n    const withUnset = unset.length > 0 && unset.reduce((patch, item)=>{\n        const path = pathToString(item.path);\n        patch.unset.push(path);\n        return patch;\n    }, {\n        id,\n        unset: []\n    });\n    const withInsert = insert.reduce((acc, item)=>{\n        const after = pathToString(item.after);\n        return acc.concat({\n            id,\n            insert: {\n                after,\n                items: item.items\n            }\n        });\n    }, []);\n    const withDmp = dmp.length > 0 && dmp.reduce((patch, item)=>{\n        const path = pathToString(item.path);\n        patch.diffMatchPatch[path] = item.value;\n        return patch;\n    }, {\n        id,\n        diffMatchPatch: {}\n    });\n    const patchSet = [\n        withSet,\n        withUnset,\n        withDmp,\n        ...withInsert\n    ].filter((item)=>item !== false);\n    return patchSet.map((patch, i)=>({\n            patch: ifRevisionID && i === 0 ? {\n                ...patch,\n                ifRevisionID\n            } : patch\n        }));\n}\nfunction isUniquelyKeyed(arr) {\n    const keys = [];\n    for(let i = 0; i < arr.length; i++){\n        const key = getKey(arr[i]);\n        if (!key || keys.indexOf(key) !== -1) {\n            return false;\n        }\n        keys.push(key);\n    }\n    return true;\n}\nfunction getKey(obj) {\n    return typeof obj === \"object\" && obj !== null && obj._key;\n}\nfunction indexByKey(arr) {\n    return arr.reduce((acc, item)=>{\n        acc.keys.push(item._key);\n        acc.index[item._key] = item;\n        return acc;\n    }, {\n        keys: [],\n        index: {}\n    });\n}\nfunction arrayIsEqual(itemA, itemB) {\n    return itemA.length === itemB.length && itemA.every((item, i)=>itemB[i] === item);\n}\nfunction nullifyUndefined(item, path, index, options) {\n    if (typeof item !== \"undefined\") {\n        return item;\n    }\n    if (!options.hideWarnings) {\n        const serializedPath = pathToString(path.concat(index));\n        console.warn(\"undefined value in array converted to null (at '\".concat(serializedPath, \"')\"));\n    }\n    return null;\n}\nfunction isRevisionLocked(options) {\n    return Boolean(options.ifRevisionID);\n}\nfunction yes(_) {\n    return true;\n}\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc2FuaXR5LWRpZmYtcGF0Y2gvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQXNHO0FBQ3RHLFNBQVNJLGFBQWFDLElBQUk7SUFDeEIsT0FBT0EsS0FBS0MsTUFBTSxDQUFDLENBQUNDLFFBQVFDLFNBQVNDO1FBQ25DLElBQUlDLE1BQU1DLE9BQU8sQ0FBQ0gsVUFBVTtZQUMxQixPQUFPLEdBQUdJLE1BQU0sQ0FBQ0wsUUFBUSxLQUFLSyxNQUFNLENBQUNKLFFBQVFLLElBQUksQ0FBQyxNQUFNO1FBQzFEO1FBQ0EsSUFBSUMsY0FBY04sVUFBVTtZQUMxQixPQUFPLEdBQUdJLE1BQU0sQ0FBQ0wsUUFBUSxZQUFhSyxNQUFNLENBQUNKLFFBQVFPLElBQUksRUFBRTtRQUM3RDtRQUNBLElBQUksT0FBT1AsWUFBWSxVQUFVO1lBQy9CLE9BQU8sR0FBR0ksTUFBTSxDQUFDTCxRQUFRLEtBQUtLLE1BQU0sQ0FBQ0osU0FBUztRQUNoRCxPQUFPLElBQUksT0FBT0EsWUFBWSxZQUFZLFFBQVFRLElBQUksQ0FBQ1IsVUFBVTtZQUMvRCxPQUFPLEdBQUdJLE1BQU0sQ0FBQ0wsUUFBUSxNQUFPSyxNQUFNLENBQUNKLFNBQVM7UUFDbEQ7UUFDQSxJQUFJLE9BQU9BLFlBQVksVUFBVTtZQUMvQixNQUFNUyxZQUFZUixNQUFNLElBQUksS0FBSztZQUNqQyxPQUFPLEdBQUdHLE1BQU0sQ0FBQ0wsUUFBUUssTUFBTSxDQUFDSyxXQUFXTCxNQUFNLENBQUNKO1FBQ3BEO1FBQ0EsTUFBTSxJQUFJVSxNQUFNLDZCQUE4Qk4sTUFBTSxDQUFDSixTQUFTO0lBQ2hFLEdBQUc7QUFDTDtBQUNBLFNBQVNNLGNBQWNLLEdBQUc7SUFDeEIsT0FBTyxPQUFPQSxRQUFRLFlBQVksT0FBT0EsSUFBSUosSUFBSSxLQUFLO0FBQ3hEO0FBQ0EsTUFBTUssa0JBQWtCRjtJQUN0QkcsWUFBWUMsT0FBTyxFQUFFakIsSUFBSSxFQUFFa0IsS0FBSyxDQUFF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QixPQUFPQTtJQUNUO0lBQ0EsSUFBSSxDQUFDN0MsUUFBUU4sWUFBWSxFQUFFO1FBQ3pCLE1BQU1SLGlCQUFpQnBCLGFBQWFDLEtBQUtPLE1BQU0sQ0FBQ3lGO1FBQ2hEcUIsUUFBUUMsSUFBSSxDQUFDLG1EQUFtRC9HLE1BQU0sQ0FBQ1ksZ0JBQWdCO0lBQ3pGO0lBQ0EsT0FBTztBQUNUO0FBQ0EsU0FBUytELGlCQUFpQmpELE9BQU87SUFDL0IsT0FBT3NGLFFBQVF0RixRQUFRUSxZQUFZO0FBQ3JDO0FBQ0EsU0FBUzRCLElBQUltRCxDQUFDO0lBQ1osT0FBTztBQUNUO0FBQzBDLENBQzFDLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL29saS1jcm9zc2xhbmQtdmlkZW9ncmFwaHkvLi9ub2RlX21vZHVsZXMvc2FuaXR5LWRpZmYtcGF0Y2gvZGlzdC9pbmRleC5qcz9iM2NmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IG1ha2VEaWZmLCBjbGVhbnVwRWZmaWNpZW5jeSwgc3RyaW5naWZ5UGF0Y2hlcywgbWFrZVBhdGNoZXMgfSBmcm9tICdAc2FuaXR5L2RpZmYtbWF0Y2gtcGF0Y2gnO1xuZnVuY3Rpb24gcGF0aFRvU3RyaW5nKHBhdGgpIHtcbiAgcmV0dXJuIHBhdGgucmVkdWNlKCh0YXJnZXQsIHNlZ21lbnQsIGkpID0+IHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShzZWdtZW50KSkge1xuICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KHRhcmdldCwgXCJbXCIpLmNvbmNhdChzZWdtZW50LmpvaW4oXCI6XCIpLCBcIl1cIik7XG4gICAgfVxuICAgIGlmIChpc0tleWVkT2JqZWN0KHNlZ21lbnQpKSB7XG4gICAgICByZXR1cm4gXCJcIi5jb25jYXQodGFyZ2V0LCBcIltfa2V5PT1cXFwiXCIpLmNvbmNhdChzZWdtZW50Ll9rZXksIFwiXFxcIl1cIik7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygc2VnbWVudCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KHRhcmdldCwgXCJbXCIpLmNvbmNhdChzZWdtZW50LCBcIl1cIik7XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygc2VnbWVudCA9PT0gXCJzdHJpbmdcIiAmJiAvXlxcZCskLy50ZXN0KHNlZ21lbnQpKSB7XG4gICAgICByZXR1cm4gXCJcIi5jb25jYXQodGFyZ2V0LCBcIltcXFwiXCIpLmNvbmNhdChzZWdtZW50LCBcIlxcXCJdXCIpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHNlZ21lbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGNvbnN0IHNlcGFyYXRvciA9IGkgPT09IDAgPyBcIlwiIDogXCIuXCI7XG4gICAgICByZXR1cm4gXCJcIi5jb25jYXQodGFyZ2V0KS5jb25jYXQoc2VwYXJhdG9yKS5jb25jYXQoc2VnbWVudCk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIHBhdGggc2VnbWVudCBcXFwiXCIuY29uY2F0KHNlZ21lbnQsIFwiXFxcIlwiKSk7XG4gIH0sIFwiXCIpO1xufVxuZnVuY3Rpb24gaXNLZXllZE9iamVjdChvYmopIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmogPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG9iai5fa2V5ID09PSBcInN0cmluZ1wiO1xufVxuY2xhc3MgRGlmZkVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBwYXRoLCB2YWx1ZSkge1xuICAgIGNvbnN0IHNlcmlhbGl6ZWRQYXRoID0gcGF0aFRvU3RyaW5nKHBhdGgpO1xuICAgIHN1cGVyKFwiXCIuY29uY2F0KG1lc3NhZ2UsIFwiIChhdCAnXCIpLmNvbmNhdChzZXJpYWxpemVkUGF0aCwgXCInKVwiKSk7XG4gICAgdGhpcy5wYXRoID0gcGF0aDtcbiAgICB0aGlzLnNlcmlhbGl6ZWRQYXRoID0gc2VyaWFsaXplZFBhdGg7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICB9XG59XG5jb25zdCBpZFBhdHRlcm4gPSAvXlthLXowLTldW2EtejAtOV8uLV0rJC9pO1xuY29uc3QgcHJvcFBhdHRlcm4gPSAvXlthLXpBLVpfXVthLXpBLVowLTlfXSokLztcbmNvbnN0IHByb3BTdGFydFBhdHRlcm4gPSAvXlthLXpfXS9pO1xuZnVuY3Rpb24gdmFsaWRhdGVQcm9wZXJ0eShwcm9wZXJ0eSwgdmFsdWUsIHBhdGgpIHtcbiAgaWYgKCFwcm9wU3RhcnRQYXR0ZXJuLnRlc3QocHJvcGVydHkpKSB7XG4gICAgdGhyb3cgbmV3IERpZmZFcnJvcihcIktleXMgbXVzdCBzdGFydCB3aXRoIGEgbGV0dGVyIChhLXopXCIsIHBhdGguY29uY2F0KHByb3BlcnR5KSwgdmFsdWUpO1xuICB9XG4gIGlmICghcHJvcFBhdHRlcm4udGVzdChwcm9wZXJ0eSkpIHtcbiAgICB0aHJvdyBuZXcgRGlmZkVycm9yKFwiS2V5cyBjYW4gb25seSBjb250YWluIGxldHRlcnMsIG51bWJlcnMgYW5kIHVuZGVyc2NvcmVzXCIsIHBhdGguY29uY2F0KHByb3BlcnR5KSwgdmFsdWUpO1xuICB9XG4gIGlmIChwcm9wZXJ0eSA9PT0gXCJfa2V5XCIgfHwgcHJvcGVydHkgPT09IFwiX3JlZlwiIHx8IHByb3BlcnR5ID09PSBcIl90eXBlXCIpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aHJvdyBuZXcgRGlmZkVycm9yKFwiS2V5cyBtdXN0IGJlIHN0cmluZ3NcIiwgcGF0aC5jb25jYXQocHJvcGVydHkpLCB2YWx1ZSk7XG4gICAgfVxuICAgIGlmICghaWRQYXR0ZXJuLnRlc3QodmFsdWUpKSB7XG4gICAgICB0aHJvdyBuZXcgRGlmZkVycm9yKFwiSW52YWxpZCBrZXkgLSB1c2UgbGVzcyBleG90aWMgY2hhcmFjdGVyc1wiLCBwYXRoLmNvbmNhdChwcm9wZXJ0eSksIHZhbHVlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHByb3BlcnR5O1xufVxuY29uc3QgaWdub3JlZEtleXMgPSBbXCJfaWRcIiwgXCJfdHlwZVwiLCBcIl9jcmVhdGVkQXRcIiwgXCJfdXBkYXRlZEF0XCIsIFwiX3JldlwiXTtcbmNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xuICBoaWRlV2FybmluZ3M6IGZhbHNlLFxuICBkaWZmTWF0Y2hQYXRjaDoge1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgLy8gT25seSB1c2UgZGlmZi1tYXRjaC1wYXRjaCBpZiB0YXJnZXQgc3RyaW5nIGlzIGxvbmdlciB0aGFuIHRoaXMgdGhyZXNob2xkXG4gICAgbGVuZ3RoVGhyZXNob2xkQWJzb2x1dGU6IDMwLFxuICAgIC8vIE9ubHkgdXNlIGdlbmVyYXRlZCBkaWZmLW1hdGNoLXBhdGNoIGlmIHRoZSBwYXRjaCBsZW5ndGggaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvXG4gICAgLy8gKHRhcmdldFN0cmluZyAqIHJlbGF0aXZlKS4gRXhhbXBsZTogQSAxMDAgY2hhcmFjdGVyIHRhcmdldCB3aXRoIGEgcmVsYXRpdmUgZmFjdG9yXG4gICAgLy8gb2YgMS4yIHdpbGwgYWxsb3cgYSAxMjAgY2hhcmFjdGVyIGRpZmYtbWF0Y2gtcGF0Y2guIElmIGxhcmdlciB0aGFuIHRoaXMgbnVtYmVyLFxuICAgIC8vIGl0IHdpbGwgZmFsbCBiYWNrIHRvIGEgcmVndWxhciBgc2V0YCBwYXRjaC5cbiAgICBsZW5ndGhUaHJlc2hvbGRSZWxhdGl2ZTogMS4yXG4gIH1cbn07XG5mdW5jdGlvbiBtZXJnZU9wdGlvbnMob3B0aW9ucykge1xuICByZXR1cm4ge1xuICAgIC4uLmRlZmF1bHRPcHRpb25zLFxuICAgIC4uLm9wdGlvbnMsXG4gICAgZGlmZk1hdGNoUGF0Y2g6IHtcbiAgICAgIC4uLmRlZmF1bHRPcHRpb25zLmRpZmZNYXRjaFBhdGNoLFxuICAgICAgLi4uKG9wdGlvbnMuZGlmZk1hdGNoUGF0Y2ggfHwge30pXG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gZGlmZlBhdGNoKGl0ZW1BLCBpdGVtQiwgb3B0cykge1xuICBjb25zdCBvcHRpb25zID0gbWVyZ2VPcHRpb25zKG9wdHMgfHwge30pO1xuICBjb25zdCBpZCA9IG9wdGlvbnMuaWQgfHwgaXRlbUEuX2lkID09PSBpdGVtQi5faWQgJiYgaXRlbUEuX2lkO1xuICBjb25zdCByZXZpc2lvbkxvY2tlZCA9IG9wdGlvbnMuaWZSZXZpc2lvbklEO1xuICBjb25zdCBpZlJldmlzaW9uSUQgPSB0eXBlb2YgcmV2aXNpb25Mb2NrZWQgPT09IFwiYm9vbGVhblwiID8gaXRlbUEuX3JldiA6IHJldmlzaW9uTG9ja2VkO1xuICBjb25zdCBiYXNlUGF0aCA9IG9wdGlvbnMuYmFzZVBhdGggfHwgW107XG4gIGlmICghaWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJfaWQgb24gaXRlbUEgYW5kIGl0ZW1CIG5vdCBwcmVzZW50IG9yIGRpZmZlcnMsIHNwZWNpZnkgZG9jdW1lbnQgaWQgdGhlIG11dGF0aW9ucyBzaG91bGQgYmUgYXBwbGllZCB0b1wiKTtcbiAgfVxuICBpZiAocmV2aXNpb25Mb2NrZWQgPT09IHRydWUgJiYgIWlmUmV2aXNpb25JRCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImBpZlJldmlzaW9uSURgIGlzIHNldCB0byBgdHJ1ZWAsIGJ1dCBubyBgX3JldmAgd2FzIHBhc3NlZCBpbiBpdGVtIEEuIEVpdGhlciBleHBsaWNpdGx5IHNldCBgaWZSZXZpc2lvbklEYCB0byBhIHJldmlzaW9uLCBvciBwYXNzIGBfcmV2YCBhcyBwYXJ0IG9mIGl0ZW0gQS5cIik7XG4gIH1cbiAgaWYgKGJhc2VQYXRoLmxlbmd0aCA9PT0gMCAmJiBpdGVtQS5fdHlwZSAhPT0gaXRlbUIuX3R5cGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJfdHlwZSBpcyBpbW11dGFibGUgYW5kIGNhbm5vdCBiZSBjaGFuZ2VkIChcIi5jb25jYXQoaXRlbUEuX3R5cGUsIFwiID0+IFwiKS5jb25jYXQoaXRlbUIuX3R5cGUsIFwiKVwiKSk7XG4gIH1cbiAgY29uc3Qgb3BlcmF0aW9ucyA9IGRpZmZJdGVtKGl0ZW1BLCBpdGVtQiwgb3B0aW9ucywgYmFzZVBhdGgsIFtdKTtcbiAgcmV0dXJuIHNlcmlhbGl6ZVBhdGNoZXMob3BlcmF0aW9ucywge1xuICAgIGlkLFxuICAgIGlmUmV2aXNpb25JRDogcmV2aXNpb25Mb2NrZWQgPyBpZlJldmlzaW9uSUQgOiB2b2lkIDBcbiAgfSk7XG59XG5mdW5jdGlvbiBkaWZmSXRlbShpdGVtQSwgaXRlbUIpIHtcbiAgbGV0IG9wdHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGRlZmF1bHRPcHRpb25zO1xuICBsZXQgcGF0aCA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogW107XG4gIGxldCBwYXRjaGVzID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiBbXTtcbiAgaWYgKGl0ZW1BID09PSBpdGVtQikge1xuICAgIHJldHVybiBwYXRjaGVzO1xuICB9XG4gIGNvbnN0IGFUeXBlID0gQXJyYXkuaXNBcnJheShpdGVtQSkgPyBcImFycmF5XCIgOiB0eXBlb2YgaXRlbUE7XG4gIGNvbnN0IGJUeXBlID0gQXJyYXkuaXNBcnJheShpdGVtQikgPyBcImFycmF5XCIgOiB0eXBlb2YgaXRlbUI7XG4gIGNvbnN0IGFJc1VuZGVmaW5lZCA9IGFUeXBlID09PSBcInVuZGVmaW5lZFwiO1xuICBjb25zdCBiSXNVbmRlZmluZWQgPSBiVHlwZSA9PT0gXCJ1bmRlZmluZWRcIjtcbiAgaWYgKGFJc1VuZGVmaW5lZCAmJiAhYklzVW5kZWZpbmVkKSB7XG4gICAgcGF0Y2hlcy5wdXNoKHtcbiAgICAgIG9wOiBcInNldFwiLFxuICAgICAgcGF0aCxcbiAgICAgIHZhbHVlOiBpdGVtQlxuICAgIH0pO1xuICAgIHJldHVybiBwYXRjaGVzO1xuICB9XG4gIGlmICghYUlzVW5kZWZpbmVkICYmIGJJc1VuZGVmaW5lZCkge1xuICAgIHBhdGNoZXMucHVzaCh7XG4gICAgICBvcDogXCJ1bnNldFwiLFxuICAgICAgcGF0aFxuICAgIH0pO1xuICAgIHJldHVybiBwYXRjaGVzO1xuICB9XG4gIGNvbnN0IG9wdGlvbnMgPSBtZXJnZU9wdGlvbnMob3B0cyk7XG4gIGNvbnN0IGRhdGFUeXBlID0gYUlzVW5kZWZpbmVkID8gYlR5cGUgOiBhVHlwZTtcbiAgY29uc3QgaXNDb250YWluZXIgPSBkYXRhVHlwZSA9PT0gXCJvYmplY3RcIiB8fCBkYXRhVHlwZSA9PT0gXCJhcnJheVwiO1xuICBpZiAoIWlzQ29udGFpbmVyKSB7XG4gICAgcmV0dXJuIGRpZmZQcmltaXRpdmUoaXRlbUEsIGl0ZW1CLCBvcHRpb25zLCBwYXRoLCBwYXRjaGVzKTtcbiAgfVxuICBpZiAoYVR5cGUgIT09IGJUeXBlKSB7XG4gICAgcGF0Y2hlcy5wdXNoKHtcbiAgICAgIG9wOiBcInNldFwiLFxuICAgICAgcGF0aCxcbiAgICAgIHZhbHVlOiBpdGVtQlxuICAgIH0pO1xuICAgIHJldHVybiBwYXRjaGVzO1xuICB9XG4gIHJldHVybiBkYXRhVHlwZSA9PT0gXCJhcnJheVwiID8gZGlmZkFycmF5KGl0ZW1BLCBpdGVtQiwgb3B0aW9ucywgcGF0aCwgcGF0Y2hlcykgOiBkaWZmT2JqZWN0KGl0ZW1BLCBpdGVtQiwgb3B0aW9ucywgcGF0aCwgcGF0Y2hlcyk7XG59XG5mdW5jdGlvbiBkaWZmT2JqZWN0KGl0ZW1BLCBpdGVtQiwgb3B0aW9ucywgcGF0aCwgcGF0Y2hlcykge1xuICBjb25zdCBhdFJvb3QgPSBwYXRoLmxlbmd0aCA9PT0gMDtcbiAgY29uc3QgYUtleXMgPSBPYmplY3Qua2V5cyhpdGVtQSkuZmlsdGVyKGF0Um9vdCA/IGlzTm90SWdub3JlZEtleSA6IHllcykubWFwKGtleSA9PiB2YWxpZGF0ZVByb3BlcnR5KGtleSwgaXRlbUFba2V5XSwgcGF0aCkpO1xuICBjb25zdCBhS2V5c0xlbmd0aCA9IGFLZXlzLmxlbmd0aDtcbiAgY29uc3QgYktleXMgPSBPYmplY3Qua2V5cyhpdGVtQikuZmlsdGVyKGF0Um9vdCA/IGlzTm90SWdub3JlZEtleSA6IHllcykubWFwKGtleSA9PiB2YWxpZGF0ZVByb3BlcnR5KGtleSwgaXRlbUJba2V5XSwgcGF0aCkpO1xuICBjb25zdCBiS2V5c0xlbmd0aCA9IGJLZXlzLmxlbmd0aDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhS2V5c0xlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qga2V5ID0gYUtleXNbaV07XG4gICAgaWYgKCEoa2V5IGluIGl0ZW1CKSkge1xuICAgICAgcGF0Y2hlcy5wdXNoKHtcbiAgICAgICAgb3A6IFwidW5zZXRcIixcbiAgICAgICAgcGF0aDogcGF0aC5jb25jYXQoa2V5KVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYktleXNMZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGtleSA9IGJLZXlzW2ldO1xuICAgIGRpZmZJdGVtKGl0ZW1BW2tleV0sIGl0ZW1CW2tleV0sIG9wdGlvbnMsIHBhdGguY29uY2F0KFtrZXldKSwgcGF0Y2hlcyk7XG4gIH1cbiAgcmV0dXJuIHBhdGNoZXM7XG59XG5mdW5jdGlvbiBkaWZmQXJyYXkoaXRlbUEsIGl0ZW1CLCBvcHRpb25zLCBwYXRoLCBwYXRjaGVzKSB7XG4gIGlmIChpdGVtQi5sZW5ndGggPiBpdGVtQS5sZW5ndGgpIHtcbiAgICBwYXRjaGVzLnB1c2goe1xuICAgICAgb3A6IFwiaW5zZXJ0XCIsXG4gICAgICBhZnRlcjogcGF0aC5jb25jYXQoWy0xXSksXG4gICAgICBpdGVtczogaXRlbUIuc2xpY2UoaXRlbUEubGVuZ3RoKS5tYXAoKGl0ZW0sIGkpID0+IG51bGxpZnlVbmRlZmluZWQoaXRlbSwgcGF0aCwgaSwgb3B0aW9ucykpXG4gICAgfSk7XG4gIH1cbiAgaWYgKGl0ZW1CLmxlbmd0aCA8IGl0ZW1BLmxlbmd0aCkge1xuICAgIGNvbnN0IGlzU2luZ2xlID0gaXRlbUEubGVuZ3RoIC0gaXRlbUIubGVuZ3RoID09PSAxO1xuICAgIGNvbnN0IHVuc2V0SXRlbXMgPSBpdGVtQS5zbGljZShpdGVtQi5sZW5ndGgpO1xuICAgIGlmIChpc1JldmlzaW9uTG9ja2VkKG9wdGlvbnMpIHx8ICFpc1VuaXF1ZWx5S2V5ZWQodW5zZXRJdGVtcykpIHtcbiAgICAgIHBhdGNoZXMucHVzaCh7XG4gICAgICAgIG9wOiBcInVuc2V0XCIsXG4gICAgICAgIHBhdGg6IHBhdGguY29uY2F0KFtpc1NpbmdsZSA/IGl0ZW1CLmxlbmd0aCA6IFtpdGVtQi5sZW5ndGgsIFwiXCJdXSlcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXRjaGVzLnB1c2goLi4udW5zZXRJdGVtcy5tYXAoaXRlbSA9PiAoe1xuICAgICAgICBvcDogXCJ1bnNldFwiLFxuICAgICAgICBwYXRoOiBwYXRoLmNvbmNhdCh7XG4gICAgICAgICAgX2tleTogaXRlbS5fa2V5XG4gICAgICAgIH0pXG4gICAgICB9KSkpO1xuICAgIH1cbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZW1CLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoaXRlbUJbaV0pKSB7XG4gICAgICB0aHJvdyBuZXcgRGlmZkVycm9yKFwiTXVsdGktZGltZW5zaW9uYWwgYXJyYXlzIG5vdCBzdXBwb3J0ZWRcIiwgcGF0aC5jb25jYXQoaSksIGl0ZW1CW2ldKTtcbiAgICB9XG4gIH1cbiAgY29uc3Qgb3ZlcmxhcHBpbmcgPSBNYXRoLm1pbihpdGVtQS5sZW5ndGgsIGl0ZW1CLmxlbmd0aCk7XG4gIGNvbnN0IHNlZ21lbnRBID0gaXRlbUEuc2xpY2UoMCwgb3ZlcmxhcHBpbmcpO1xuICBjb25zdCBzZWdtZW50QiA9IGl0ZW1CLnNsaWNlKDAsIG92ZXJsYXBwaW5nKTtcbiAgcmV0dXJuIGlzVW5pcXVlbHlLZXllZChzZWdtZW50QSkgJiYgaXNVbmlxdWVseUtleWVkKHNlZ21lbnRCKSA/IGRpZmZBcnJheUJ5S2V5KHNlZ21lbnRBLCBzZWdtZW50Qiwgb3B0aW9ucywgcGF0aCwgcGF0Y2hlcykgOiBkaWZmQXJyYXlCeUluZGV4KHNlZ21lbnRBLCBzZWdtZW50Qiwgb3B0aW9ucywgcGF0aCwgcGF0Y2hlcyk7XG59XG5mdW5jdGlvbiBkaWZmQXJyYXlCeUluZGV4KGl0ZW1BLCBpdGVtQiwgb3B0aW9ucywgcGF0aCwgcGF0Y2hlcykge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZW1BLmxlbmd0aDsgaSsrKSB7XG4gICAgZGlmZkl0ZW0oaXRlbUFbaV0sIG51bGxpZnlVbmRlZmluZWQoaXRlbUJbaV0sIHBhdGgsIGksIG9wdGlvbnMpLCBvcHRpb25zLCBwYXRoLmNvbmNhdChpKSwgcGF0Y2hlcyk7XG4gIH1cbiAgcmV0dXJuIHBhdGNoZXM7XG59XG5mdW5jdGlvbiBkaWZmQXJyYXlCeUtleShpdGVtQSwgaXRlbUIsIG9wdGlvbnMsIHBhdGgsIHBhdGNoZXMpIHtcbiAgY29uc3Qga2V5ZWRBID0gaW5kZXhCeUtleShpdGVtQSk7XG4gIGNvbnN0IGtleWVkQiA9IGluZGV4QnlLZXkoaXRlbUIpO1xuICBpZiAoIWFycmF5SXNFcXVhbChrZXllZEEua2V5cywga2V5ZWRCLmtleXMpKSB7XG4gICAgcmV0dXJuIGRpZmZBcnJheUJ5SW5kZXgoaXRlbUEsIGl0ZW1CLCBvcHRpb25zLCBwYXRoLCBwYXRjaGVzKTtcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGtleWVkQi5rZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qga2V5ID0ga2V5ZWRCLmtleXNbaV07XG4gICAgY29uc3QgdmFsdWVBID0ga2V5ZWRBLmluZGV4W2tleV07XG4gICAgY29uc3QgdmFsdWVCID0gbnVsbGlmeVVuZGVmaW5lZChrZXllZEIuaW5kZXhba2V5XSwgcGF0aCwgaSwgb3B0aW9ucyk7XG4gICAgZGlmZkl0ZW0odmFsdWVBLCB2YWx1ZUIsIG9wdGlvbnMsIHBhdGguY29uY2F0KHtcbiAgICAgIF9rZXk6IGtleVxuICAgIH0pLCBwYXRjaGVzKTtcbiAgfVxuICByZXR1cm4gcGF0Y2hlcztcbn1cbmZ1bmN0aW9uIGdldERpZmZNYXRjaFBhdGNoKGl0ZW1BLCBpdGVtQiwgb3B0aW9ucywgcGF0aCkge1xuICBjb25zdCB7XG4gICAgZW5hYmxlZCxcbiAgICBsZW5ndGhUaHJlc2hvbGRSZWxhdGl2ZSxcbiAgICBsZW5ndGhUaHJlc2hvbGRBYnNvbHV0ZVxuICB9ID0gb3B0aW9ucy5kaWZmTWF0Y2hQYXRjaDtcbiAgY29uc3Qgc2VnbWVudCA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXTtcbiAgaWYgKCFlbmFibGVkIHx8XG4gIC8vIERvbid0IHVzZSBmb3IgYW55dGhpbmcgYnV0IHN0cmluZ3NcbiAgdHlwZW9mIGl0ZW1BICE9PSBcInN0cmluZ1wiIHx8IHR5cGVvZiBpdGVtQiAhPT0gXCJzdHJpbmdcIiB8fFxuICAvLyBEb24ndCB1c2UgZm9yIGBfa2V5YCwgYF9yZWZgIGV0Y1xuICB0eXBlb2Ygc2VnbWVudCA9PT0gXCJzdHJpbmdcIiAmJiBzZWdtZW50WzBdID09PSBcIl9cIiB8fFxuICAvLyBEb24ndCB1c2Ugb24gc2hvcnQgc3RyaW5nc1xuICBpdGVtQi5sZW5ndGggPCBsZW5ndGhUaHJlc2hvbGRBYnNvbHV0ZSkge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgbGV0IHN0clBhdGNoID0gXCJcIjtcbiAgdHJ5IHtcbiAgICBjb25zdCBwYXRjaCA9IG1ha2VEaWZmKGl0ZW1BLCBpdGVtQik7XG4gICAgY29uc3QgZGlmZiA9IGNsZWFudXBFZmZpY2llbmN5KHBhdGNoKTtcbiAgICBzdHJQYXRjaCA9IHN0cmluZ2lmeVBhdGNoZXMobWFrZVBhdGNoZXMoZGlmZikpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIHJldHVybiBzdHJQYXRjaC5sZW5ndGggPiBpdGVtQi5sZW5ndGggKiBsZW5ndGhUaHJlc2hvbGRSZWxhdGl2ZSA/IHZvaWQgMCA6IHtcbiAgICBvcDogXCJkaWZmTWF0Y2hQYXRjaFwiLFxuICAgIHBhdGgsXG4gICAgdmFsdWU6IHN0clBhdGNoXG4gIH07XG59XG5mdW5jdGlvbiBkaWZmUHJpbWl0aXZlKGl0ZW1BLCBpdGVtQiwgb3B0aW9ucywgcGF0aCwgcGF0Y2hlcykge1xuICBjb25zdCBkbXAgPSBnZXREaWZmTWF0Y2hQYXRjaChpdGVtQSwgaXRlbUIsIG9wdGlvbnMsIHBhdGgpO1xuICBwYXRjaGVzLnB1c2goZG1wIHx8IHtcbiAgICBvcDogXCJzZXRcIixcbiAgICBwYXRoLFxuICAgIHZhbHVlOiBpdGVtQlxuICB9KTtcbiAgcmV0dXJuIHBhdGNoZXM7XG59XG5mdW5jdGlvbiBpc05vdElnbm9yZWRLZXkoa2V5KSB7XG4gIHJldHVybiBpZ25vcmVkS2V5cy5pbmRleE9mKGtleSkgPT09IC0xO1xufVxuZnVuY3Rpb24gc2VyaWFsaXplUGF0Y2hlcyhwYXRjaGVzLCBvcHRpb25zKSB7XG4gIGlmIChwYXRjaGVzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBjb25zdCB7XG4gICAgaWQsXG4gICAgaWZSZXZpc2lvbklEXG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBzZXQgPSBwYXRjaGVzLmZpbHRlcihwYXRjaCA9PiBwYXRjaC5vcCA9PT0gXCJzZXRcIik7XG4gIGNvbnN0IHVuc2V0ID0gcGF0Y2hlcy5maWx0ZXIocGF0Y2ggPT4gcGF0Y2gub3AgPT09IFwidW5zZXRcIik7XG4gIGNvbnN0IGluc2VydCA9IHBhdGNoZXMuZmlsdGVyKHBhdGNoID0+IHBhdGNoLm9wID09PSBcImluc2VydFwiKTtcbiAgY29uc3QgZG1wID0gcGF0Y2hlcy5maWx0ZXIocGF0Y2ggPT4gcGF0Y2gub3AgPT09IFwiZGlmZk1hdGNoUGF0Y2hcIik7XG4gIGNvbnN0IHdpdGhTZXQgPSBzZXQubGVuZ3RoID4gMCAmJiBzZXQucmVkdWNlKChwYXRjaCwgaXRlbSkgPT4ge1xuICAgIGNvbnN0IHBhdGggPSBwYXRoVG9TdHJpbmcoaXRlbS5wYXRoKTtcbiAgICBwYXRjaC5zZXRbcGF0aF0gPSBpdGVtLnZhbHVlO1xuICAgIHJldHVybiBwYXRjaDtcbiAgfSwge1xuICAgIGlkLFxuICAgIHNldDoge31cbiAgfSk7XG4gIGNvbnN0IHdpdGhVbnNldCA9IHVuc2V0Lmxlbmd0aCA+IDAgJiYgdW5zZXQucmVkdWNlKChwYXRjaCwgaXRlbSkgPT4ge1xuICAgIGNvbnN0IHBhdGggPSBwYXRoVG9TdHJpbmcoaXRlbS5wYXRoKTtcbiAgICBwYXRjaC51bnNldC5wdXNoKHBhdGgpO1xuICAgIHJldHVybiBwYXRjaDtcbiAgfSwge1xuICAgIGlkLFxuICAgIHVuc2V0OiBbXVxuICB9KTtcbiAgY29uc3Qgd2l0aEluc2VydCA9IGluc2VydC5yZWR1Y2UoKGFjYywgaXRlbSkgPT4ge1xuICAgIGNvbnN0IGFmdGVyID0gcGF0aFRvU3RyaW5nKGl0ZW0uYWZ0ZXIpO1xuICAgIHJldHVybiBhY2MuY29uY2F0KHtcbiAgICAgIGlkLFxuICAgICAgaW5zZXJ0OiB7XG4gICAgICAgIGFmdGVyLFxuICAgICAgICBpdGVtczogaXRlbS5pdGVtc1xuICAgICAgfVxuICAgIH0pO1xuICB9LCBbXSk7XG4gIGNvbnN0IHdpdGhEbXAgPSBkbXAubGVuZ3RoID4gMCAmJiBkbXAucmVkdWNlKChwYXRjaCwgaXRlbSkgPT4ge1xuICAgIGNvbnN0IHBhdGggPSBwYXRoVG9TdHJpbmcoaXRlbS5wYXRoKTtcbiAgICBwYXRjaC5kaWZmTWF0Y2hQYXRjaFtwYXRoXSA9IGl0ZW0udmFsdWU7XG4gICAgcmV0dXJuIHBhdGNoO1xuICB9LCB7XG4gICAgaWQsXG4gICAgZGlmZk1hdGNoUGF0Y2g6IHt9XG4gIH0pO1xuICBjb25zdCBwYXRjaFNldCA9IFt3aXRoU2V0LCB3aXRoVW5zZXQsIHdpdGhEbXAsIC4uLndpdGhJbnNlcnRdLmZpbHRlcihpdGVtID0+IGl0ZW0gIT09IGZhbHNlKTtcbiAgcmV0dXJuIHBhdGNoU2V0Lm1hcCgocGF0Y2gsIGkpID0+ICh7XG4gICAgcGF0Y2g6IGlmUmV2aXNpb25JRCAmJiBpID09PSAwID8ge1xuICAgICAgLi4ucGF0Y2gsXG4gICAgICBpZlJldmlzaW9uSURcbiAgICB9IDogcGF0Y2hcbiAgfSkpO1xufVxuZnVuY3Rpb24gaXNVbmlxdWVseUtleWVkKGFycikge1xuICBjb25zdCBrZXlzID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qga2V5ID0gZ2V0S2V5KGFycltpXSk7XG4gICAgaWYgKCFrZXkgfHwga2V5cy5pbmRleE9mKGtleSkgIT09IC0xKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGtleXMucHVzaChrZXkpO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gZ2V0S2V5KG9iaikge1xuICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gXCJvYmplY3RcIiAmJiBvYmogIT09IG51bGwgJiYgb2JqLl9rZXk7XG59XG5mdW5jdGlvbiBpbmRleEJ5S2V5KGFycikge1xuICByZXR1cm4gYXJyLnJlZHVjZSgoYWNjLCBpdGVtKSA9PiB7XG4gICAgYWNjLmtleXMucHVzaChpdGVtLl9rZXkpO1xuICAgIGFjYy5pbmRleFtpdGVtLl9rZXldID0gaXRlbTtcbiAgICByZXR1cm4gYWNjO1xuICB9LCB7XG4gICAga2V5czogW10sXG4gICAgaW5kZXg6IHt9XG4gIH0pO1xufVxuZnVuY3Rpb24gYXJyYXlJc0VxdWFsKGl0ZW1BLCBpdGVtQikge1xuICByZXR1cm4gaXRlbUEubGVuZ3RoID09PSBpdGVtQi5sZW5ndGggJiYgaXRlbUEuZXZlcnkoKGl0ZW0sIGkpID0+IGl0ZW1CW2ldID09PSBpdGVtKTtcbn1cbmZ1bmN0aW9uIG51bGxpZnlVbmRlZmluZWQoaXRlbSwgcGF0aCwgaW5kZXgsIG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiBpdGVtICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIGl0ZW07XG4gIH1cbiAgaWYgKCFvcHRpb25zLmhpZGVXYXJuaW5ncykge1xuICAgIGNvbnN0IHNlcmlhbGl6ZWRQYXRoID0gcGF0aFRvU3RyaW5nKHBhdGguY29uY2F0KGluZGV4KSk7XG4gICAgY29uc29sZS53YXJuKFwidW5kZWZpbmVkIHZhbHVlIGluIGFycmF5IGNvbnZlcnRlZCB0byBudWxsIChhdCAnXCIuY29uY2F0KHNlcmlhbGl6ZWRQYXRoLCBcIicpXCIpKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGlzUmV2aXNpb25Mb2NrZWQob3B0aW9ucykge1xuICByZXR1cm4gQm9vbGVhbihvcHRpb25zLmlmUmV2aXNpb25JRCk7XG59XG5mdW5jdGlvbiB5ZXMoXykge1xuICByZXR1cm4gdHJ1ZTtcbn1cbmV4cG9ydCB7IERpZmZFcnJvciwgZGlmZkl0ZW0sIGRpZmZQYXRjaCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOlsibWFrZURpZmYiLCJjbGVhbnVwRWZmaWNpZW5jeSIsInN0cmluZ2lmeVBhdGNoZXMiLCJtYWtlUGF0Y2hlcyIsInBhdGhUb1N0cmluZyIsInBhdGgiLCJyZWR1Y2UiLCJ0YXJnZXQiLCJzZWdtZW50IiwiaSIsIkFycmF5IiwiaXNBcnJheSIsImNvbmNhdCIsImpvaW4iLCJpc0tleWVkT2JqZWN0IiwiX2tleSIsInRlc3QiLCJzZXBhcmF0b3IiLCJFcnJvciIsIm9iaiIsIkRpZmZFcnJvciIsImNvbnN0cnVjdG9yIiwibWVzc2FnZSIsInZhbHVlIiwic2VyaWFsaXplZFBhdGgiLCJpZFBhdHRlcm4iLCJwcm9wUGF0dGVybiIsInByb3BTdGFydFBhdHRlcm4iLCJ2YWxpZGF0ZVByb3BlcnR5IiwicHJvcGVydHkiLCJpZ25vcmVkS2V5cyIsImRlZmF1bHRPcHRpb25zIiwiaGlkZVdhcm5pbmdzIiwiZGlmZk1hdGNoUGF0Y2giLCJlbmFibGVkIiwibGVuZ3RoVGhyZXNob2xkQWJzb2x1dGUiLCJsZW5ndGhUaHJlc2hvbGRSZWxhdGl2ZSIsIm1lcmdlT3B0aW9ucyIsIm9wdGlvbnMiLCJkaWZmUGF0Y2giLCJpdGVtQSIsIml0ZW1CIiwib3B0cyIsImlkIiwiX2lkIiwicmV2aXNpb25Mb2NrZWQiLCJpZlJldmlzaW9uSUQiLCJfcmV2IiwiYmFzZVBhdGgiLCJsZW5ndGgiLCJfdHlwZSIsIm9wZXJhdGlvbnMiLCJkaWZmSXRlbSIsInNlcmlhbGl6ZVBhdGNoZXMiLCJhcmd1bWVudHMiLCJ1bmRlZmluZWQiLCJwYXRjaGVzIiwiYVR5cGUiLCJiVHlwZSIsImFJc1VuZGVmaW5lZCIsImJJc1VuZGVmaW5lZCIsInB1c2giLCJvcCIsImRhdGFUeXBlIiwiaXNDb250YWluZXIiLCJkaWZmUHJpbWl0aXZlIiwiZGlmZkFycmF5IiwiZGlmZk9iamVjdCIsImF0Um9vdCIsImFLZXlzIiwiT2JqZWN0Iiwia2V5cyIsImZpbHRlciIsImlzTm90SWdub3JlZEtleSIsInllcyIsIm1hcCIsImtleSIsImFLZXlzTGVuZ3RoIiwiYktleXMiLCJiS2V5c0xlbmd0aCIsImFmdGVyIiwiaXRlbXMiLCJzbGljZSIsIml0ZW0iLCJudWxsaWZ5VW5kZWZpbmVkIiwiaXNTaW5nbGUiLCJ1bnNldEl0ZW1zIiwiaXNSZXZpc2lvbkxvY2tlZCIsImlzVW5pcXVlbHlLZXllZCIsIm92ZXJsYXBwaW5nIiwiTWF0aCIsIm1pbiIsInNlZ21lbnRBIiwic2VnbWVudEIiLCJkaWZmQXJyYXlCeUtleSIsImRpZmZBcnJheUJ5SW5kZXgiLCJrZXllZEEiLCJpbmRleEJ5S2V5Iiwia2V5ZWRCIiwiYXJyYXlJc0VxdWFsIiwidmFsdWVBIiwiaW5kZXgiLCJ2YWx1ZUIiLCJnZXREaWZmTWF0Y2hQYXRjaCIsInN0clBhdGNoIiwicGF0Y2giLCJkaWZmIiwiZXJyIiwiZG1wIiwiaW5kZXhPZiIsInNldCIsInVuc2V0IiwiaW5zZXJ0Iiwid2l0aFNldCIsIndpdGhVbnNldCIsIndpdGhJbnNlcnQiLCJhY2MiLCJ3aXRoRG1wIiwicGF0Y2hTZXQiLCJhcnIiLCJnZXRLZXkiLCJldmVyeSIsImNvbnNvbGUiLCJ3YXJuIiwiQm9vbGVhbiIsIl8iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/sanity-diff-patch/dist/index.js\n");

/***/ })

};
;
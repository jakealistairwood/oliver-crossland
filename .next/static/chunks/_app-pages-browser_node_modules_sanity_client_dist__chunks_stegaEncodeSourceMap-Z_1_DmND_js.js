"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_node_modules_sanity_client_dist__chunks_stegaEncodeSourceMap-Z_1_DmND_js"],{

/***/ "(app-pages-browser)/./node_modules/@sanity/client/dist/_chunks/stegaEncodeSourceMap-Z_1_DmND.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@sanity/client/dist/_chunks/stegaEncodeSourceMap-Z_1_DmND.js ***!
  \***********************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   a: function() { return /* binding */ stegaEncodeSourceMap$1; },\n/* harmony export */   e: function() { return /* binding */ encodeIntoResult; },\n/* harmony export */   s: function() { return /* binding */ stegaEncodeSourceMap; }\n/* harmony export */ });\n/* harmony import */ var _browserMiddleware_B_0VHs_S_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./browserMiddleware-B_0VHs-S.js */ \"(app-pages-browser)/./node_modules/@sanity/client/dist/_chunks/browserMiddleware-B_0VHs-S.js\");\n\nconst reKeySegment = /_key\\s*==\\s*['\"](.*)['\"]/;\nfunction isKeySegment(segment) {\n    return typeof segment == \"string\" ? reKeySegment.test(segment.trim()) : typeof segment == \"object\" && \"_key\" in segment;\n}\nfunction toString(path) {\n    if (!Array.isArray(path)) throw new Error(\"Path is not an array\");\n    return path.reduce((target, segment, i)=>{\n        const segmentType = typeof segment;\n        if (segmentType === \"number\") return \"\".concat(target, \"[\").concat(segment, \"]\");\n        if (segmentType === \"string\") return \"\".concat(target).concat(i === 0 ? \"\" : \".\").concat(segment);\n        if (isKeySegment(segment) && segment._key) return \"\".concat(target, '[_key==\"').concat(segment._key, '\"]');\n        if (Array.isArray(segment)) {\n            const [from, to] = segment;\n            return \"\".concat(target, \"[\").concat(from, \":\").concat(to, \"]\");\n        }\n        throw new Error(\"Unsupported path segment `\".concat(JSON.stringify(segment), \"`\"));\n    }, \"\");\n}\nconst ESCAPE = {\n    \"\\f\": \"\\\\f\",\n    \"\\n\": \"\\\\n\",\n    \"\\r\": \"\\\\r\",\n    \"\t\": \"\\\\t\",\n    \"'\": \"\\\\'\",\n    \"\\\\\": \"\\\\\\\\\"\n}, UNESCAPE = {\n    \"\\\\f\": \"\\f\",\n    \"\\\\n\": \"\\n\",\n    \"\\\\r\": \"\\r\",\n    \"\\\\t\": \"\t\",\n    \"\\\\'\": \"'\",\n    \"\\\\\\\\\": \"\\\\\"\n};\nfunction jsonPath(path) {\n    return \"$\".concat(path.map((segment)=>typeof segment == \"string\" ? \"['\".concat(segment.replace(/[\\f\\n\\r\\t'\\\\]/g, (match)=>ESCAPE[match]), \"']\") : typeof segment == \"number\" ? \"[\".concat(segment, \"]\") : segment._key !== \"\" ? \"[?(@._key=='\".concat(segment._key.replace(/['\\\\]/g, (match)=>ESCAPE[match]), \"')]\") : \"[\".concat(segment._index, \"]\")).join(\"\"));\n}\nfunction parseJsonPath(path) {\n    const parsed = [], parseRe = /\\['(.*?)'\\]|\\[(\\d+)\\]|\\[\\?\\(@\\._key=='(.*?)'\\)\\]/g;\n    let match;\n    for(; (match = parseRe.exec(path)) !== null;){\n        if (match[1] !== void 0) {\n            const key = match[1].replace(/\\\\(\\\\|f|n|r|t|')/g, (m)=>UNESCAPE[m]);\n            parsed.push(key);\n            continue;\n        }\n        if (match[2] !== void 0) {\n            parsed.push(parseInt(match[2], 10));\n            continue;\n        }\n        if (match[3] !== void 0) {\n            const _key = match[3].replace(/\\\\(\\\\')/g, (m)=>UNESCAPE[m]);\n            parsed.push({\n                _key,\n                _index: -1\n            });\n            continue;\n        }\n    }\n    return parsed;\n}\nfunction jsonPathToStudioPath(path) {\n    return path.map((segment)=>{\n        if (typeof segment == \"string\" || typeof segment == \"number\") return segment;\n        if (segment._key !== \"\") return {\n            _key: segment._key\n        };\n        if (segment._index !== -1) return segment._index;\n        throw new Error(\"invalid segment:\".concat(JSON.stringify(segment)));\n    });\n}\nfunction jsonPathToMappingPath(path) {\n    return path.map((segment)=>{\n        if (typeof segment == \"string\" || typeof segment == \"number\") return segment;\n        if (segment._index !== -1) return segment._index;\n        throw new Error(\"invalid segment:\".concat(JSON.stringify(segment)));\n    });\n}\nfunction resolveMapping(resultPath, csm) {\n    if (!(csm != null && csm.mappings)) return;\n    const resultMappingPath = jsonPath(jsonPathToMappingPath(resultPath));\n    if (csm.mappings[resultMappingPath] !== void 0) return {\n        mapping: csm.mappings[resultMappingPath],\n        matchedPath: resultMappingPath,\n        pathSuffix: \"\"\n    };\n    const mappings = Object.entries(csm.mappings).filter((param)=>{\n        let [key] = param;\n        return resultMappingPath.startsWith(key);\n    }).sort((param, param1)=>{\n        let [key1] = param, [key2] = param1;\n        return key2.length - key1.length;\n    });\n    if (mappings.length == 0) return;\n    const [matchedPath, mapping] = mappings[0], pathSuffix = resultMappingPath.substring(matchedPath.length);\n    return {\n        mapping,\n        matchedPath,\n        pathSuffix\n    };\n}\nfunction isArray(value) {\n    return value !== null && Array.isArray(value);\n}\nfunction isRecord(value) {\n    return typeof value == \"object\" && value !== null;\n}\nfunction walkMap(value, mappingFn) {\n    let path = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];\n    return isArray(value) ? value.map((v, idx)=>{\n        if (isRecord(v)) {\n            const _key = v._key;\n            if (typeof _key == \"string\") return walkMap(v, mappingFn, path.concat({\n                _key,\n                _index: idx\n            }));\n        }\n        return walkMap(v, mappingFn, path.concat(idx));\n    }) : isRecord(value) ? Object.fromEntries(Object.entries(value).map((param)=>{\n        let [k, v] = param;\n        return [\n            k,\n            walkMap(v, mappingFn, path.concat(k))\n        ];\n    })) : mappingFn(value, path);\n}\nfunction encodeIntoResult(result, csm, encoder) {\n    return walkMap(result, (value, path)=>{\n        if (typeof value != \"string\") return value;\n        const resolveMappingResult = resolveMapping(path, csm);\n        if (!resolveMappingResult) return value;\n        const { mapping, matchedPath } = resolveMappingResult;\n        if (mapping.type !== \"value\" || mapping.source.type !== \"documentValue\") return value;\n        const sourceDocument = csm.documents[mapping.source.document], sourcePath = csm.paths[mapping.source.path], matchPathSegments = parseJsonPath(matchedPath), fullSourceSegments = parseJsonPath(sourcePath).concat(path.slice(matchPathSegments.length));\n        return encoder({\n            sourcePath: fullSourceSegments,\n            sourceDocument,\n            resultPath: path,\n            value\n        });\n    });\n}\nconst DRAFTS_PREFIX = \"drafts.\";\nfunction getPublishedId(id) {\n    return id.startsWith(DRAFTS_PREFIX) ? id.slice(DRAFTS_PREFIX.length) : id;\n}\nfunction createEditUrl(options) {\n    const { baseUrl, workspace: _workspace = \"default\", tool: _tool = \"default\", id: _id, type, path, projectId, dataset } = options;\n    if (!baseUrl) throw new Error(\"baseUrl is required\");\n    if (!path) throw new Error(\"path is required\");\n    if (!_id) throw new Error(\"id is required\");\n    if (baseUrl !== \"/\" && baseUrl.endsWith(\"/\")) throw new Error(\"baseUrl must not end with a slash\");\n    const workspace = _workspace === \"default\" ? void 0 : _workspace, tool = _tool === \"default\" ? void 0 : _tool, id = getPublishedId(_id), stringifiedPath = Array.isArray(path) ? toString(jsonPathToStudioPath(path)) : path, searchParams = new URLSearchParams({\n        baseUrl,\n        id,\n        type,\n        path: stringifiedPath\n    });\n    workspace && searchParams.set(\"workspace\", workspace), tool && searchParams.set(\"tool\", tool), projectId && searchParams.set(\"projectId\", projectId), dataset && searchParams.set(\"dataset\", dataset);\n    const segments = [\n        baseUrl === \"/\" ? \"\" : baseUrl\n    ];\n    workspace && segments.push(workspace);\n    const routerParams = [\n        \"mode=presentation\",\n        \"id=\".concat(id),\n        \"type=\".concat(type),\n        \"path=\".concat(encodeURIComponent(stringifiedPath))\n    ];\n    return tool && routerParams.push(\"tool=\".concat(tool)), segments.push(\"intent\", \"edit\", \"\".concat(routerParams.join(\";\"), \"?\").concat(searchParams)), segments.join(\"/\");\n}\nfunction resolveStudioBaseRoute(studioUrl) {\n    let baseUrl = typeof studioUrl == \"string\" ? studioUrl : studioUrl.baseUrl;\n    return baseUrl !== \"/\" && (baseUrl = baseUrl.replace(/\\/$/, \"\")), typeof studioUrl == \"string\" ? {\n        baseUrl\n    } : {\n        ...studioUrl,\n        baseUrl\n    };\n}\nconst filterDefault = (param)=>{\n    let { sourcePath, value } = param;\n    if (isValidDate(value) || isValidURL(value)) return !1;\n    const endPath = sourcePath.at(-1);\n    return !(sourcePath.at(-2) === \"slug\" && endPath === \"current\" || typeof endPath == \"string\" && endPath.startsWith(\"_\") || typeof endPath == \"number\" && sourcePath.at(-2) === \"marks\" || endPath === \"href\" && typeof sourcePath.at(-2) == \"number\" && sourcePath.at(-3) === \"markDefs\" || endPath === \"style\" || endPath === \"listItem\" || sourcePath.some((path)=>path === \"meta\" || path === \"metadata\" || path === \"openGraph\" || path === \"seo\") || typeof endPath == \"string\" && denylist.has(endPath));\n}, denylist = /* @__PURE__ */ new Set([\n    \"color\",\n    \"colour\",\n    \"currency\",\n    \"email\",\n    \"format\",\n    \"gid\",\n    \"hex\",\n    \"href\",\n    \"hsl\",\n    \"hsla\",\n    \"icon\",\n    \"id\",\n    \"index\",\n    \"key\",\n    \"language\",\n    \"layout\",\n    \"link\",\n    \"linkAction\",\n    \"locale\",\n    \"lqip\",\n    \"page\",\n    \"path\",\n    \"ref\",\n    \"rgb\",\n    \"rgba\",\n    \"route\",\n    \"secret\",\n    \"slug\",\n    \"status\",\n    \"tag\",\n    \"template\",\n    \"theme\",\n    \"type\",\n    \"unit\",\n    \"url\",\n    \"username\",\n    \"variant\",\n    \"website\"\n]);\nfunction isValidDate(dateString) {\n    return /^\\d{4}-\\d{2}-\\d{2}/.test(dateString) ? !!Date.parse(dateString) : !1;\n}\nfunction isValidURL(url) {\n    try {\n        new URL(url, url.startsWith(\"/\") ? \"https://acme.com\" : void 0);\n    } catch (e) {\n        return !1;\n    }\n    return !0;\n}\nconst TRUNCATE_LENGTH = 20;\nfunction stegaEncodeSourceMap(result, resultSourceMap, config) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _i;\n    const { filter, logger, enabled } = config;\n    if (!enabled) {\n        const msg = \"config.enabled must be true, don't call this function otherwise\";\n        throw (_a = logger == null ? void 0 : logger.error) == null || _a.call(logger, \"[@sanity/client]: \".concat(msg), {\n            result,\n            resultSourceMap,\n            config\n        }), new TypeError(msg);\n    }\n    if (!resultSourceMap) return (_b = logger == null ? void 0 : logger.error) == null || _b.call(logger, \"[@sanity/client]: Missing Content Source Map from response body\", {\n        result,\n        resultSourceMap,\n        config\n    }), result;\n    if (!config.studioUrl) {\n        const msg = \"config.studioUrl must be defined\";\n        throw (_c = logger == null ? void 0 : logger.error) == null || _c.call(logger, \"[@sanity/client]: \".concat(msg), {\n            result,\n            resultSourceMap,\n            config\n        }), new TypeError(msg);\n    }\n    const report = {\n        encoded: [],\n        skipped: []\n    }, resultWithStega = encodeIntoResult(result, resultSourceMap, (param)=>{\n        let { sourcePath, sourceDocument, resultPath, value } = param;\n        if ((typeof filter == \"function\" ? filter({\n            sourcePath,\n            resultPath,\n            filterDefault,\n            sourceDocument,\n            value\n        }) : filterDefault({\n            sourcePath,\n            resultPath,\n            filterDefault,\n            sourceDocument,\n            value\n        })) === !1) return logger && report.skipped.push({\n            path: prettyPathForLogging(sourcePath),\n            value: \"\".concat(value.slice(0, TRUNCATE_LENGTH)).concat(value.length > TRUNCATE_LENGTH ? \"...\" : \"\"),\n            length: value.length\n        }), value;\n        logger && report.encoded.push({\n            path: prettyPathForLogging(sourcePath),\n            value: \"\".concat(value.slice(0, TRUNCATE_LENGTH)).concat(value.length > TRUNCATE_LENGTH ? \"...\" : \"\"),\n            length: value.length\n        });\n        const { baseUrl, workspace, tool } = resolveStudioBaseRoute(typeof config.studioUrl == \"function\" ? config.studioUrl(sourceDocument) : config.studioUrl);\n        if (!baseUrl) return value;\n        const { _id: id, _type: type, _projectId: projectId, _dataset: dataset } = sourceDocument;\n        return (0,_browserMiddleware_B_0VHs_S_js__WEBPACK_IMPORTED_MODULE_0__.g)(value, {\n            origin: \"sanity.io\",\n            href: createEditUrl({\n                baseUrl,\n                workspace,\n                tool,\n                id,\n                type,\n                path: sourcePath,\n                ...!config.omitCrossDatasetReferenceData && {\n                    dataset,\n                    projectId\n                }\n            })\n        }, // We use custom logic to determine if we should skip encoding\n        !1);\n    });\n    if (logger) {\n        const isSkipping = report.skipped.length, isEncoding = report.encoded.length;\n        if ((isSkipping || isEncoding) && ((_d = (logger == null ? void 0 : logger.groupCollapsed) || logger.log) == null || _d(\"[@sanity/client]: Encoding source map into result\"), (_e = logger.log) == null || _e.call(logger, \"[@sanity/client]: Paths encoded: \".concat(report.encoded.length, \", skipped: \").concat(report.skipped.length))), report.encoded.length > 0 && ((_f = logger == null ? void 0 : logger.log) == null || _f.call(logger, \"[@sanity/client]: Table of encoded paths\"), (_g = (logger == null ? void 0 : logger.table) || logger.log) == null || _g(report.encoded)), report.skipped.length > 0) {\n            const skipped = /* @__PURE__ */ new Set();\n            for (const { path } of report.skipped)skipped.add(path.replace(reKeySegment, \"0\").replace(/\\[\\d+\\]/g, \"[]\"));\n            (_h = logger == null ? void 0 : logger.log) == null || _h.call(logger, \"[@sanity/client]: List of skipped paths\", [\n                ...skipped.values()\n            ]);\n        }\n        (isSkipping || isEncoding) && ((_i = logger == null ? void 0 : logger.groupEnd) == null || _i.call(logger));\n    }\n    return resultWithStega;\n}\nfunction prettyPathForLogging(path) {\n    return toString(jsonPathToStudioPath(path));\n}\nvar stegaEncodeSourceMap$1 = /* @__PURE__ */ Object.freeze({\n    __proto__: null,\n    stegaEncodeSourceMap\n});\n //# sourceMappingURL=stegaEncodeSourceMap-Z_1_DmND.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac2FuaXR5L2NsaWVudC9kaXN0L19jaHVua3Mvc3RlZ2FFbmNvZGVTb3VyY2VNYXAtWl8xX0RtTkQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUF5RDtBQUN6RCxNQUFNRSxlQUFlO0FBQ3JCLFNBQVNDLGFBQWFDLE9BQU87SUFDM0IsT0FBTyxPQUFPQSxXQUFXLFdBQVdGLGFBQWFHLElBQUksQ0FBQ0QsUUFBUUUsSUFBSSxNQUFNLE9BQU9GLFdBQVcsWUFBWSxVQUFVQTtBQUNsSDtBQUNBLFNBQVNHLFNBQVNDLElBQUk7SUFDcEIsSUFBSSxDQUFDQyxNQUFNQyxPQUFPLENBQUNGLE9BQ2pCLE1BQU0sSUFBSUcsTUFBTTtJQUNsQixPQUFPSCxLQUFLSSxNQUFNLENBQUMsQ0FBQ0MsUUFBUVQsU0FBU1U7UUFDbkMsTUFBTUMsY0FBYyxPQUFPWDtRQUMzQixJQUFJVyxnQkFBZ0IsVUFDbEIsT0FBTyxHQUFhWCxPQUFWUyxRQUFPLEtBQVcsT0FBUlQsU0FBUTtRQUM5QixJQUFJVyxnQkFBZ0IsVUFDbEIsT0FBTyxHQUFZRCxPQUFURCxRQUE4QlQsT0FBckJVLE1BQU0sSUFBSSxLQUFLLEtBQWMsT0FBUlY7UUFDMUMsSUFBSUQsYUFBYUMsWUFBWUEsUUFBUVksSUFBSSxFQUN2QyxPQUFPLEdBQW9CWixPQUFqQlMsUUFBTyxZQUF1QixPQUFiVCxRQUFRWSxJQUFJLEVBQUM7UUFDMUMsSUFBSVAsTUFBTUMsT0FBTyxDQUFDTixVQUFVO1lBQzFCLE1BQU0sQ0FBQ2EsTUFBTUMsR0FBRyxHQUFHZDtZQUNuQixPQUFPLEdBQWFhLE9BQVZKLFFBQU8sS0FBV0ssT0FBUkQsTUFBSyxLQUFNLE9BQUhDLElBQUc7UUFDakM7UUFDQSxNQUFNLElBQUlQLE1BQU0sNkJBQXNELE9BQXhCUSxLQUFLQyxTQUFTLENBQUNoQixVQUFTO0lBQ3hFLEdBQUc7QUFDTDtBQUNBLE1BQU1pQixTQUFTO0lBQ2IsTUFBTTtJQUNOLE1B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LEtBQU0sRUFBQ3VFLEtBQUtJLFVBQVUsT0FBTyxLQUFLLElBQUlBLE9BQU9vQixHQUFHLEtBQUssUUFBUXhCLEdBQUdRLElBQUksQ0FBQ0osUUFBUSw2Q0FBNkMsQ0FBQ0gsS0FBSyxDQUFDRyxVQUFVLE9BQU8sS0FBSyxJQUFJQSxPQUFPcUIsS0FBSyxLQUFLckIsT0FBT29CLEdBQUcsS0FBSyxRQUFRdkIsR0FBR1MsT0FBT0MsT0FBTyxJQUFJRCxPQUFPRSxPQUFPLENBQUNuRixNQUFNLEdBQUcsR0FBRztZQUM3USxNQUFNbUYsVUFBVSxhQUFhLEdBQUcsSUFBSTNCO1lBQ3BDLEtBQUssTUFBTSxFQUFFdEcsSUFBSSxFQUFFLElBQUkrSCxPQUFPRSxPQUFPLENBQ25DQSxRQUFRYyxHQUFHLENBQUMvSSxLQUFLaUIsT0FBTyxDQUFDdkIsY0FBYyxLQUFLdUIsT0FBTyxDQUFDLFlBQVk7WUFDakVzRyxDQUFBQSxLQUFLRSxVQUFVLE9BQU8sS0FBSyxJQUFJQSxPQUFPb0IsR0FBRyxLQUFLLFFBQVF0QixHQUFHTSxJQUFJLENBQUNKLFFBQVEsMkNBQTJDO21CQUFJUSxRQUFRZSxNQUFNO2FBQUc7UUFDekk7UUFDQ04sQ0FBQUEsY0FBY0MsVUFBUyxLQUFPLEVBQUNuQixLQUFLQyxVQUFVLE9BQU8sS0FBSyxJQUFJQSxPQUFPd0IsUUFBUSxLQUFLLFFBQVF6QixHQUFHSyxJQUFJLENBQUNKLE9BQU07SUFDM0c7SUFDQSxPQUFPUztBQUNUO0FBQ0EsU0FBU0MscUJBQXFCbkksSUFBSTtJQUNoQyxPQUFPRCxTQUFTOEIscUJBQXFCN0I7QUFDdkM7QUFDQSxJQUFJa0oseUJBQXlCLGFBQWEsR0FBRzNHLE9BQU80RyxNQUFNLENBQUM7SUFDekRDLFdBQVc7SUFDWHZDO0FBQ0Y7QUFLRSxDQUNGLHlEQUF5RCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHNhbml0eS9jbGllbnQvZGlzdC9fY2h1bmtzL3N0ZWdhRW5jb2RlU291cmNlTWFwLVpfMV9EbU5ELmpzP2Y0MjYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZyBhcyBiIH0gZnJvbSBcIi4vYnJvd3Nlck1pZGRsZXdhcmUtQl8wVkhzLVMuanNcIjtcbmNvbnN0IHJlS2V5U2VnbWVudCA9IC9fa2V5XFxzKj09XFxzKlsnXCJdKC4qKVsnXCJdLztcbmZ1bmN0aW9uIGlzS2V5U2VnbWVudChzZWdtZW50KSB7XG4gIHJldHVybiB0eXBlb2Ygc2VnbWVudCA9PSBcInN0cmluZ1wiID8gcmVLZXlTZWdtZW50LnRlc3Qoc2VnbWVudC50cmltKCkpIDogdHlwZW9mIHNlZ21lbnQgPT0gXCJvYmplY3RcIiAmJiBcIl9rZXlcIiBpbiBzZWdtZW50O1xufVxuZnVuY3Rpb24gdG9TdHJpbmcocGF0aCkge1xuICBpZiAoIUFycmF5LmlzQXJyYXkocGF0aCkpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiUGF0aCBpcyBub3QgYW4gYXJyYXlcIik7XG4gIHJldHVybiBwYXRoLnJlZHVjZSgodGFyZ2V0LCBzZWdtZW50LCBpKSA9PiB7XG4gICAgY29uc3Qgc2VnbWVudFR5cGUgPSB0eXBlb2Ygc2VnbWVudDtcbiAgICBpZiAoc2VnbWVudFR5cGUgPT09IFwibnVtYmVyXCIpXG4gICAgICByZXR1cm4gYCR7dGFyZ2V0fVske3NlZ21lbnR9XWA7XG4gICAgaWYgKHNlZ21lbnRUeXBlID09PSBcInN0cmluZ1wiKVxuICAgICAgcmV0dXJuIGAke3RhcmdldH0ke2kgPT09IDAgPyBcIlwiIDogXCIuXCJ9JHtzZWdtZW50fWA7XG4gICAgaWYgKGlzS2V5U2VnbWVudChzZWdtZW50KSAmJiBzZWdtZW50Ll9rZXkpXG4gICAgICByZXR1cm4gYCR7dGFyZ2V0fVtfa2V5PT1cIiR7c2VnbWVudC5fa2V5fVwiXWA7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc2VnbWVudCkpIHtcbiAgICAgIGNvbnN0IFtmcm9tLCB0b10gPSBzZWdtZW50O1xuICAgICAgcmV0dXJuIGAke3RhcmdldH1bJHtmcm9tfToke3RvfV1gO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIHBhdGggc2VnbWVudCBcXGAke0pTT04uc3RyaW5naWZ5KHNlZ21lbnQpfVxcYGApO1xuICB9LCBcIlwiKTtcbn1cbmNvbnN0IEVTQ0FQRSA9IHtcbiAgXCJcXGZcIjogXCJcXFxcZlwiLFxuICBcIlxcblwiOiBcIlxcXFxuXCIsXG4gIFwiXFxyXCI6IFwiXFxcXHJcIixcbiAgXCJcdFwiOiBcIlxcXFx0XCIsXG4gIFwiJ1wiOiBcIlxcXFwnXCIsXG4gIFwiXFxcXFwiOiBcIlxcXFxcXFxcXCJcbn0sIFVORVNDQVBFID0ge1xuICBcIlxcXFxmXCI6IFwiXFxmXCIsXG4gIFwiXFxcXG5cIjogYFxuYCxcbiAgXCJcXFxcclwiOiBcIlxcclwiLFxuICBcIlxcXFx0XCI6IFwiXHRcIixcbiAgXCJcXFxcJ1wiOiBcIidcIixcbiAgXCJcXFxcXFxcXFwiOiBcIlxcXFxcIlxufTtcbmZ1bmN0aW9uIGpzb25QYXRoKHBhdGgpIHtcbiAgcmV0dXJuIGAkJHtwYXRoLm1hcCgoc2VnbWVudCkgPT4gdHlwZW9mIHNlZ21lbnQgPT0gXCJzdHJpbmdcIiA/IGBbJyR7c2VnbWVudC5yZXBsYWNlKC9bXFxmXFxuXFxyXFx0J1xcXFxdL2csIChtYXRjaCkgPT4gRVNDQVBFW21hdGNoXSl9J11gIDogdHlwZW9mIHNlZ21lbnQgPT0gXCJudW1iZXJcIiA/IGBbJHtzZWdtZW50fV1gIDogc2VnbWVudC5fa2V5ICE9PSBcIlwiID8gYFs/KEAuX2tleT09JyR7c2VnbWVudC5fa2V5LnJlcGxhY2UoL1snXFxcXF0vZywgKG1hdGNoKSA9PiBFU0NBUEVbbWF0Y2hdKX0nKV1gIDogYFske3NlZ21lbnQuX2luZGV4fV1gKS5qb2luKFwiXCIpfWA7XG59XG5mdW5jdGlvbiBwYXJzZUpzb25QYXRoKHBhdGgpIHtcbiAgY29uc3QgcGFyc2VkID0gW10sIHBhcnNlUmUgPSAvXFxbJyguKj8pJ1xcXXxcXFsoXFxkKylcXF18XFxbXFw/XFwoQFxcLl9rZXk9PScoLio/KSdcXClcXF0vZztcbiAgbGV0IG1hdGNoO1xuICBmb3IgKDsgKG1hdGNoID0gcGFyc2VSZS5leGVjKHBhdGgpKSAhPT0gbnVsbDsgKSB7XG4gICAgaWYgKG1hdGNoWzFdICE9PSB2b2lkIDApIHtcbiAgICAgIGNvbnN0IGtleSA9IG1hdGNoWzFdLnJlcGxhY2UoL1xcXFwoXFxcXHxmfG58cnx0fCcpL2csIChtKSA9PiBVTkVTQ0FQRVttXSk7XG4gICAgICBwYXJzZWQucHVzaChrZXkpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChtYXRjaFsyXSAhPT0gdm9pZCAwKSB7XG4gICAgICBwYXJzZWQucHVzaChwYXJzZUludChtYXRjaFsyXSwgMTApKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAobWF0Y2hbM10gIT09IHZvaWQgMCkge1xuICAgICAgY29uc3QgX2tleSA9IG1hdGNoWzNdLnJlcGxhY2UoL1xcXFwoXFxcXCcpL2csIChtKSA9PiBVTkVTQ0FQRVttXSk7XG4gICAgICBwYXJzZWQucHVzaCh7XG4gICAgICAgIF9rZXksXG4gICAgICAgIF9pbmRleDogLTFcbiAgICAgIH0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBwYXJzZWQ7XG59XG5mdW5jdGlvbiBqc29uUGF0aFRvU3R1ZGlvUGF0aChwYXRoKSB7XG4gIHJldHVybiBwYXRoLm1hcCgoc2VnbWVudCkgPT4ge1xuICAgIGlmICh0eXBlb2Ygc2VnbWVudCA9PSBcInN0cmluZ1wiIHx8IHR5cGVvZiBzZWdtZW50ID09IFwibnVtYmVyXCIpXG4gICAgICByZXR1cm4gc2VnbWVudDtcbiAgICBpZiAoc2VnbWVudC5fa2V5ICE9PSBcIlwiKVxuICAgICAgcmV0dXJuIHsgX2tleTogc2VnbWVudC5fa2V5IH07XG4gICAgaWYgKHNlZ21lbnQuX2luZGV4ICE9PSAtMSlcbiAgICAgIHJldHVybiBzZWdtZW50Ll9pbmRleDtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgc2VnbWVudDoke0pTT04uc3RyaW5naWZ5KHNlZ21lbnQpfWApO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGpzb25QYXRoVG9NYXBwaW5nUGF0aChwYXRoKSB7XG4gIHJldHVybiBwYXRoLm1hcCgoc2VnbWVudCkgPT4ge1xuICAgIGlmICh0eXBlb2Ygc2VnbWVudCA9PSBcInN0cmluZ1wiIHx8IHR5cGVvZiBzZWdtZW50ID09IFwibnVtYmVyXCIpXG4gICAgICByZXR1cm4gc2VnbWVudDtcbiAgICBpZiAoc2VnbWVudC5faW5kZXggIT09IC0xKVxuICAgICAgcmV0dXJuIHNlZ21lbnQuX2luZGV4O1xuICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBzZWdtZW50OiR7SlNPTi5zdHJpbmdpZnkoc2VnbWVudCl9YCk7XG4gIH0pO1xufVxuZnVuY3Rpb24gcmVzb2x2ZU1hcHBpbmcocmVzdWx0UGF0aCwgY3NtKSB7XG4gIGlmICghKGNzbSAhPSBudWxsICYmIGNzbS5tYXBwaW5ncykpXG4gICAgcmV0dXJuO1xuICBjb25zdCByZXN1bHRNYXBwaW5nUGF0aCA9IGpzb25QYXRoKGpzb25QYXRoVG9NYXBwaW5nUGF0aChyZXN1bHRQYXRoKSk7XG4gIGlmIChjc20ubWFwcGluZ3NbcmVzdWx0TWFwcGluZ1BhdGhdICE9PSB2b2lkIDApXG4gICAgcmV0dXJuIHtcbiAgICAgIG1hcHBpbmc6IGNzbS5tYXBwaW5nc1tyZXN1bHRNYXBwaW5nUGF0aF0sXG4gICAgICBtYXRjaGVkUGF0aDogcmVzdWx0TWFwcGluZ1BhdGgsXG4gICAgICBwYXRoU3VmZml4OiBcIlwiXG4gICAgfTtcbiAgY29uc3QgbWFwcGluZ3MgPSBPYmplY3QuZW50cmllcyhjc20ubWFwcGluZ3MpLmZpbHRlcigoW2tleV0pID0+IHJlc3VsdE1hcHBpbmdQYXRoLnN0YXJ0c1dpdGgoa2V5KSkuc29ydCgoW2tleTFdLCBba2V5Ml0pID0+IGtleTIubGVuZ3RoIC0ga2V5MS5sZW5ndGgpO1xuICBpZiAobWFwcGluZ3MubGVuZ3RoID09IDApXG4gICAgcmV0dXJuO1xuICBjb25zdCBbbWF0Y2hlZFBhdGgsIG1hcHBpbmddID0gbWFwcGluZ3NbMF0sIHBhdGhTdWZmaXggPSByZXN1bHRNYXBwaW5nUGF0aC5zdWJzdHJpbmcobWF0Y2hlZFBhdGgubGVuZ3RoKTtcbiAgcmV0dXJuIHsgbWFwcGluZywgbWF0Y2hlZFBhdGgsIHBhdGhTdWZmaXggfTtcbn1cbmZ1bmN0aW9uIGlzQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9PSBudWxsICYmIEFycmF5LmlzQXJyYXkodmFsdWUpO1xufVxuZnVuY3Rpb24gaXNSZWNvcmQodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSBcIm9iamVjdFwiICYmIHZhbHVlICE9PSBudWxsO1xufVxuZnVuY3Rpb24gd2Fsa01hcCh2YWx1ZSwgbWFwcGluZ0ZuLCBwYXRoID0gW10pIHtcbiAgcmV0dXJuIGlzQXJyYXkodmFsdWUpID8gdmFsdWUubWFwKCh2LCBpZHgpID0+IHtcbiAgICBpZiAoaXNSZWNvcmQodikpIHtcbiAgICAgIGNvbnN0IF9rZXkgPSB2Ll9rZXk7XG4gICAgICBpZiAodHlwZW9mIF9rZXkgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgcmV0dXJuIHdhbGtNYXAodiwgbWFwcGluZ0ZuLCBwYXRoLmNvbmNhdCh7IF9rZXksIF9pbmRleDogaWR4IH0pKTtcbiAgICB9XG4gICAgcmV0dXJuIHdhbGtNYXAodiwgbWFwcGluZ0ZuLCBwYXRoLmNvbmNhdChpZHgpKTtcbiAgfSkgOiBpc1JlY29yZCh2YWx1ZSkgPyBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgT2JqZWN0LmVudHJpZXModmFsdWUpLm1hcCgoW2ssIHZdKSA9PiBbaywgd2Fsa01hcCh2LCBtYXBwaW5nRm4sIHBhdGguY29uY2F0KGspKV0pXG4gICkgOiBtYXBwaW5nRm4odmFsdWUsIHBhdGgpO1xufVxuZnVuY3Rpb24gZW5jb2RlSW50b1Jlc3VsdChyZXN1bHQsIGNzbSwgZW5jb2Rlcikge1xuICByZXR1cm4gd2Fsa01hcChyZXN1bHQsICh2YWx1ZSwgcGF0aCkgPT4ge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT0gXCJzdHJpbmdcIilcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICBjb25zdCByZXNvbHZlTWFwcGluZ1Jlc3VsdCA9IHJlc29sdmVNYXBwaW5nKHBhdGgsIGNzbSk7XG4gICAgaWYgKCFyZXNvbHZlTWFwcGluZ1Jlc3VsdClcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICBjb25zdCB7IG1hcHBpbmcsIG1hdGNoZWRQYXRoIH0gPSByZXNvbHZlTWFwcGluZ1Jlc3VsdDtcbiAgICBpZiAobWFwcGluZy50eXBlICE9PSBcInZhbHVlXCIgfHwgbWFwcGluZy5zb3VyY2UudHlwZSAhPT0gXCJkb2N1bWVudFZhbHVlXCIpXG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgY29uc3Qgc291cmNlRG9jdW1lbnQgPSBjc20uZG9jdW1lbnRzW21hcHBpbmcuc291cmNlLmRvY3VtZW50XSwgc291cmNlUGF0aCA9IGNzbS5wYXRoc1ttYXBwaW5nLnNvdXJjZS5wYXRoXSwgbWF0Y2hQYXRoU2VnbWVudHMgPSBwYXJzZUpzb25QYXRoKG1hdGNoZWRQYXRoKSwgZnVsbFNvdXJjZVNlZ21lbnRzID0gcGFyc2VKc29uUGF0aChzb3VyY2VQYXRoKS5jb25jYXQocGF0aC5zbGljZShtYXRjaFBhdGhTZWdtZW50cy5sZW5ndGgpKTtcbiAgICByZXR1cm4gZW5jb2Rlcih7XG4gICAgICBzb3VyY2VQYXRoOiBmdWxsU291cmNlU2VnbWVudHMsXG4gICAgICBzb3VyY2VEb2N1bWVudCxcbiAgICAgIHJlc3VsdFBhdGg6IHBhdGgsXG4gICAgICB2YWx1ZVxuICAgIH0pO1xuICB9KTtcbn1cbmNvbnN0IERSQUZUU19QUkVGSVggPSBcImRyYWZ0cy5cIjtcbmZ1bmN0aW9uIGdldFB1Ymxpc2hlZElkKGlkKSB7XG4gIHJldHVybiBpZC5zdGFydHNXaXRoKERSQUZUU19QUkVGSVgpID8gaWQuc2xpY2UoRFJBRlRTX1BSRUZJWC5sZW5ndGgpIDogaWQ7XG59XG5mdW5jdGlvbiBjcmVhdGVFZGl0VXJsKG9wdGlvbnMpIHtcbiAgY29uc3Qge1xuICAgIGJhc2VVcmwsXG4gICAgd29ya3NwYWNlOiBfd29ya3NwYWNlID0gXCJkZWZhdWx0XCIsXG4gICAgdG9vbDogX3Rvb2wgPSBcImRlZmF1bHRcIixcbiAgICBpZDogX2lkLFxuICAgIHR5cGUsXG4gICAgcGF0aCxcbiAgICBwcm9qZWN0SWQsXG4gICAgZGF0YXNldFxuICB9ID0gb3B0aW9ucztcbiAgaWYgKCFiYXNlVXJsKVxuICAgIHRocm93IG5ldyBFcnJvcihcImJhc2VVcmwgaXMgcmVxdWlyZWRcIik7XG4gIGlmICghcGF0aClcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJwYXRoIGlzIHJlcXVpcmVkXCIpO1xuICBpZiAoIV9pZClcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpZCBpcyByZXF1aXJlZFwiKTtcbiAgaWYgKGJhc2VVcmwgIT09IFwiL1wiICYmIGJhc2VVcmwuZW5kc1dpdGgoXCIvXCIpKVxuICAgIHRocm93IG5ldyBFcnJvcihcImJhc2VVcmwgbXVzdCBub3QgZW5kIHdpdGggYSBzbGFzaFwiKTtcbiAgY29uc3Qgd29ya3NwYWNlID0gX3dvcmtzcGFjZSA9PT0gXCJkZWZhdWx0XCIgPyB2b2lkIDAgOiBfd29ya3NwYWNlLCB0b29sID0gX3Rvb2wgPT09IFwiZGVmYXVsdFwiID8gdm9pZCAwIDogX3Rvb2wsIGlkID0gZ2V0UHVibGlzaGVkSWQoX2lkKSwgc3RyaW5naWZpZWRQYXRoID0gQXJyYXkuaXNBcnJheShwYXRoKSA/IHRvU3RyaW5nKGpzb25QYXRoVG9TdHVkaW9QYXRoKHBhdGgpKSA6IHBhdGgsIHNlYXJjaFBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoe1xuICAgIGJhc2VVcmwsXG4gICAgaWQsXG4gICAgdHlwZSxcbiAgICBwYXRoOiBzdHJpbmdpZmllZFBhdGhcbiAgfSk7XG4gIHdvcmtzcGFjZSAmJiBzZWFyY2hQYXJhbXMuc2V0KFwid29ya3NwYWNlXCIsIHdvcmtzcGFjZSksIHRvb2wgJiYgc2VhcmNoUGFyYW1zLnNldChcInRvb2xcIiwgdG9vbCksIHByb2plY3RJZCAmJiBzZWFyY2hQYXJhbXMuc2V0KFwicHJvamVjdElkXCIsIHByb2plY3RJZCksIGRhdGFzZXQgJiYgc2VhcmNoUGFyYW1zLnNldChcImRhdGFzZXRcIiwgZGF0YXNldCk7XG4gIGNvbnN0IHNlZ21lbnRzID0gW2Jhc2VVcmwgPT09IFwiL1wiID8gXCJcIiA6IGJhc2VVcmxdO1xuICB3b3Jrc3BhY2UgJiYgc2VnbWVudHMucHVzaCh3b3Jrc3BhY2UpO1xuICBjb25zdCByb3V0ZXJQYXJhbXMgPSBbXG4gICAgXCJtb2RlPXByZXNlbnRhdGlvblwiLFxuICAgIGBpZD0ke2lkfWAsXG4gICAgYHR5cGU9JHt0eXBlfWAsXG4gICAgYHBhdGg9JHtlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZpZWRQYXRoKX1gXG4gIF07XG4gIHJldHVybiB0b29sICYmIHJvdXRlclBhcmFtcy5wdXNoKGB0b29sPSR7dG9vbH1gKSwgc2VnbWVudHMucHVzaChcImludGVudFwiLCBcImVkaXRcIiwgYCR7cm91dGVyUGFyYW1zLmpvaW4oXCI7XCIpfT8ke3NlYXJjaFBhcmFtc31gKSwgc2VnbWVudHMuam9pbihcIi9cIik7XG59XG5mdW5jdGlvbiByZXNvbHZlU3R1ZGlvQmFzZVJvdXRlKHN0dWRpb1VybCkge1xuICBsZXQgYmFzZVVybCA9IHR5cGVvZiBzdHVkaW9VcmwgPT0gXCJzdHJpbmdcIiA/IHN0dWRpb1VybCA6IHN0dWRpb1VybC5iYXNlVXJsO1xuICByZXR1cm4gYmFzZVVybCAhPT0gXCIvXCIgJiYgKGJhc2VVcmwgPSBiYXNlVXJsLnJlcGxhY2UoL1xcLyQvLCBcIlwiKSksIHR5cGVvZiBzdHVkaW9VcmwgPT0gXCJzdHJpbmdcIiA/IHsgYmFzZVVybCB9IDogeyAuLi5zdHVkaW9VcmwsIGJhc2VVcmwgfTtcbn1cbmNvbnN0IGZpbHRlckRlZmF1bHQgPSAoeyBzb3VyY2VQYXRoLCB2YWx1ZSB9KSA9PiB7XG4gIGlmIChpc1ZhbGlkRGF0ZSh2YWx1ZSkgfHwgaXNWYWxpZFVSTCh2YWx1ZSkpXG4gICAgcmV0dXJuICExO1xuICBjb25zdCBlbmRQYXRoID0gc291cmNlUGF0aC5hdCgtMSk7XG4gIHJldHVybiAhKHNvdXJjZVBhdGguYXQoLTIpID09PSBcInNsdWdcIiAmJiBlbmRQYXRoID09PSBcImN1cnJlbnRcIiB8fCB0eXBlb2YgZW5kUGF0aCA9PSBcInN0cmluZ1wiICYmIGVuZFBhdGguc3RhcnRzV2l0aChcIl9cIikgfHwgdHlwZW9mIGVuZFBhdGggPT0gXCJudW1iZXJcIiAmJiBzb3VyY2VQYXRoLmF0KC0yKSA9PT0gXCJtYXJrc1wiIHx8IGVuZFBhdGggPT09IFwiaHJlZlwiICYmIHR5cGVvZiBzb3VyY2VQYXRoLmF0KC0yKSA9PSBcIm51bWJlclwiICYmIHNvdXJjZVBhdGguYXQoLTMpID09PSBcIm1hcmtEZWZzXCIgfHwgZW5kUGF0aCA9PT0gXCJzdHlsZVwiIHx8IGVuZFBhdGggPT09IFwibGlzdEl0ZW1cIiB8fCBzb3VyY2VQYXRoLnNvbWUoXG4gICAgKHBhdGgpID0+IHBhdGggPT09IFwibWV0YVwiIHx8IHBhdGggPT09IFwibWV0YWRhdGFcIiB8fCBwYXRoID09PSBcIm9wZW5HcmFwaFwiIHx8IHBhdGggPT09IFwic2VvXCJcbiAgKSB8fCB0eXBlb2YgZW5kUGF0aCA9PSBcInN0cmluZ1wiICYmIGRlbnlsaXN0LmhhcyhlbmRQYXRoKSk7XG59LCBkZW55bGlzdCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcbiAgXCJjb2xvclwiLFxuICBcImNvbG91clwiLFxuICBcImN1cnJlbmN5XCIsXG4gIFwiZW1haWxcIixcbiAgXCJmb3JtYXRcIixcbiAgXCJnaWRcIixcbiAgXCJoZXhcIixcbiAgXCJocmVmXCIsXG4gIFwiaHNsXCIsXG4gIFwiaHNsYVwiLFxuICBcImljb25cIixcbiAgXCJpZFwiLFxuICBcImluZGV4XCIsXG4gIFwia2V5XCIsXG4gIFwibGFuZ3VhZ2VcIixcbiAgXCJsYXlvdXRcIixcbiAgXCJsaW5rXCIsXG4gIFwibGlua0FjdGlvblwiLFxuICBcImxvY2FsZVwiLFxuICBcImxxaXBcIixcbiAgXCJwYWdlXCIsXG4gIFwicGF0aFwiLFxuICBcInJlZlwiLFxuICBcInJnYlwiLFxuICBcInJnYmFcIixcbiAgXCJyb3V0ZVwiLFxuICBcInNlY3JldFwiLFxuICBcInNsdWdcIixcbiAgXCJzdGF0dXNcIixcbiAgXCJ0YWdcIixcbiAgXCJ0ZW1wbGF0ZVwiLFxuICBcInRoZW1lXCIsXG4gIFwidHlwZVwiLFxuICBcInVuaXRcIixcbiAgXCJ1cmxcIixcbiAgXCJ1c2VybmFtZVwiLFxuICBcInZhcmlhbnRcIixcbiAgXCJ3ZWJzaXRlXCJcbl0pO1xuZnVuY3Rpb24gaXNWYWxpZERhdGUoZGF0ZVN0cmluZykge1xuICByZXR1cm4gL15cXGR7NH0tXFxkezJ9LVxcZHsyfS8udGVzdChkYXRlU3RyaW5nKSA/ICEhRGF0ZS5wYXJzZShkYXRlU3RyaW5nKSA6ICExO1xufVxuZnVuY3Rpb24gaXNWYWxpZFVSTCh1cmwpIHtcbiAgdHJ5IHtcbiAgICBuZXcgVVJMKHVybCwgdXJsLnN0YXJ0c1dpdGgoXCIvXCIpID8gXCJodHRwczovL2FjbWUuY29tXCIgOiB2b2lkIDApO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gITE7XG4gIH1cbiAgcmV0dXJuICEwO1xufVxuY29uc3QgVFJVTkNBVEVfTEVOR1RIID0gMjA7XG5mdW5jdGlvbiBzdGVnYUVuY29kZVNvdXJjZU1hcChyZXN1bHQsIHJlc3VsdFNvdXJjZU1hcCwgY29uZmlnKSB7XG4gIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZywgX2gsIF9pO1xuICBjb25zdCB7IGZpbHRlciwgbG9nZ2VyLCBlbmFibGVkIH0gPSBjb25maWc7XG4gIGlmICghZW5hYmxlZCkge1xuICAgIGNvbnN0IG1zZyA9IFwiY29uZmlnLmVuYWJsZWQgbXVzdCBiZSB0cnVlLCBkb24ndCBjYWxsIHRoaXMgZnVuY3Rpb24gb3RoZXJ3aXNlXCI7XG4gICAgdGhyb3cgKF9hID0gbG9nZ2VyID09IG51bGwgPyB2b2lkIDAgOiBsb2dnZXIuZXJyb3IpID09IG51bGwgfHwgX2EuY2FsbChsb2dnZXIsIGBbQHNhbml0eS9jbGllbnRdOiAke21zZ31gLCB7IHJlc3VsdCwgcmVzdWx0U291cmNlTWFwLCBjb25maWcgfSksIG5ldyBUeXBlRXJyb3IobXNnKTtcbiAgfVxuICBpZiAoIXJlc3VsdFNvdXJjZU1hcClcbiAgICByZXR1cm4gKF9iID0gbG9nZ2VyID09IG51bGwgPyB2b2lkIDAgOiBsb2dnZXIuZXJyb3IpID09IG51bGwgfHwgX2IuY2FsbChsb2dnZXIsIFwiW0BzYW5pdHkvY2xpZW50XTogTWlzc2luZyBDb250ZW50IFNvdXJjZSBNYXAgZnJvbSByZXNwb25zZSBib2R5XCIsIHtcbiAgICAgIHJlc3VsdCxcbiAgICAgIHJlc3VsdFNvdXJjZU1hcCxcbiAgICAgIGNvbmZpZ1xuICAgIH0pLCByZXN1bHQ7XG4gIGlmICghY29uZmlnLnN0dWRpb1VybCkge1xuICAgIGNvbnN0IG1zZyA9IFwiY29uZmlnLnN0dWRpb1VybCBtdXN0IGJlIGRlZmluZWRcIjtcbiAgICB0aHJvdyAoX2MgPSBsb2dnZXIgPT0gbnVsbCA/IHZvaWQgMCA6IGxvZ2dlci5lcnJvcikgPT0gbnVsbCB8fCBfYy5jYWxsKGxvZ2dlciwgYFtAc2FuaXR5L2NsaWVudF06ICR7bXNnfWAsIHsgcmVzdWx0LCByZXN1bHRTb3VyY2VNYXAsIGNvbmZpZyB9KSwgbmV3IFR5cGVFcnJvcihtc2cpO1xuICB9XG4gIGNvbnN0IHJlcG9ydCA9IHtcbiAgICBlbmNvZGVkOiBbXSxcbiAgICBza2lwcGVkOiBbXVxuICB9LCByZXN1bHRXaXRoU3RlZ2EgPSBlbmNvZGVJbnRvUmVzdWx0KFxuICAgIHJlc3VsdCxcbiAgICByZXN1bHRTb3VyY2VNYXAsXG4gICAgKHsgc291cmNlUGF0aCwgc291cmNlRG9jdW1lbnQsIHJlc3VsdFBhdGgsIHZhbHVlIH0pID0+IHtcbiAgICAgIGlmICgodHlwZW9mIGZpbHRlciA9PSBcImZ1bmN0aW9uXCIgPyBmaWx0ZXIoeyBzb3VyY2VQYXRoLCByZXN1bHRQYXRoLCBmaWx0ZXJEZWZhdWx0LCBzb3VyY2VEb2N1bWVudCwgdmFsdWUgfSkgOiBmaWx0ZXJEZWZhdWx0KHsgc291cmNlUGF0aCwgcmVzdWx0UGF0aCwgZmlsdGVyRGVmYXVsdCwgc291cmNlRG9jdW1lbnQsIHZhbHVlIH0pKSA9PT0gITEpXG4gICAgICAgIHJldHVybiBsb2dnZXIgJiYgcmVwb3J0LnNraXBwZWQucHVzaCh7XG4gICAgICAgICAgcGF0aDogcHJldHR5UGF0aEZvckxvZ2dpbmcoc291cmNlUGF0aCksXG4gICAgICAgICAgdmFsdWU6IGAke3ZhbHVlLnNsaWNlKDAsIFRSVU5DQVRFX0xFTkdUSCl9JHt2YWx1ZS5sZW5ndGggPiBUUlVOQ0FURV9MRU5HVEggPyBcIi4uLlwiIDogXCJcIn1gLFxuICAgICAgICAgIGxlbmd0aDogdmFsdWUubGVuZ3RoXG4gICAgICAgIH0pLCB2YWx1ZTtcbiAgICAgIGxvZ2dlciAmJiByZXBvcnQuZW5jb2RlZC5wdXNoKHtcbiAgICAgICAgcGF0aDogcHJldHR5UGF0aEZvckxvZ2dpbmcoc291cmNlUGF0aCksXG4gICAgICAgIHZhbHVlOiBgJHt2YWx1ZS5zbGljZSgwLCBUUlVOQ0FURV9MRU5HVEgpfSR7dmFsdWUubGVuZ3RoID4gVFJVTkNBVEVfTEVOR1RIID8gXCIuLi5cIiA6IFwiXCJ9YCxcbiAgICAgICAgbGVuZ3RoOiB2YWx1ZS5sZW5ndGhcbiAgICAgIH0pO1xuICAgICAgY29uc3QgeyBiYXNlVXJsLCB3b3Jrc3BhY2UsIHRvb2wgfSA9IHJlc29sdmVTdHVkaW9CYXNlUm91dGUoXG4gICAgICAgIHR5cGVvZiBjb25maWcuc3R1ZGlvVXJsID09IFwiZnVuY3Rpb25cIiA/IGNvbmZpZy5zdHVkaW9Vcmwoc291cmNlRG9jdW1lbnQpIDogY29uZmlnLnN0dWRpb1VybFxuICAgICAgKTtcbiAgICAgIGlmICghYmFzZVVybClcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgY29uc3QgeyBfaWQ6IGlkLCBfdHlwZTogdHlwZSwgX3Byb2plY3RJZDogcHJvamVjdElkLCBfZGF0YXNldDogZGF0YXNldCB9ID0gc291cmNlRG9jdW1lbnQ7XG4gICAgICByZXR1cm4gYihcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIHtcbiAgICAgICAgICBvcmlnaW46IFwic2FuaXR5LmlvXCIsXG4gICAgICAgICAgaHJlZjogY3JlYXRlRWRpdFVybCh7XG4gICAgICAgICAgICBiYXNlVXJsLFxuICAgICAgICAgICAgd29ya3NwYWNlLFxuICAgICAgICAgICAgdG9vbCxcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgIHBhdGg6IHNvdXJjZVBhdGgsXG4gICAgICAgICAgICAuLi4hY29uZmlnLm9taXRDcm9zc0RhdGFzZXRSZWZlcmVuY2VEYXRhICYmIHsgZGF0YXNldCwgcHJvamVjdElkIH1cbiAgICAgICAgICB9KVxuICAgICAgICB9LFxuICAgICAgICAvLyBXZSB1c2UgY3VzdG9tIGxvZ2ljIHRvIGRldGVybWluZSBpZiB3ZSBzaG91bGQgc2tpcCBlbmNvZGluZ1xuICAgICAgICAhMVxuICAgICAgKTtcbiAgICB9XG4gICk7XG4gIGlmIChsb2dnZXIpIHtcbiAgICBjb25zdCBpc1NraXBwaW5nID0gcmVwb3J0LnNraXBwZWQubGVuZ3RoLCBpc0VuY29kaW5nID0gcmVwb3J0LmVuY29kZWQubGVuZ3RoO1xuICAgIGlmICgoaXNTa2lwcGluZyB8fCBpc0VuY29kaW5nKSAmJiAoKF9kID0gKGxvZ2dlciA9PSBudWxsID8gdm9pZCAwIDogbG9nZ2VyLmdyb3VwQ29sbGFwc2VkKSB8fCBsb2dnZXIubG9nKSA9PSBudWxsIHx8IF9kKFwiW0BzYW5pdHkvY2xpZW50XTogRW5jb2Rpbmcgc291cmNlIG1hcCBpbnRvIHJlc3VsdFwiKSwgKF9lID0gbG9nZ2VyLmxvZykgPT0gbnVsbCB8fCBfZS5jYWxsKFxuICAgICAgbG9nZ2VyLFxuICAgICAgYFtAc2FuaXR5L2NsaWVudF06IFBhdGhzIGVuY29kZWQ6ICR7cmVwb3J0LmVuY29kZWQubGVuZ3RofSwgc2tpcHBlZDogJHtyZXBvcnQuc2tpcHBlZC5sZW5ndGh9YFxuICAgICkpLCByZXBvcnQuZW5jb2RlZC5sZW5ndGggPiAwICYmICgoX2YgPSBsb2dnZXIgPT0gbnVsbCA/IHZvaWQgMCA6IGxvZ2dlci5sb2cpID09IG51bGwgfHwgX2YuY2FsbChsb2dnZXIsIFwiW0BzYW5pdHkvY2xpZW50XTogVGFibGUgb2YgZW5jb2RlZCBwYXRoc1wiKSwgKF9nID0gKGxvZ2dlciA9PSBudWxsID8gdm9pZCAwIDogbG9nZ2VyLnRhYmxlKSB8fCBsb2dnZXIubG9nKSA9PSBudWxsIHx8IF9nKHJlcG9ydC5lbmNvZGVkKSksIHJlcG9ydC5za2lwcGVkLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IHNraXBwZWQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgICAgZm9yIChjb25zdCB7IHBhdGggfSBvZiByZXBvcnQuc2tpcHBlZClcbiAgICAgICAgc2tpcHBlZC5hZGQocGF0aC5yZXBsYWNlKHJlS2V5U2VnbWVudCwgXCIwXCIpLnJlcGxhY2UoL1xcW1xcZCtcXF0vZywgXCJbXVwiKSk7XG4gICAgICAoX2ggPSBsb2dnZXIgPT0gbnVsbCA/IHZvaWQgMCA6IGxvZ2dlci5sb2cpID09IG51bGwgfHwgX2guY2FsbChsb2dnZXIsIFwiW0BzYW5pdHkvY2xpZW50XTogTGlzdCBvZiBza2lwcGVkIHBhdGhzXCIsIFsuLi5za2lwcGVkLnZhbHVlcygpXSk7XG4gICAgfVxuICAgIChpc1NraXBwaW5nIHx8IGlzRW5jb2RpbmcpICYmICgoX2kgPSBsb2dnZXIgPT0gbnVsbCA/IHZvaWQgMCA6IGxvZ2dlci5ncm91cEVuZCkgPT0gbnVsbCB8fCBfaS5jYWxsKGxvZ2dlcikpO1xuICB9XG4gIHJldHVybiByZXN1bHRXaXRoU3RlZ2E7XG59XG5mdW5jdGlvbiBwcmV0dHlQYXRoRm9yTG9nZ2luZyhwYXRoKSB7XG4gIHJldHVybiB0b1N0cmluZyhqc29uUGF0aFRvU3R1ZGlvUGF0aChwYXRoKSk7XG59XG52YXIgc3RlZ2FFbmNvZGVTb3VyY2VNYXAkMSA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZnJlZXplKHtcbiAgX19wcm90b19fOiBudWxsLFxuICBzdGVnYUVuY29kZVNvdXJjZU1hcFxufSk7XG5leHBvcnQge1xuICBzdGVnYUVuY29kZVNvdXJjZU1hcCQxIGFzIGEsXG4gIGVuY29kZUludG9SZXN1bHQgYXMgZSxcbiAgc3RlZ2FFbmNvZGVTb3VyY2VNYXAgYXMgc1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0ZWdhRW5jb2RlU291cmNlTWFwLVpfMV9EbU5ELmpzLm1hcFxuIl0sIm5hbWVzIjpbImciLCJiIiwicmVLZXlTZWdtZW50IiwiaXNLZXlTZWdtZW50Iiwic2VnbWVudCIsInRlc3QiLCJ0cmltIiwidG9TdHJpbmciLCJwYXRoIiwiQXJyYXkiLCJpc0FycmF5IiwiRXJyb3IiLCJyZWR1Y2UiLCJ0YXJnZXQiLCJpIiwic2VnbWVudFR5cGUiLCJfa2V5IiwiZnJvbSIsInRvIiwiSlNPTiIsInN0cmluZ2lmeSIsIkVTQ0FQRSIsIlVORVNDQVBFIiwianNvblBhdGgiLCJtYXAiLCJyZXBsYWNlIiwibWF0Y2giLCJfaW5kZXgiLCJqb2luIiwicGFyc2VKc29uUGF0aCIsInBhcnNlZCIsInBhcnNlUmUiLCJleGVjIiwia2V5IiwibSIsInB1c2giLCJwYXJzZUludCIsImpzb25QYXRoVG9TdHVkaW9QYXRoIiwianNvblBhdGhUb01hcHBpbmdQYXRoIiwicmVzb2x2ZU1hcHBpbmciLCJyZXN1bHRQYXRoIiwiY3NtIiwibWFwcGluZ3MiLCJyZXN1bHRNYXBwaW5nUGF0aCIsIm1hcHBpbmciLCJtYXRjaGVkUGF0aCIsInBhdGhTdWZmaXgiLCJPYmplY3QiLCJlbnRyaWVzIiwiZmlsdGVyIiwic3RhcnRzV2l0aCIsInNvcnQiLCJrZXkxIiwia2V5MiIsImxlbmd0aCIsInN1YnN0cmluZyIsInZhbHVlIiwiaXNSZWNvcmQiLCJ3YWxrTWFwIiwibWFwcGluZ0ZuIiwidiIsImlkeCIsImNvbmNhdCIsImZyb21FbnRyaWVzIiwiayIsImVuY29kZUludG9SZXN1bHQiLCJyZXN1bHQiLCJlbmNvZGVyIiwicmVzb2x2ZU1hcHBpbmdSZXN1bHQiLCJ0eXBlIiwic291cmNlIiwic291cmNlRG9jdW1lbnQiLCJkb2N1bWVudHMiLCJkb2N1bWVudCIsInNvdXJjZVBhdGgiLCJwYXRocyIsIm1hdGNoUGF0aFNlZ21lbnRzIiwiZnVsbFNvdXJjZVNlZ21lbnRzIiwic2xpY2UiLCJEUkFGVFNfUFJFRklYIiwiZ2V0UHVibGlzaGVkSWQiLCJpZCIsImNyZWF0ZUVkaXRVcmwiLCJvcHRpb25zIiwiYmFzZVVybCIsIndvcmtzcGFjZSIsIl93b3Jrc3BhY2UiLCJ0b29sIiwiX3Rvb2wiLCJfaWQiLCJwcm9qZWN0SWQiLCJkYXRhc2V0IiwiZW5kc1dpdGgiLCJzdHJpbmdpZmllZFBhdGgiLCJzZWFyY2hQYXJhbXMiLCJVUkxTZWFyY2hQYXJhbXMiLCJzZXQiLCJzZWdtZW50cyIsInJvdXRlclBhcmFtcyIsImVuY29kZVVSSUNvbXBvbmVudCIsInJlc29sdmVTdHVkaW9CYXNlUm91dGUiLCJzdHVkaW9VcmwiLCJmaWx0ZXJEZWZhdWx0IiwiaXNWYWxpZERhdGUiLCJpc1ZhbGlkVVJMIiwiZW5kUGF0aCIsImF0Iiwic29tZSIsImRlbnlsaXN0IiwiaGFzIiwiU2V0IiwiZGF0ZVN0cmluZyIsIkRhdGUiLCJwYXJzZSIsInVybCIsIlVSTCIsIlRSVU5DQVRFX0xFTkdUSCIsInN0ZWdhRW5jb2RlU291cmNlTWFwIiwicmVzdWx0U291cmNlTWFwIiwiY29uZmlnIiwiX2EiLCJfYiIsIl9jIiwiX2QiLCJfZSIsIl9mIiwiX2ciLCJfaCIsIl9pIiwibG9nZ2VyIiwiZW5hYmxlZCIsIm1zZyIsImVycm9yIiwiY2FsbCIsIlR5cGVFcnJvciIsInJlcG9ydCIsImVuY29kZWQiLCJza2lwcGVkIiwicmVzdWx0V2l0aFN0ZWdhIiwicHJldHR5UGF0aEZvckxvZ2dpbmciLCJfdHlwZSIsIl9wcm9qZWN0SWQiLCJfZGF0YXNldCIsIm9yaWdpbiIsImhyZWYiLCJvbWl0Q3Jvc3NEYXRhc2V0UmVmZXJlbmNlRGF0YSIsImlzU2tpcHBpbmciLCJpc0VuY29kaW5nIiwiZ3JvdXBDb2xsYXBzZWQiLCJsb2ciLCJ0YWJsZSIsImFkZCIsInZhbHVlcyIsImdyb3VwRW5kIiwic3RlZ2FFbmNvZGVTb3VyY2VNYXAkMSIsImZyZWV6ZSIsIl9fcHJvdG9fXyIsImEiLCJlIiwicyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@sanity/client/dist/_chunks/stegaEncodeSourceMap-Z_1_DmND.js\n"));

/***/ })

}]);
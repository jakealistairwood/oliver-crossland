"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/get-it";
exports.ids = ["vendor-chunks/get-it"];
exports.modules = {

/***/ "(ssr)/./node_modules/get-it/node_modules/is-stream/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/get-it/node_modules/is-stream/index.js ***!
  \*************************************************************/
/***/ ((module) => {

eval("\nconst isStream = (stream)=>stream !== null && typeof stream === \"object\" && typeof stream.pipe === \"function\";\nisStream.writable = (stream)=>isStream(stream) && stream.writable !== false && typeof stream._write === \"function\" && typeof stream._writableState === \"object\";\nisStream.readable = (stream)=>isStream(stream) && stream.readable !== false && typeof stream._read === \"function\" && typeof stream._readableState === \"object\";\nisStream.duplex = (stream)=>isStream.writable(stream) && isStream.readable(stream);\nisStream.transform = (stream)=>isStream.duplex(stream) && typeof stream._transform === \"function\";\nmodule.exports = isStream;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ2V0LWl0L25vZGVfbW9kdWxlcy9pcy1zdHJlYW0vaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNQSxXQUFXQyxDQUFBQSxTQUNoQkEsV0FBVyxRQUNYLE9BQU9BLFdBQVcsWUFDbEIsT0FBT0EsT0FBT0MsSUFBSSxLQUFLO0FBRXhCRixTQUFTRyxRQUFRLEdBQUdGLENBQUFBLFNBQ25CRCxTQUFTQyxXQUNUQSxPQUFPRSxRQUFRLEtBQUssU0FDcEIsT0FBT0YsT0FBT0csTUFBTSxLQUFLLGNBQ3pCLE9BQU9ILE9BQU9JLGNBQWMsS0FBSztBQUVsQ0wsU0FBU00sUUFBUSxHQUFHTCxDQUFBQSxTQUNuQkQsU0FBU0MsV0FDVEEsT0FBT0ssUUFBUSxLQUFLLFNBQ3BCLE9BQU9MLE9BQU9NLEtBQUssS0FBSyxjQUN4QixPQUFPTixPQUFPTyxjQUFjLEtBQUs7QUFFbENSLFNBQVNTLE1BQU0sR0FBR1IsQ0FBQUEsU0FDakJELFNBQVNHLFFBQVEsQ0FBQ0YsV0FDbEJELFNBQVNNLFFBQVEsQ0FBQ0w7QUFFbkJELFNBQVNVLFNBQVMsR0FBR1QsQ0FBQUEsU0FDcEJELFNBQVNTLE1BQU0sQ0FBQ1IsV0FDaEIsT0FBT0EsT0FBT1UsVUFBVSxLQUFLO0FBRTlCQyxPQUFPQyxPQUFPLEdBQUdiIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vb2xpLWNyb3NzbGFuZC12aWRlb2dyYXBoeS8uL25vZGVfbW9kdWxlcy9nZXQtaXQvbm9kZV9tb2R1bGVzL2lzLXN0cmVhbS9pbmRleC5qcz8wNDEwIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgaXNTdHJlYW0gPSBzdHJlYW0gPT5cblx0c3RyZWFtICE9PSBudWxsICYmXG5cdHR5cGVvZiBzdHJlYW0gPT09ICdvYmplY3QnICYmXG5cdHR5cGVvZiBzdHJlYW0ucGlwZSA9PT0gJ2Z1bmN0aW9uJztcblxuaXNTdHJlYW0ud3JpdGFibGUgPSBzdHJlYW0gPT5cblx0aXNTdHJlYW0oc3RyZWFtKSAmJlxuXHRzdHJlYW0ud3JpdGFibGUgIT09IGZhbHNlICYmXG5cdHR5cGVvZiBzdHJlYW0uX3dyaXRlID09PSAnZnVuY3Rpb24nICYmXG5cdHR5cGVvZiBzdHJlYW0uX3dyaXRhYmxlU3RhdGUgPT09ICdvYmplY3QnO1xuXG5pc1N0cmVhbS5yZWFkYWJsZSA9IHN0cmVhbSA9PlxuXHRpc1N0cmVhbShzdHJlYW0pICYmXG5cdHN0cmVhbS5yZWFkYWJsZSAhPT0gZmFsc2UgJiZcblx0dHlwZW9mIHN0cmVhbS5fcmVhZCA9PT0gJ2Z1bmN0aW9uJyAmJlxuXHR0eXBlb2Ygc3RyZWFtLl9yZWFkYWJsZVN0YXRlID09PSAnb2JqZWN0JztcblxuaXNTdHJlYW0uZHVwbGV4ID0gc3RyZWFtID0+XG5cdGlzU3RyZWFtLndyaXRhYmxlKHN0cmVhbSkgJiZcblx0aXNTdHJlYW0ucmVhZGFibGUoc3RyZWFtKTtcblxuaXNTdHJlYW0udHJhbnNmb3JtID0gc3RyZWFtID0+XG5cdGlzU3RyZWFtLmR1cGxleChzdHJlYW0pICYmXG5cdHR5cGVvZiBzdHJlYW0uX3RyYW5zZm9ybSA9PT0gJ2Z1bmN0aW9uJztcblxubW9kdWxlLmV4cG9ydHMgPSBpc1N0cmVhbTtcbiJdLCJuYW1lcyI6WyJpc1N0cmVhbSIsInN0cmVhbSIsInBpcGUiLCJ3cml0YWJsZSIsIl93cml0ZSIsIl93cml0YWJsZVN0YXRlIiwicmVhZGFibGUiLCJfcmVhZCIsIl9yZWFkYWJsZVN0YXRlIiwiZHVwbGV4IiwidHJhbnNmb3JtIiwiX3RyYW5zZm9ybSIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/get-it/node_modules/is-stream/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/get-it/dist/_chunks/defaultOptionsValidator-CXwrNjme.cjs":
/*!*******************************************************************************!*\
  !*** ./node_modules/get-it/dist/_chunks/defaultOptionsValidator-CXwrNjme.cjs ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nconst isReactNative = typeof navigator > \"u\" ? !1 : navigator.product === \"ReactNative\", defaultOptions = {\n    timeout: isReactNative ? 6e4 : 12e4\n}, processOptions = function(opts) {\n    const options = {\n        ...defaultOptions,\n        ...typeof opts == \"string\" ? {\n            url: opts\n        } : opts\n    }, { searchParams } = new URL(options.url, \"http://localhost\");\n    if (options.timeout = normalizeTimeout(options.timeout), options.query) {\n        for (const [key, value] of Object.entries(options.query))if (value !== void 0) if (Array.isArray(value)) for (const v of value)searchParams.append(key, v);\n        else searchParams.append(key, value);\n    }\n    const [url] = options.url.split(\"?\"), search = searchParams.toString();\n    return search && (options.url = `${url}?${search}`), options.method = options.body && !options.method ? \"POST\" : (options.method || \"GET\").toUpperCase(), options;\n};\nfunction normalizeTimeout(time) {\n    if (time === !1 || time === 0) return !1;\n    if (time.connect || time.socket) return time;\n    const delay = Number(time);\n    return isNaN(delay) ? normalizeTimeout(defaultOptions.timeout) : {\n        connect: delay,\n        socket: delay\n    };\n}\nconst validUrl = /^https?:\\/\\//i, validateOptions = function(options) {\n    if (!validUrl.test(options.url)) throw new Error(`\"${options.url}\" is not a valid URL`);\n};\nexports.processOptions = processOptions;\nexports.validateOptions = validateOptions; //# sourceMappingURL=defaultOptionsValidator-CXwrNjme.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ2V0LWl0L2Rpc3QvX2NodW5rcy9kZWZhdWx0T3B0aW9uc1ZhbGlkYXRvci1DWHdyTmptZS5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixNQUFNQSxnQkFBZ0IsT0FBT0MsWUFBWSxNQUFNLENBQUMsSUFBSUEsVUFBVUMsT0FBTyxLQUFLLGVBQWVDLGlCQUFpQjtJQUFFQyxTQUFTSixnQkFBZ0IsTUFBTTtBQUFLLEdBQUdLLGlCQUFpQixTQUFTQyxJQUFJO0lBQy9LLE1BQU1DLFVBQVU7UUFDZCxHQUFHSixjQUFjO1FBQ2pCLEdBQUcsT0FBT0csUUFBUSxXQUFXO1lBQUVFLEtBQUtGO1FBQUssSUFBSUEsSUFBSTtJQUNuRCxHQUFHLEVBQUVHLFlBQVksRUFBRSxHQUFHLElBQUlDLElBQUlILFFBQVFDLEdBQUcsRUFBRTtJQUMzQyxJQUFJRCxRQUFRSCxPQUFPLEdBQUdPLGlCQUFpQkosUUFBUUgsT0FBTyxHQUFHRyxRQUFRSyxLQUFLLEVBQUU7UUFDdEUsS0FBSyxNQUFNLENBQUNDLEtBQUtDLE1BQU0sSUFBSUMsT0FBT0MsT0FBTyxDQUFDVCxRQUFRSyxLQUFLLEVBQ3JELElBQUlFLFVBQVUsS0FBSyxHQUNqQixJQUFJRyxNQUFNQyxPQUFPLENBQUNKLFFBQ2hCLEtBQUssTUFBTUssS0FBS0wsTUFDZEwsYUFBYVcsTUFBTSxDQUFDUCxLQUFLTTthQUUzQlYsYUFBYVcsTUFBTSxDQUFDUCxLQUFLQztJQUNqQztJQUNBLE1BQU0sQ0FBQ04sSUFBSSxHQUFHRCxRQUFRQyxHQUFHLENBQUNhLEtBQUssQ0FBQyxNQUFNQyxTQUFTYixhQUFhYyxRQUFRO0lBQ3BFLE9BQU9ELFVBQVdmLENBQUFBLFFBQVFDLEdBQUcsR0FBRyxDQUFDLEVBQUVBLElBQUksQ0FBQyxFQUFFYyxPQUFPLENBQUMsR0FBR2YsUUFBUWlCLE1BQU0sR0FBR2pCLFFBQVFrQixJQUFJLElBQUksQ0FBQ2xCLFFBQVFpQixNQUFNLEdBQUcsU0FBUyxDQUFDakIsUUFBUWlCLE1BQU0sSUFBSSxLQUFJLEVBQUdFLFdBQVcsSUFBSW5CO0FBQzVKO0FBQ0EsU0FBU0ksaUJBQWlCZ0IsSUFBSTtJQUM1QixJQUFJQSxTQUFTLENBQUMsS0FBS0EsU0FBUyxHQUMxQixPQUFPLENBQUM7SUFDVixJQUFJQSxLQUFLQyxPQUFPLElBQUlELEtBQUtFLE1BQU0sRUFDN0IsT0FBT0Y7SUFDVCxNQUFNRyxRQUFRQyxPQUFPSjtJQUNyQixPQUFPSyxNQUFNRixTQUFTbkIsaUJBQWlCUixlQUFlQyxPQUFPLElBQUk7UUFBRXdCLFNBQVNFO1FBQU9ELFFBQVFDO0lBQU07QUFDbkc7QUFDQSxNQUFNRyxXQUFXLGlCQUFpQkMsa0JBQWtCLFNBQVMzQixPQUFPO0lBQ2xFLElBQUksQ0FBQzBCLFNBQVNFLElBQUksQ0FBQzVCLFFBQVFDLEdBQUcsR0FDNUIsTUFBTSxJQUFJNEIsTUFBTSxDQUFDLENBQUMsRUFBRTdCLFFBQVFDLEdBQUcsQ0FBQyxvQkFBb0IsQ0FBQztBQUN6RDtBQUNBNkIsc0JBQXNCLEdBQUdoQztBQUN6QmdDLHVCQUF1QixHQUFHSCxpQkFDMUIsNkRBQTZEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vb2xpLWNyb3NzbGFuZC12aWRlb2dyYXBoeS8uL25vZGVfbW9kdWxlcy9nZXQtaXQvZGlzdC9fY2h1bmtzL2RlZmF1bHRPcHRpb25zVmFsaWRhdG9yLUNYd3JOam1lLmNqcz9jZTEwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuY29uc3QgaXNSZWFjdE5hdGl2ZSA9IHR5cGVvZiBuYXZpZ2F0b3IgPiBcInVcIiA/ICExIDogbmF2aWdhdG9yLnByb2R1Y3QgPT09IFwiUmVhY3ROYXRpdmVcIiwgZGVmYXVsdE9wdGlvbnMgPSB7IHRpbWVvdXQ6IGlzUmVhY3ROYXRpdmUgPyA2ZTQgOiAxMmU0IH0sIHByb2Nlc3NPcHRpb25zID0gZnVuY3Rpb24ob3B0cykge1xuICBjb25zdCBvcHRpb25zID0ge1xuICAgIC4uLmRlZmF1bHRPcHRpb25zLFxuICAgIC4uLnR5cGVvZiBvcHRzID09IFwic3RyaW5nXCIgPyB7IHVybDogb3B0cyB9IDogb3B0c1xuICB9LCB7IHNlYXJjaFBhcmFtcyB9ID0gbmV3IFVSTChvcHRpb25zLnVybCwgXCJodHRwOi8vbG9jYWxob3N0XCIpO1xuICBpZiAob3B0aW9ucy50aW1lb3V0ID0gbm9ybWFsaXplVGltZW91dChvcHRpb25zLnRpbWVvdXQpLCBvcHRpb25zLnF1ZXJ5KSB7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMob3B0aW9ucy5xdWVyeSkpXG4gICAgICBpZiAodmFsdWUgIT09IHZvaWQgMClcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKVxuICAgICAgICAgIGZvciAoY29uc3QgdiBvZiB2YWx1ZSlcbiAgICAgICAgICAgIHNlYXJjaFBhcmFtcy5hcHBlbmQoa2V5LCB2KTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHNlYXJjaFBhcmFtcy5hcHBlbmQoa2V5LCB2YWx1ZSk7XG4gIH1cbiAgY29uc3QgW3VybF0gPSBvcHRpb25zLnVybC5zcGxpdChcIj9cIiksIHNlYXJjaCA9IHNlYXJjaFBhcmFtcy50b1N0cmluZygpO1xuICByZXR1cm4gc2VhcmNoICYmIChvcHRpb25zLnVybCA9IGAke3VybH0/JHtzZWFyY2h9YCksIG9wdGlvbnMubWV0aG9kID0gb3B0aW9ucy5ib2R5ICYmICFvcHRpb25zLm1ldGhvZCA/IFwiUE9TVFwiIDogKG9wdGlvbnMubWV0aG9kIHx8IFwiR0VUXCIpLnRvVXBwZXJDYXNlKCksIG9wdGlvbnM7XG59O1xuZnVuY3Rpb24gbm9ybWFsaXplVGltZW91dCh0aW1lKSB7XG4gIGlmICh0aW1lID09PSAhMSB8fCB0aW1lID09PSAwKVxuICAgIHJldHVybiAhMTtcbiAgaWYgKHRpbWUuY29ubmVjdCB8fCB0aW1lLnNvY2tldClcbiAgICByZXR1cm4gdGltZTtcbiAgY29uc3QgZGVsYXkgPSBOdW1iZXIodGltZSk7XG4gIHJldHVybiBpc05hTihkZWxheSkgPyBub3JtYWxpemVUaW1lb3V0KGRlZmF1bHRPcHRpb25zLnRpbWVvdXQpIDogeyBjb25uZWN0OiBkZWxheSwgc29ja2V0OiBkZWxheSB9O1xufVxuY29uc3QgdmFsaWRVcmwgPSAvXmh0dHBzPzpcXC9cXC8vaSwgdmFsaWRhdGVPcHRpb25zID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICBpZiAoIXZhbGlkVXJsLnRlc3Qob3B0aW9ucy51cmwpKVxuICAgIHRocm93IG5ldyBFcnJvcihgXCIke29wdGlvbnMudXJsfVwiIGlzIG5vdCBhIHZhbGlkIFVSTGApO1xufTtcbmV4cG9ydHMucHJvY2Vzc09wdGlvbnMgPSBwcm9jZXNzT3B0aW9ucztcbmV4cG9ydHMudmFsaWRhdGVPcHRpb25zID0gdmFsaWRhdGVPcHRpb25zO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVmYXVsdE9wdGlvbnNWYWxpZGF0b3ItQ1h3ck5qbWUuY2pzLm1hcFxuIl0sIm5hbWVzIjpbImlzUmVhY3ROYXRpdmUiLCJuYXZpZ2F0b3IiLCJwcm9kdWN0IiwiZGVmYXVsdE9wdGlvbnMiLCJ0aW1lb3V0IiwicHJvY2Vzc09wdGlvbnMiLCJvcHRzIiwib3B0aW9ucyIsInVybCIsInNlYXJjaFBhcmFtcyIsIlVSTCIsIm5vcm1hbGl6ZVRpbWVvdXQiLCJxdWVyeSIsImtleSIsInZhbHVlIiwiT2JqZWN0IiwiZW50cmllcyIsIkFycmF5IiwiaXNBcnJheSIsInYiLCJhcHBlbmQiLCJzcGxpdCIsInNlYXJjaCIsInRvU3RyaW5nIiwibWV0aG9kIiwiYm9keSIsInRvVXBwZXJDYXNlIiwidGltZSIsImNvbm5lY3QiLCJzb2NrZXQiLCJkZWxheSIsIk51bWJlciIsImlzTmFOIiwidmFsaWRVcmwiLCJ2YWxpZGF0ZU9wdGlvbnMiLCJ0ZXN0IiwiRXJyb3IiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/get-it/dist/_chunks/defaultOptionsValidator-CXwrNjme.cjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/get-it/dist/index.cjs":
/*!********************************************!*\
  !*** ./node_modules/get-it/dist/index.cjs ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: !0\n}));\nvar defaultOptionsValidator = __webpack_require__(/*! ./_chunks/defaultOptionsValidator-CXwrNjme.cjs */ \"(ssr)/./node_modules/get-it/dist/_chunks/defaultOptionsValidator-CXwrNjme.cjs\"), decompressResponse = __webpack_require__(/*! decompress-response */ \"(ssr)/./node_modules/decompress-response/index.js\"), follow = __webpack_require__(/*! follow-redirects */ \"(ssr)/./node_modules/follow-redirects/index.js\"), http = __webpack_require__(/*! http */ \"http\"), https = __webpack_require__(/*! https */ \"https\"), toStream = __webpack_require__(/*! into-stream */ \"(ssr)/./node_modules/into-stream/index.js\"), isStream = __webpack_require__(/*! is-stream */ \"(ssr)/./node_modules/get-it/node_modules/is-stream/index.js\"), progressStream = __webpack_require__(/*! progress-stream */ \"(ssr)/./node_modules/progress-stream/index.js\"), qs = __webpack_require__(/*! querystring */ \"querystring\"), url = __webpack_require__(/*! url */ \"url\"), tunnel = __webpack_require__(/*! tunnel-agent */ \"(ssr)/./node_modules/tunnel-agent/index.js\");\nfunction _interopDefaultCompat(e) {\n    return e && typeof e == \"object\" && \"default\" in e ? e : {\n        default: e\n    };\n}\nfunction _interopNamespaceCompat(e) {\n    if (e && typeof e == \"object\" && \"default\" in e) return e;\n    var n = /* @__PURE__ */ Object.create(null);\n    return e && Object.keys(e).forEach(function(k) {\n        if (k !== \"default\") {\n            var d = Object.getOwnPropertyDescriptor(e, k);\n            Object.defineProperty(n, k, d.get ? d : {\n                enumerable: !0,\n                get: function() {\n                    return e[k];\n                }\n            });\n        }\n    }), n.default = e, Object.freeze(n);\n}\nvar decompressResponse__default = /* @__PURE__ */ _interopDefaultCompat(decompressResponse), follow__default = /* @__PURE__ */ _interopDefaultCompat(follow), http__default = /* @__PURE__ */ _interopDefaultCompat(http), https__default = /* @__PURE__ */ _interopDefaultCompat(https), toStream__default = /* @__PURE__ */ _interopDefaultCompat(toStream), isStream__default = /* @__PURE__ */ _interopDefaultCompat(isStream), progressStream__default = /* @__PURE__ */ _interopDefaultCompat(progressStream), qs__default = /* @__PURE__ */ _interopDefaultCompat(qs), url__default = /* @__PURE__ */ _interopDefaultCompat(url), tunnel__namespace = /* @__PURE__ */ _interopNamespaceCompat(tunnel);\nconst middlewareReducer = (middleware)=>function(hook, defaultValue, ...args) {\n        const bailEarly = hook === \"onError\";\n        let value = defaultValue;\n        for(let i = 0; i < middleware[hook].length; i++){\n            const handler = middleware[hook][i];\n            if (value = handler(value, ...args), bailEarly && !value) break;\n        }\n        return value;\n    };\nfunction createPubSub() {\n    const subscribers = /* @__PURE__ */ Object.create(null);\n    let nextId = 0;\n    function subscribe(subscriber) {\n        const id = nextId++;\n        return subscribers[id] = subscriber, function() {\n            delete subscribers[id];\n        };\n    }\n    function publish(event) {\n        for(const id in subscribers)subscribers[id](event);\n    }\n    return {\n        publish,\n        subscribe\n    };\n}\nconst channelNames = [\n    \"request\",\n    \"response\",\n    \"progress\",\n    \"error\",\n    \"abort\"\n], middlehooks = [\n    \"processOptions\",\n    \"validateOptions\",\n    \"interceptRequest\",\n    \"finalizeOptions\",\n    \"onRequest\",\n    \"onResponse\",\n    \"onError\",\n    \"onReturn\",\n    \"onHeaders\"\n];\nfunction createRequester(initMiddleware, httpRequest) {\n    const loadedMiddleware = [], middleware = middlehooks.reduce((ware, name)=>(ware[name] = ware[name] || [], ware), {\n        processOptions: [\n            defaultOptionsValidator.processOptions\n        ],\n        validateOptions: [\n            defaultOptionsValidator.validateOptions\n        ]\n    });\n    function request(opts) {\n        const onResponse = (reqErr, res, ctx)=>{\n            let error = reqErr, response = res;\n            if (!error) try {\n                response = applyMiddleware(\"onResponse\", res, ctx);\n            } catch (err) {\n                response = null, error = err;\n            }\n            error = error && applyMiddleware(\"onError\", error, ctx), error ? channels.error.publish(error) : response && channels.response.publish(response);\n        }, channels = channelNames.reduce((target, name)=>(target[name] = createPubSub(), target), {}), applyMiddleware = middlewareReducer(middleware), options = applyMiddleware(\"processOptions\", opts);\n        applyMiddleware(\"validateOptions\", options);\n        const context = {\n            options,\n            channels,\n            applyMiddleware\n        };\n        let ongoingRequest;\n        const unsubscribe = channels.request.subscribe((ctx)=>{\n            ongoingRequest = httpRequest(ctx, (err, res)=>onResponse(err, res, ctx));\n        });\n        channels.abort.subscribe(()=>{\n            unsubscribe(), ongoingRequest && ongoingRequest.abort();\n        });\n        const returnValue = applyMiddleware(\"onReturn\", channels, context);\n        return returnValue === channels && channels.request.publish(context), returnValue;\n    }\n    return request.use = function(newMiddleware) {\n        if (!newMiddleware) throw new Error(\"Tried to add middleware that resolved to falsey value\");\n        if (typeof newMiddleware == \"function\") throw new Error(\"Tried to add middleware that was a function. It probably expects you to pass options to it.\");\n        if (newMiddleware.onReturn && middleware.onReturn.length > 0) throw new Error(\"Tried to add new middleware with `onReturn` handler, but another handler has already been registered for this event\");\n        return middlehooks.forEach((key)=>{\n            newMiddleware[key] && middleware[key].push(newMiddleware[key]);\n        }), loadedMiddleware.push(newMiddleware), request;\n    }, request.clone = ()=>createRequester(loadedMiddleware, httpRequest), initMiddleware.forEach(request.use), request;\n}\nfunction lowerCaseHeaders(headers) {\n    return Object.keys(headers || {}).reduce((acc, header)=>(acc[header.toLowerCase()] = headers[header], acc), {});\n}\nfunction formatHostname(hostname) {\n    return hostname.replace(/^\\.*/, \".\").toLowerCase();\n}\nfunction parseNoProxyZone(zoneStr) {\n    const zone = zoneStr.trim().toLowerCase(), zoneParts = zone.split(\":\", 2), zoneHost = formatHostname(zoneParts[0]), zonePort = zoneParts[1], hasPort = zone.indexOf(\":\") > -1;\n    return {\n        hostname: zoneHost,\n        port: zonePort,\n        hasPort\n    };\n}\nfunction uriInNoProxy(uri, noProxy) {\n    const port = uri.port || (uri.protocol === \"https:\" ? \"443\" : \"80\"), hostname = formatHostname(uri.hostname);\n    return noProxy.split(\",\").map(parseNoProxyZone).some((noProxyZone)=>{\n        const isMatchedAt = hostname.indexOf(noProxyZone.hostname), hostnameMatched = isMatchedAt > -1 && isMatchedAt === hostname.length - noProxyZone.hostname.length;\n        return noProxyZone.hasPort ? port === noProxyZone.port && hostnameMatched : hostnameMatched;\n    });\n}\nfunction getProxyFromUri(uri) {\n    const noProxy = process.env.NO_PROXY || process.env.no_proxy || \"\";\n    return noProxy === \"*\" || noProxy !== \"\" && uriInNoProxy(uri, noProxy) ? null : uri.protocol === \"http:\" ? process.env.HTTP_PROXY || process.env.http_proxy || null : uri.protocol === \"https:\" && (process.env.HTTPS_PROXY || process.env.https_proxy || process.env.HTTP_PROXY || process.env.http_proxy) || null;\n}\nfunction getHostFromUri(uri) {\n    let host = uri.host;\n    return uri.port && (uri.port === \"80\" && uri.protocol === \"http:\" || uri.port === \"443\" && uri.protocol === \"https:\") && (host = uri.hostname), host;\n}\nfunction getHostHeaderWithPort(uri) {\n    const port = uri.port || (uri.protocol === \"https:\" ? \"443\" : \"80\");\n    return `${uri.hostname}:${port}`;\n}\nfunction rewriteUriForProxy(reqOpts, uri, proxy) {\n    const headers = reqOpts.headers || {}, options = Object.assign({}, reqOpts, {\n        headers\n    });\n    return headers.host = headers.host || getHostHeaderWithPort(uri), options.protocol = proxy.protocol || options.protocol, options.hostname = proxy.host.replace(/:\\d+/, \"\"), options.port = proxy.port, options.host = getHostFromUri(Object.assign({}, uri, proxy)), options.href = `${options.protocol}//${options.host}${options.path}`, options.path = url__default.default.format(uri), options;\n}\nfunction getProxyOptions(options) {\n    let proxy;\n    if (options.hasOwnProperty(\"proxy\")) proxy = options.proxy;\n    else {\n        const uri = url__default.default.parse(options.url);\n        proxy = getProxyFromUri(uri);\n    }\n    return typeof proxy == \"string\" ? url__default.default.parse(proxy) : proxy;\n}\n/*! simple-concat. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */ function concat(stream, cb) {\n    const chunks = [];\n    stream.on(\"data\", function(chunk) {\n        chunks.push(chunk);\n    }), stream.once(\"end\", function() {\n        cb && cb(null, Buffer.concat(chunks)), cb = null;\n    }), stream.once(\"error\", function(err) {\n        cb && cb(err), cb = null;\n    });\n}\nfunction timedOut(req, time) {\n    if (req.timeoutTimer) return req;\n    const delays = isNaN(time) ? time : {\n        socket: time,\n        connect: time\n    }, hostHeader = req.getHeader(\"host\"), host = hostHeader ? \" to \" + hostHeader : \"\";\n    delays.connect !== void 0 && (req.timeoutTimer = setTimeout(function() {\n        req.abort();\n        const e = new Error(\"Connection timed out on request\" + host);\n        e.code = \"ETIMEDOUT\", req.emit(\"error\", e);\n    }, delays.connect)), req.on(\"socket\", function(socket) {\n        if (!(socket.connecting || socket._connecting)) {\n            connect();\n            return;\n        }\n        socket.once(\"connect\", connect);\n    });\n    function clear() {\n        req.timeoutTimer && (clearTimeout(req.timeoutTimer), req.timeoutTimer = null);\n    }\n    function connect() {\n        clear(), delays.socket !== void 0 && req.setTimeout(delays.socket, function() {\n            req.abort();\n            const e = new Error(\"Socket timed out on request\" + host);\n            e.code = \"ESOCKETTIMEDOUT\", req.emit(\"error\", e);\n        });\n    }\n    return req.on(\"error\", clear);\n}\nconst uriParts = [\n    \"protocol\",\n    \"slashes\",\n    \"auth\",\n    \"host\",\n    \"port\",\n    \"hostname\",\n    \"hash\",\n    \"search\",\n    \"query\",\n    \"pathname\",\n    \"path\",\n    \"href\"\n], defaultProxyHeaderWhiteList = [\n    \"accept\",\n    \"accept-charset\",\n    \"accept-encoding\",\n    \"accept-language\",\n    \"accept-ranges\",\n    \"cache-control\",\n    \"content-encoding\",\n    \"content-language\",\n    \"content-location\",\n    \"content-md5\",\n    \"content-range\",\n    \"content-type\",\n    \"connection\",\n    \"date\",\n    \"expect\",\n    \"max-forwards\",\n    \"pragma\",\n    \"referer\",\n    \"te\",\n    \"user-agent\",\n    \"via\"\n], defaultProxyHeaderExclusiveList = [\n    \"proxy-authorization\"\n];\nfunction shouldEnable(options) {\n    return typeof options.tunnel < \"u\" ? !!options.tunnel : url__default.default.parse(options.url).protocol === \"https:\";\n}\nfunction applyAgent(opts = {}, proxy) {\n    const options = Object.assign({}, opts), proxyHeaderWhiteList = defaultProxyHeaderWhiteList.concat(options.proxyHeaderWhiteList || []).map((header)=>header.toLowerCase()), proxyHeaderExclusiveList = defaultProxyHeaderExclusiveList.concat(options.proxyHeaderExclusiveList || []).map((header)=>header.toLowerCase()), proxyHeaders = getAllowedProxyHeaders(options.headers, proxyHeaderWhiteList);\n    proxyHeaders.host = constructProxyHost(options), options.headers = Object.keys(options.headers || {}).reduce((headers, header)=>(proxyHeaderExclusiveList.indexOf(header.toLowerCase()) === -1 && (headers[header] = options.headers[header]), headers), {});\n    const tunnelFn = getTunnelFn(options, proxy), tunnelOptions = constructTunnelOptions(options, proxy, proxyHeaders);\n    return options.agent = tunnelFn(tunnelOptions), options;\n}\nfunction getTunnelFn(options, proxy) {\n    const uri = getUriParts(options), tunnelFnName = constructTunnelFnName(uri, proxy);\n    return tunnel__namespace[tunnelFnName];\n}\nfunction getUriParts(options) {\n    return uriParts.reduce((uri, part)=>(uri[part] = options[part], uri), {});\n}\nfunction constructTunnelFnName(uri, proxy) {\n    const uriProtocol = uri.protocol === \"https:\" ? \"https\" : \"http\", proxyProtocol = proxy.protocol === \"https:\" ? \"Https\" : \"Http\";\n    return `${uriProtocol}Over${proxyProtocol}`;\n}\nfunction constructProxyHost(uri) {\n    const port = uri.port, protocol = uri.protocol;\n    let proxyHost = `${uri.hostname}:`;\n    return port ? proxyHost += port : protocol === \"https:\" ? proxyHost += \"443\" : proxyHost += \"80\", proxyHost;\n}\nfunction getAllowedProxyHeaders(headers, whiteList) {\n    return Object.keys(headers).filter((header)=>whiteList.indexOf(header.toLowerCase()) !== -1).reduce((set, header)=>(set[header] = headers[header], set), {});\n}\nfunction constructTunnelOptions(options, proxy, proxyHeaders) {\n    return {\n        proxy: {\n            host: proxy.hostname,\n            port: +proxy.port,\n            proxyAuth: proxy.auth,\n            headers: proxyHeaders\n        },\n        headers: options.headers,\n        ca: options.ca,\n        cert: options.cert,\n        key: options.key,\n        passphrase: options.passphrase,\n        pfx: options.pfx,\n        ciphers: options.ciphers,\n        rejectUnauthorized: options.rejectUnauthorized,\n        secureOptions: options.secureOptions,\n        secureProtocol: options.secureProtocol\n    };\n}\nconst adapter = \"node\", reduceResponse = (res, reqUrl, method, body)=>({\n        body,\n        url: reqUrl,\n        method,\n        headers: res.headers,\n        statusCode: res.statusCode,\n        statusMessage: res.statusMessage\n    }), httpRequester = (context, cb)=>{\n    const { options } = context, uri = Object.assign({}, url__default.default.parse(options.url));\n    if (typeof fetch == \"function\" && options.fetch) {\n        const controller = new AbortController(), reqOpts2 = context.applyMiddleware(\"finalizeOptions\", {\n            ...uri,\n            method: options.method,\n            headers: {\n                ...typeof options.fetch == \"object\" && options.fetch.headers ? lowerCaseHeaders(options.fetch.headers) : {},\n                ...lowerCaseHeaders(options.headers)\n            },\n            maxRedirects: options.maxRedirects\n        }), fetchOpts = {\n            credentials: options.withCredentials ? \"include\" : \"omit\",\n            ...typeof options.fetch == \"object\" ? options.fetch : {},\n            method: reqOpts2.method,\n            headers: reqOpts2.headers,\n            body: options.body,\n            signal: controller.signal\n        }, injectedResponse2 = context.applyMiddleware(\"interceptRequest\", void 0, {\n            adapter,\n            context\n        });\n        if (injectedResponse2) {\n            const cbTimer = setTimeout(cb, 0, null, injectedResponse2);\n            return {\n                abort: ()=>clearTimeout(cbTimer)\n            };\n        }\n        const request2 = fetch(options.url, fetchOpts);\n        return context.applyMiddleware(\"onRequest\", {\n            options,\n            adapter,\n            request: request2,\n            context\n        }), request2.then(async (res)=>{\n            const body = options.rawBody ? res.body : await res.text(), headers = {};\n            res.headers.forEach((value, key)=>{\n                headers[key] = value;\n            }), cb(null, {\n                body,\n                url: res.url,\n                method: options.method,\n                headers,\n                statusCode: res.status,\n                statusMessage: res.statusText\n            });\n        }).catch((err)=>{\n            err.name != \"AbortError\" && cb(err);\n        }), {\n            abort: ()=>controller.abort()\n        };\n    }\n    const bodyType = isStream__default.default(options.body) ? \"stream\" : typeof options.body;\n    if (bodyType !== \"undefined\" && bodyType !== \"stream\" && bodyType !== \"string\" && !Buffer.isBuffer(options.body)) throw new Error(`Request body must be a string, buffer or stream, got ${bodyType}`);\n    const lengthHeader = {};\n    options.bodySize ? lengthHeader[\"content-length\"] = options.bodySize : options.body && bodyType !== \"stream\" && (lengthHeader[\"content-length\"] = Buffer.byteLength(options.body));\n    let aborted = !1;\n    const callback = (err, res)=>!aborted && cb(err, res);\n    context.channels.abort.subscribe(()=>{\n        aborted = !0;\n    });\n    let reqOpts = Object.assign({}, uri, {\n        method: options.method,\n        headers: Object.assign({}, lowerCaseHeaders(options.headers), lengthHeader),\n        maxRedirects: options.maxRedirects\n    });\n    const proxy = getProxyOptions(options), tunnel2 = proxy && shouldEnable(options), injectedResponse = context.applyMiddleware(\"interceptRequest\", void 0, {\n        adapter,\n        context\n    });\n    if (injectedResponse) {\n        const cbTimer = setImmediate(callback, null, injectedResponse);\n        return {\n            abort: ()=>clearImmediate(cbTimer)\n        };\n    }\n    if (options.maxRedirects !== 0 && (reqOpts.maxRedirects = options.maxRedirects || 5), proxy && tunnel2 ? reqOpts = applyAgent(reqOpts, proxy) : proxy && !tunnel2 && (reqOpts = rewriteUriForProxy(reqOpts, uri, proxy)), !tunnel2 && proxy && proxy.auth && !reqOpts.headers[\"proxy-authorization\"]) {\n        const [username, password] = proxy.auth.username ? [\n            proxy.auth.username,\n            proxy.auth.password\n        ] : proxy.auth.split(\":\").map((item)=>qs__default.default.unescape(item)), authBase64 = Buffer.from(`${username}:${password}`, \"utf8\").toString(\"base64\");\n        reqOpts.headers[\"proxy-authorization\"] = `Basic ${authBase64}`;\n    }\n    const transport = getRequestTransport(reqOpts, proxy, tunnel2);\n    typeof options.debug == \"function\" && proxy && options.debug(\"Proxying using %s\", reqOpts.agent ? \"tunnel agent\" : `${reqOpts.host}:${reqOpts.port}`);\n    const tryCompressed = reqOpts.method !== \"HEAD\";\n    tryCompressed && !reqOpts.headers[\"accept-encoding\"] && options.compress !== !1 && (reqOpts.headers[\"accept-encoding\"] = \"br, gzip, deflate\");\n    const finalOptions = context.applyMiddleware(\"finalizeOptions\", reqOpts), request = transport.request(finalOptions, (response)=>{\n        const res = tryCompressed ? decompressResponse__default.default(response) : response, resStream = context.applyMiddleware(\"onHeaders\", res, {\n            headers: response.headers,\n            adapter,\n            context\n        }), reqUrl = \"responseUrl\" in response ? response.responseUrl : options.url;\n        if (options.stream) {\n            callback(null, reduceResponse(res, reqUrl, reqOpts.method, resStream));\n            return;\n        }\n        concat(resStream, (err, data)=>{\n            if (err) return callback(err);\n            const body = options.rawBody ? data : data.toString(), reduced = reduceResponse(res, reqUrl, reqOpts.method, body);\n            return callback(null, reduced);\n        });\n    });\n    options.timeout && timedOut(request, options.timeout), request.once(\"error\", callback);\n    const { bodyStream, progress } = getProgressStream(options);\n    return context.applyMiddleware(\"onRequest\", {\n        options,\n        adapter,\n        request,\n        context,\n        progress\n    }), bodyStream ? bodyStream.pipe(request) : request.end(options.body), {\n        abort: ()=>request.abort()\n    };\n};\nfunction getProgressStream(options) {\n    if (!options.body) return {};\n    const bodyIsStream = isStream__default.default(options.body), length = options.bodySize || (bodyIsStream ? null : Buffer.byteLength(options.body));\n    if (!length) return bodyIsStream ? {\n        bodyStream: options.body\n    } : {};\n    const progress = progressStream__default.default({\n        time: 16,\n        length\n    });\n    return {\n        bodyStream: (bodyIsStream ? options.body : toStream__default.default(options.body)).pipe(progress),\n        progress\n    };\n}\nfunction getRequestTransport(reqOpts, proxy, tunnel2) {\n    const isHttpsRequest = reqOpts.protocol === \"https:\", transports = reqOpts.maxRedirects === 0 ? {\n        http: http__default.default,\n        https: https__default.default\n    } : {\n        http: follow__default.default.http,\n        https: follow__default.default.https\n    };\n    if (!proxy || tunnel2) return isHttpsRequest ? transports.https : transports.http;\n    let isHttpsProxy = proxy.port === 443;\n    return proxy.protocol && (isHttpsProxy = /^https:?/.test(proxy.protocol)), isHttpsProxy ? transports.https : transports.http;\n}\nconst getIt = (initMiddleware = [], httpRequest = httpRequester)=>createRequester(initMiddleware, httpRequest), environment = \"node\";\nexports.adapter = adapter;\nexports.environment = environment;\nexports.getIt = getIt; //# sourceMappingURL=index.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ2V0LWl0L2Rpc3QvaW5kZXguY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPLENBQUM7QUFBRSxDQUFDLEVBQUM7QUFDM0QsSUFBSUMsMEJBQTBCQyxtQkFBT0EsQ0FBQyxxSUFBZ0QsR0FBR0MscUJBQXFCRCxtQkFBT0EsQ0FBQyw4RUFBcUIsR0FBR0UsU0FBU0YsbUJBQU9BLENBQUMsd0VBQWtCLEdBQUdHLE9BQU9ILG1CQUFPQSxDQUFDLGtCQUFNLEdBQUdJLFFBQVFKLG1CQUFPQSxDQUFDLG9CQUFPLEdBQUdLLFdBQVdMLG1CQUFPQSxDQUFDLDhEQUFhLEdBQUdNLFdBQVdOLG1CQUFPQSxDQUFDLDhFQUFXLEdBQUdPLGlCQUFpQlAsbUJBQU9BLENBQUMsc0VBQWlCLEdBQUdRLEtBQUtSLG1CQUFPQSxDQUFDLGdDQUFhLEdBQUdTLE1BQU1ULG1CQUFPQSxDQUFDLGdCQUFLLEdBQUdVLFNBQVNWLG1CQUFPQSxDQUFDLGdFQUFjO0FBQ3phLFNBQVNXLHNCQUFzQkMsQ0FBQztJQUM5QixPQUFPQSxLQUFLLE9BQU9BLEtBQUssWUFBWSxhQUFhQSxJQUFJQSxJQUFJO1FBQUVDLFNBQVNEO0lBQUU7QUFDeEU7QUFDQSxTQUFTRSx3QkFBd0JGLENBQUM7SUFDaEMsSUFBSUEsS0FBSyxPQUFPQSxLQUFLLFlBQVksYUFBYUEsR0FDNUMsT0FBT0E7SUFDVCxJQUFJRyxJQUFJLGFBQWEsR0FBR3BCLE9BQU9xQixNQUFNLENBQUM7SUFDdEMsT0FBT0osS0FBS2pCLE9BQU9zQixJQUFJLENBQUNMLEdBQUdNLE9BQU8sQ0FBQyxTQUFTQyxDQUFDO1FBQzNDLElBQUlBLE1BQU0sV0FBVztZQUNuQixJQUFJQyxJQUFJekIsT0FBTzBCLHdCQUF3QixDQUFDVCxHQUFHTztZQUMzQ3hCLE9BQU9DLGNBQWMsQ0FBQ21CLEdBQUdJLEdBQUdDLEVBQUVFLEdBQUcsR0FBR0YsSUFBSTtnQkFDdENHLFlBQVksQ0FBQztn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QUksQ0FBQ3BJLE1BQU1wQixRQUFRLElBQUl1SixlQUFlRCxXQUFXaFEsS0FBSyxHQUFHZ1EsV0FBV2pRLElBQUk7QUFDOUg7QUFDQSxNQUFNb1EsUUFBUSxDQUFDaE4saUJBQWlCLEVBQUUsRUFBRUMsY0FBY3FKLGFBQWEsR0FBS3ZKLGdCQUFnQkMsZ0JBQWdCQyxjQUFjZ04sY0FBYztBQUNoSTNRLGVBQWUsR0FBR3lNO0FBQ2xCek0sbUJBQW1CLEdBQUcyUTtBQUN0QjNRLGFBQWEsR0FBRzBRLE9BQ2hCLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL29saS1jcm9zc2xhbmQtdmlkZW9ncmFwaHkvLi9ub2RlX21vZHVsZXMvZ2V0LWl0L2Rpc3QvaW5kZXguY2pzPzI5YTYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pO1xudmFyIGRlZmF1bHRPcHRpb25zVmFsaWRhdG9yID0gcmVxdWlyZShcIi4vX2NodW5rcy9kZWZhdWx0T3B0aW9uc1ZhbGlkYXRvci1DWHdyTmptZS5janNcIiksIGRlY29tcHJlc3NSZXNwb25zZSA9IHJlcXVpcmUoXCJkZWNvbXByZXNzLXJlc3BvbnNlXCIpLCBmb2xsb3cgPSByZXF1aXJlKFwiZm9sbG93LXJlZGlyZWN0c1wiKSwgaHR0cCA9IHJlcXVpcmUoXCJodHRwXCIpLCBodHRwcyA9IHJlcXVpcmUoXCJodHRwc1wiKSwgdG9TdHJlYW0gPSByZXF1aXJlKFwiaW50by1zdHJlYW1cIiksIGlzU3RyZWFtID0gcmVxdWlyZShcImlzLXN0cmVhbVwiKSwgcHJvZ3Jlc3NTdHJlYW0gPSByZXF1aXJlKFwicHJvZ3Jlc3Mtc3RyZWFtXCIpLCBxcyA9IHJlcXVpcmUoXCJxdWVyeXN0cmluZ1wiKSwgdXJsID0gcmVxdWlyZShcInVybFwiKSwgdHVubmVsID0gcmVxdWlyZShcInR1bm5lbC1hZ2VudFwiKTtcbmZ1bmN0aW9uIF9pbnRlcm9wRGVmYXVsdENvbXBhdChlKSB7XG4gIHJldHVybiBlICYmIHR5cGVvZiBlID09IFwib2JqZWN0XCIgJiYgXCJkZWZhdWx0XCIgaW4gZSA/IGUgOiB7IGRlZmF1bHQ6IGUgfTtcbn1cbmZ1bmN0aW9uIF9pbnRlcm9wTmFtZXNwYWNlQ29tcGF0KGUpIHtcbiAgaWYgKGUgJiYgdHlwZW9mIGUgPT0gXCJvYmplY3RcIiAmJiBcImRlZmF1bHRcIiBpbiBlKVxuICAgIHJldHVybiBlO1xuICB2YXIgbiA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICByZXR1cm4gZSAmJiBPYmplY3Qua2V5cyhlKS5mb3JFYWNoKGZ1bmN0aW9uKGspIHtcbiAgICBpZiAoayAhPT0gXCJkZWZhdWx0XCIpIHtcbiAgICAgIHZhciBkID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCBrKTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCBrLCBkLmdldCA/IGQgOiB7XG4gICAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBlW2tdO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0pLCBuLmRlZmF1bHQgPSBlLCBPYmplY3QuZnJlZXplKG4pO1xufVxudmFyIGRlY29tcHJlc3NSZXNwb25zZV9fZGVmYXVsdCA9IC8qIEBfX1BVUkVfXyAqLyBfaW50ZXJvcERlZmF1bHRDb21wYXQoZGVjb21wcmVzc1Jlc3BvbnNlKSwgZm9sbG93X19kZWZhdWx0ID0gLyogQF9fUFVSRV9fICovIF9pbnRlcm9wRGVmYXVsdENvbXBhdChmb2xsb3cpLCBodHRwX19kZWZhdWx0ID0gLyogQF9fUFVSRV9fICovIF9pbnRlcm9wRGVmYXVsdENvbXBhdChodHRwKSwgaHR0cHNfX2RlZmF1bHQgPSAvKiBAX19QVVJFX18gKi8gX2ludGVyb3BEZWZhdWx0Q29tcGF0KGh0dHBzKSwgdG9TdHJlYW1fX2RlZmF1bHQgPSAvKiBAX19QVVJFX18gKi8gX2ludGVyb3BEZWZhdWx0Q29tcGF0KHRvU3RyZWFtKSwgaXNTdHJlYW1fX2RlZmF1bHQgPSAvKiBAX19QVVJFX18gKi8gX2ludGVyb3BEZWZhdWx0Q29tcGF0KGlzU3RyZWFtKSwgcHJvZ3Jlc3NTdHJlYW1fX2RlZmF1bHQgPSAvKiBAX19QVVJFX18gKi8gX2ludGVyb3BEZWZhdWx0Q29tcGF0KHByb2dyZXNzU3RyZWFtKSwgcXNfX2RlZmF1bHQgPSAvKiBAX19QVVJFX18gKi8gX2ludGVyb3BEZWZhdWx0Q29tcGF0KHFzKSwgdXJsX19kZWZhdWx0ID0gLyogQF9fUFVSRV9fICovIF9pbnRlcm9wRGVmYXVsdENvbXBhdCh1cmwpLCB0dW5uZWxfX25hbWVzcGFjZSA9IC8qIEBfX1BVUkVfXyAqLyBfaW50ZXJvcE5hbWVzcGFjZUNvbXBhdCh0dW5uZWwpO1xuY29uc3QgbWlkZGxld2FyZVJlZHVjZXIgPSAobWlkZGxld2FyZSkgPT4gZnVuY3Rpb24oaG9vaywgZGVmYXVsdFZhbHVlLCAuLi5hcmdzKSB7XG4gIGNvbnN0IGJhaWxFYXJseSA9IGhvb2sgPT09IFwib25FcnJvclwiO1xuICBsZXQgdmFsdWUgPSBkZWZhdWx0VmFsdWU7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbWlkZGxld2FyZVtob29rXS5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGhhbmRsZXIgPSBtaWRkbGV3YXJlW2hvb2tdW2ldO1xuICAgIGlmICh2YWx1ZSA9IGhhbmRsZXIodmFsdWUsIC4uLmFyZ3MpLCBiYWlsRWFybHkgJiYgIXZhbHVlKVxuICAgICAgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufTtcbmZ1bmN0aW9uIGNyZWF0ZVB1YlN1YigpIHtcbiAgY29uc3Qgc3Vic2NyaWJlcnMgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgbGV0IG5leHRJZCA9IDA7XG4gIGZ1bmN0aW9uIHN1YnNjcmliZShzdWJzY3JpYmVyKSB7XG4gICAgY29uc3QgaWQgPSBuZXh0SWQrKztcbiAgICByZXR1cm4gc3Vic2NyaWJlcnNbaWRdID0gc3Vic2NyaWJlciwgZnVuY3Rpb24oKSB7XG4gICAgICBkZWxldGUgc3Vic2NyaWJlcnNbaWRdO1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gcHVibGlzaChldmVudCkge1xuICAgIGZvciAoY29uc3QgaWQgaW4gc3Vic2NyaWJlcnMpXG4gICAgICBzdWJzY3JpYmVyc1tpZF0oZXZlbnQpO1xuICB9XG4gIHJldHVybiB7XG4gICAgcHVibGlzaCxcbiAgICBzdWJzY3JpYmVcbiAgfTtcbn1cbmNvbnN0IGNoYW5uZWxOYW1lcyA9IFtcbiAgXCJyZXF1ZXN0XCIsXG4gIFwicmVzcG9uc2VcIixcbiAgXCJwcm9ncmVzc1wiLFxuICBcImVycm9yXCIsXG4gIFwiYWJvcnRcIlxuXSwgbWlkZGxlaG9va3MgPSBbXG4gIFwicHJvY2Vzc09wdGlvbnNcIixcbiAgXCJ2YWxpZGF0ZU9wdGlvbnNcIixcbiAgXCJpbnRlcmNlcHRSZXF1ZXN0XCIsXG4gIFwiZmluYWxpemVPcHRpb25zXCIsXG4gIFwib25SZXF1ZXN0XCIsXG4gIFwib25SZXNwb25zZVwiLFxuICBcIm9uRXJyb3JcIixcbiAgXCJvblJldHVyblwiLFxuICBcIm9uSGVhZGVyc1wiXG5dO1xuZnVuY3Rpb24gY3JlYXRlUmVxdWVzdGVyKGluaXRNaWRkbGV3YXJlLCBodHRwUmVxdWVzdCkge1xuICBjb25zdCBsb2FkZWRNaWRkbGV3YXJlID0gW10sIG1pZGRsZXdhcmUgPSBtaWRkbGVob29rcy5yZWR1Y2UoXG4gICAgKHdhcmUsIG5hbWUpID0+ICh3YXJlW25hbWVdID0gd2FyZVtuYW1lXSB8fCBbXSwgd2FyZSksXG4gICAge1xuICAgICAgcHJvY2Vzc09wdGlvbnM6IFtkZWZhdWx0T3B0aW9uc1ZhbGlkYXRvci5wcm9jZXNzT3B0aW9uc10sXG4gICAgICB2YWxpZGF0ZU9wdGlvbnM6IFtkZWZhdWx0T3B0aW9uc1ZhbGlkYXRvci52YWxpZGF0ZU9wdGlvbnNdXG4gICAgfVxuICApO1xuICBmdW5jdGlvbiByZXF1ZXN0KG9wdHMpIHtcbiAgICBjb25zdCBvblJlc3BvbnNlID0gKHJlcUVyciwgcmVzLCBjdHgpID0+IHtcbiAgICAgIGxldCBlcnJvciA9IHJlcUVyciwgcmVzcG9uc2UgPSByZXM7XG4gICAgICBpZiAoIWVycm9yKVxuICAgICAgICB0cnkge1xuICAgICAgICAgIHJlc3BvbnNlID0gYXBwbHlNaWRkbGV3YXJlKFwib25SZXNwb25zZVwiLCByZXMsIGN0eCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIHJlc3BvbnNlID0gbnVsbCwgZXJyb3IgPSBlcnI7XG4gICAgICAgIH1cbiAgICAgIGVycm9yID0gZXJyb3IgJiYgYXBwbHlNaWRkbGV3YXJlKFwib25FcnJvclwiLCBlcnJvciwgY3R4KSwgZXJyb3IgPyBjaGFubmVscy5lcnJvci5wdWJsaXNoKGVycm9yKSA6IHJlc3BvbnNlICYmIGNoYW5uZWxzLnJlc3BvbnNlLnB1Ymxpc2gocmVzcG9uc2UpO1xuICAgIH0sIGNoYW5uZWxzID0gY2hhbm5lbE5hbWVzLnJlZHVjZSgodGFyZ2V0LCBuYW1lKSA9PiAodGFyZ2V0W25hbWVdID0gY3JlYXRlUHViU3ViKCksIHRhcmdldCksIHt9KSwgYXBwbHlNaWRkbGV3YXJlID0gbWlkZGxld2FyZVJlZHVjZXIobWlkZGxld2FyZSksIG9wdGlvbnMgPSBhcHBseU1pZGRsZXdhcmUoXCJwcm9jZXNzT3B0aW9uc1wiLCBvcHRzKTtcbiAgICBhcHBseU1pZGRsZXdhcmUoXCJ2YWxpZGF0ZU9wdGlvbnNcIiwgb3B0aW9ucyk7XG4gICAgY29uc3QgY29udGV4dCA9IHsgb3B0aW9ucywgY2hhbm5lbHMsIGFwcGx5TWlkZGxld2FyZSB9O1xuICAgIGxldCBvbmdvaW5nUmVxdWVzdDtcbiAgICBjb25zdCB1bnN1YnNjcmliZSA9IGNoYW5uZWxzLnJlcXVlc3Quc3Vic2NyaWJlKChjdHgpID0+IHtcbiAgICAgIG9uZ29pbmdSZXF1ZXN0ID0gaHR0cFJlcXVlc3QoY3R4LCAoZXJyLCByZXMpID0+IG9uUmVzcG9uc2UoZXJyLCByZXMsIGN0eCkpO1xuICAgIH0pO1xuICAgIGNoYW5uZWxzLmFib3J0LnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICB1bnN1YnNjcmliZSgpLCBvbmdvaW5nUmVxdWVzdCAmJiBvbmdvaW5nUmVxdWVzdC5hYm9ydCgpO1xuICAgIH0pO1xuICAgIGNvbnN0IHJldHVyblZhbHVlID0gYXBwbHlNaWRkbGV3YXJlKFwib25SZXR1cm5cIiwgY2hhbm5lbHMsIGNvbnRleHQpO1xuICAgIHJldHVybiByZXR1cm5WYWx1ZSA9PT0gY2hhbm5lbHMgJiYgY2hhbm5lbHMucmVxdWVzdC5wdWJsaXNoKGNvbnRleHQpLCByZXR1cm5WYWx1ZTtcbiAgfVxuICByZXR1cm4gcmVxdWVzdC51c2UgPSBmdW5jdGlvbihuZXdNaWRkbGV3YXJlKSB7XG4gICAgaWYgKCFuZXdNaWRkbGV3YXJlKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVHJpZWQgdG8gYWRkIG1pZGRsZXdhcmUgdGhhdCByZXNvbHZlZCB0byBmYWxzZXkgdmFsdWVcIik7XG4gICAgaWYgKHR5cGVvZiBuZXdNaWRkbGV3YXJlID09IFwiZnVuY3Rpb25cIilcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJUcmllZCB0byBhZGQgbWlkZGxld2FyZSB0aGF0IHdhcyBhIGZ1bmN0aW9uLiBJdCBwcm9iYWJseSBleHBlY3RzIHlvdSB0byBwYXNzIG9wdGlvbnMgdG8gaXQuXCJcbiAgICAgICk7XG4gICAgaWYgKG5ld01pZGRsZXdhcmUub25SZXR1cm4gJiYgbWlkZGxld2FyZS5vblJldHVybi5sZW5ndGggPiAwKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIlRyaWVkIHRvIGFkZCBuZXcgbWlkZGxld2FyZSB3aXRoIGBvblJldHVybmAgaGFuZGxlciwgYnV0IGFub3RoZXIgaGFuZGxlciBoYXMgYWxyZWFkeSBiZWVuIHJlZ2lzdGVyZWQgZm9yIHRoaXMgZXZlbnRcIlxuICAgICAgKTtcbiAgICByZXR1cm4gbWlkZGxlaG9va3MuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICBuZXdNaWRkbGV3YXJlW2tleV0gJiYgbWlkZGxld2FyZVtrZXldLnB1c2gobmV3TWlkZGxld2FyZVtrZXldKTtcbiAgICB9KSwgbG9hZGVkTWlkZGxld2FyZS5wdXNoKG5ld01pZGRsZXdhcmUpLCByZXF1ZXN0O1xuICB9LCByZXF1ZXN0LmNsb25lID0gKCkgPT4gY3JlYXRlUmVxdWVzdGVyKGxvYWRlZE1pZGRsZXdhcmUsIGh0dHBSZXF1ZXN0KSwgaW5pdE1pZGRsZXdhcmUuZm9yRWFjaChyZXF1ZXN0LnVzZSksIHJlcXVlc3Q7XG59XG5mdW5jdGlvbiBsb3dlckNhc2VIZWFkZXJzKGhlYWRlcnMpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKGhlYWRlcnMgfHwge30pLnJlZHVjZSgoYWNjLCBoZWFkZXIpID0+IChhY2NbaGVhZGVyLnRvTG93ZXJDYXNlKCldID0gaGVhZGVyc1toZWFkZXJdLCBhY2MpLCB7fSk7XG59XG5mdW5jdGlvbiBmb3JtYXRIb3N0bmFtZShob3N0bmFtZSkge1xuICByZXR1cm4gaG9zdG5hbWUucmVwbGFjZSgvXlxcLiovLCBcIi5cIikudG9Mb3dlckNhc2UoKTtcbn1cbmZ1bmN0aW9uIHBhcnNlTm9Qcm94eVpvbmUoem9uZVN0cikge1xuICBjb25zdCB6b25lID0gem9uZVN0ci50cmltKCkudG9Mb3dlckNhc2UoKSwgem9uZVBhcnRzID0gem9uZS5zcGxpdChcIjpcIiwgMiksIHpvbmVIb3N0ID0gZm9ybWF0SG9zdG5hbWUoem9uZVBhcnRzWzBdKSwgem9uZVBvcnQgPSB6b25lUGFydHNbMV0sIGhhc1BvcnQgPSB6b25lLmluZGV4T2YoXCI6XCIpID4gLTE7XG4gIHJldHVybiB7IGhvc3RuYW1lOiB6b25lSG9zdCwgcG9ydDogem9uZVBvcnQsIGhhc1BvcnQgfTtcbn1cbmZ1bmN0aW9uIHVyaUluTm9Qcm94eSh1cmksIG5vUHJveHkpIHtcbiAgY29uc3QgcG9ydCA9IHVyaS5wb3J0IHx8ICh1cmkucHJvdG9jb2wgPT09IFwiaHR0cHM6XCIgPyBcIjQ0M1wiIDogXCI4MFwiKSwgaG9zdG5hbWUgPSBmb3JtYXRIb3N0bmFtZSh1cmkuaG9zdG5hbWUpO1xuICByZXR1cm4gbm9Qcm94eS5zcGxpdChcIixcIikubWFwKHBhcnNlTm9Qcm94eVpvbmUpLnNvbWUoKG5vUHJveHlab25lKSA9PiB7XG4gICAgY29uc3QgaXNNYXRjaGVkQXQgPSBob3N0bmFtZS5pbmRleE9mKG5vUHJveHlab25lLmhvc3RuYW1lKSwgaG9zdG5hbWVNYXRjaGVkID0gaXNNYXRjaGVkQXQgPiAtMSAmJiBpc01hdGNoZWRBdCA9PT0gaG9zdG5hbWUubGVuZ3RoIC0gbm9Qcm94eVpvbmUuaG9zdG5hbWUubGVuZ3RoO1xuICAgIHJldHVybiBub1Byb3h5Wm9uZS5oYXNQb3J0ID8gcG9ydCA9PT0gbm9Qcm94eVpvbmUucG9ydCAmJiBob3N0bmFtZU1hdGNoZWQgOiBob3N0bmFtZU1hdGNoZWQ7XG4gIH0pO1xufVxuZnVuY3Rpb24gZ2V0UHJveHlGcm9tVXJpKHVyaSkge1xuICBjb25zdCBub1Byb3h5ID0gcHJvY2Vzcy5lbnYuTk9fUFJPWFkgfHwgcHJvY2Vzcy5lbnYubm9fcHJveHkgfHwgXCJcIjtcbiAgcmV0dXJuIG5vUHJveHkgPT09IFwiKlwiIHx8IG5vUHJveHkgIT09IFwiXCIgJiYgdXJpSW5Ob1Byb3h5KHVyaSwgbm9Qcm94eSkgPyBudWxsIDogdXJpLnByb3RvY29sID09PSBcImh0dHA6XCIgPyBwcm9jZXNzLmVudi5IVFRQX1BST1hZIHx8IHByb2Nlc3MuZW52Lmh0dHBfcHJveHkgfHwgbnVsbCA6IHVyaS5wcm90b2NvbCA9PT0gXCJodHRwczpcIiAmJiAocHJvY2Vzcy5lbnYuSFRUUFNfUFJPWFkgfHwgcHJvY2Vzcy5lbnYuaHR0cHNfcHJveHkgfHwgcHJvY2Vzcy5lbnYuSFRUUF9QUk9YWSB8fCBwcm9jZXNzLmVudi5odHRwX3Byb3h5KSB8fCBudWxsO1xufVxuZnVuY3Rpb24gZ2V0SG9zdEZyb21VcmkodXJpKSB7XG4gIGxldCBob3N0ID0gdXJpLmhvc3Q7XG4gIHJldHVybiB1cmkucG9ydCAmJiAodXJpLnBvcnQgPT09IFwiODBcIiAmJiB1cmkucHJvdG9jb2wgPT09IFwiaHR0cDpcIiB8fCB1cmkucG9ydCA9PT0gXCI0NDNcIiAmJiB1cmkucHJvdG9jb2wgPT09IFwiaHR0cHM6XCIpICYmIChob3N0ID0gdXJpLmhvc3RuYW1lKSwgaG9zdDtcbn1cbmZ1bmN0aW9uIGdldEhvc3RIZWFkZXJXaXRoUG9ydCh1cmkpIHtcbiAgY29uc3QgcG9ydCA9IHVyaS5wb3J0IHx8ICh1cmkucHJvdG9jb2wgPT09IFwiaHR0cHM6XCIgPyBcIjQ0M1wiIDogXCI4MFwiKTtcbiAgcmV0dXJuIGAke3VyaS5ob3N0bmFtZX06JHtwb3J0fWA7XG59XG5mdW5jdGlvbiByZXdyaXRlVXJpRm9yUHJveHkocmVxT3B0cywgdXJpLCBwcm94eSkge1xuICBjb25zdCBoZWFkZXJzID0gcmVxT3B0cy5oZWFkZXJzIHx8IHt9LCBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgcmVxT3B0cywgeyBoZWFkZXJzIH0pO1xuICByZXR1cm4gaGVhZGVycy5ob3N0ID0gaGVhZGVycy5ob3N0IHx8IGdldEhvc3RIZWFkZXJXaXRoUG9ydCh1cmkpLCBvcHRpb25zLnByb3RvY29sID0gcHJveHkucHJvdG9jb2wgfHwgb3B0aW9ucy5wcm90b2NvbCwgb3B0aW9ucy5ob3N0bmFtZSA9IHByb3h5Lmhvc3QucmVwbGFjZSgvOlxcZCsvLCBcIlwiKSwgb3B0aW9ucy5wb3J0ID0gcHJveHkucG9ydCwgb3B0aW9ucy5ob3N0ID0gZ2V0SG9zdEZyb21VcmkoT2JqZWN0LmFzc2lnbih7fSwgdXJpLCBwcm94eSkpLCBvcHRpb25zLmhyZWYgPSBgJHtvcHRpb25zLnByb3RvY29sfS8vJHtvcHRpb25zLmhvc3R9JHtvcHRpb25zLnBhdGh9YCwgb3B0aW9ucy5wYXRoID0gdXJsX19kZWZhdWx0LmRlZmF1bHQuZm9ybWF0KHVyaSksIG9wdGlvbnM7XG59XG5mdW5jdGlvbiBnZXRQcm94eU9wdGlvbnMob3B0aW9ucykge1xuICBsZXQgcHJveHk7XG4gIGlmIChvcHRpb25zLmhhc093blByb3BlcnR5KFwicHJveHlcIikpXG4gICAgcHJveHkgPSBvcHRpb25zLnByb3h5O1xuICBlbHNlIHtcbiAgICBjb25zdCB1cmkgPSB1cmxfX2RlZmF1bHQuZGVmYXVsdC5wYXJzZShvcHRpb25zLnVybCk7XG4gICAgcHJveHkgPSBnZXRQcm94eUZyb21VcmkodXJpKTtcbiAgfVxuICByZXR1cm4gdHlwZW9mIHByb3h5ID09IFwic3RyaW5nXCIgPyB1cmxfX2RlZmF1bHQuZGVmYXVsdC5wYXJzZShwcm94eSkgOiBwcm94eTtcbn1cbi8qISBzaW1wbGUtY29uY2F0LiBNSVQgTGljZW5zZS4gRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnL29wZW5zb3VyY2U+ICovXG5mdW5jdGlvbiBjb25jYXQoc3RyZWFtLCBjYikge1xuICBjb25zdCBjaHVua3MgPSBbXTtcbiAgc3RyZWFtLm9uKFwiZGF0YVwiLCBmdW5jdGlvbihjaHVuaykge1xuICAgIGNodW5rcy5wdXNoKGNodW5rKTtcbiAgfSksIHN0cmVhbS5vbmNlKFwiZW5kXCIsIGZ1bmN0aW9uKCkge1xuICAgIGNiICYmIGNiKG51bGwsIEJ1ZmZlci5jb25jYXQoY2h1bmtzKSksIGNiID0gbnVsbDtcbiAgfSksIHN0cmVhbS5vbmNlKFwiZXJyb3JcIiwgZnVuY3Rpb24oZXJyKSB7XG4gICAgY2IgJiYgY2IoZXJyKSwgY2IgPSBudWxsO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHRpbWVkT3V0KHJlcSwgdGltZSkge1xuICBpZiAocmVxLnRpbWVvdXRUaW1lcilcbiAgICByZXR1cm4gcmVxO1xuICBjb25zdCBkZWxheXMgPSBpc05hTih0aW1lKSA/IHRpbWUgOiB7IHNvY2tldDogdGltZSwgY29ubmVjdDogdGltZSB9LCBob3N0SGVhZGVyID0gcmVxLmdldEhlYWRlcihcImhvc3RcIiksIGhvc3QgPSBob3N0SGVhZGVyID8gXCIgdG8gXCIgKyBob3N0SGVhZGVyIDogXCJcIjtcbiAgZGVsYXlzLmNvbm5lY3QgIT09IHZvaWQgMCAmJiAocmVxLnRpbWVvdXRUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgcmVxLmFib3J0KCk7XG4gICAgY29uc3QgZSA9IG5ldyBFcnJvcihcIkNvbm5lY3Rpb24gdGltZWQgb3V0IG9uIHJlcXVlc3RcIiArIGhvc3QpO1xuICAgIGUuY29kZSA9IFwiRVRJTUVET1VUXCIsIHJlcS5lbWl0KFwiZXJyb3JcIiwgZSk7XG4gIH0sIGRlbGF5cy5jb25uZWN0KSksIHJlcS5vbihcInNvY2tldFwiLCBmdW5jdGlvbihzb2NrZXQpIHtcbiAgICBpZiAoIShzb2NrZXQuY29ubmVjdGluZyB8fCBzb2NrZXQuX2Nvbm5lY3RpbmcpKSB7XG4gICAgICBjb25uZWN0KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHNvY2tldC5vbmNlKFwiY29ubmVjdFwiLCBjb25uZWN0KTtcbiAgfSk7XG4gIGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgIHJlcS50aW1lb3V0VGltZXIgJiYgKGNsZWFyVGltZW91dChyZXEudGltZW91dFRpbWVyKSwgcmVxLnRpbWVvdXRUaW1lciA9IG51bGwpO1xuICB9XG4gIGZ1bmN0aW9uIGNvbm5lY3QoKSB7XG4gICAgY2xlYXIoKSwgZGVsYXlzLnNvY2tldCAhPT0gdm9pZCAwICYmIHJlcS5zZXRUaW1lb3V0KGRlbGF5cy5zb2NrZXQsIGZ1bmN0aW9uKCkge1xuICAgICAgcmVxLmFib3J0KCk7XG4gICAgICBjb25zdCBlID0gbmV3IEVycm9yKFwiU29ja2V0IHRpbWVkIG91dCBvbiByZXF1ZXN0XCIgKyBob3N0KTtcbiAgICAgIGUuY29kZSA9IFwiRVNPQ0tFVFRJTUVET1VUXCIsIHJlcS5lbWl0KFwiZXJyb3JcIiwgZSk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHJlcS5vbihcImVycm9yXCIsIGNsZWFyKTtcbn1cbmNvbnN0IHVyaVBhcnRzID0gW1xuICBcInByb3RvY29sXCIsXG4gIFwic2xhc2hlc1wiLFxuICBcImF1dGhcIixcbiAgXCJob3N0XCIsXG4gIFwicG9ydFwiLFxuICBcImhvc3RuYW1lXCIsXG4gIFwiaGFzaFwiLFxuICBcInNlYXJjaFwiLFxuICBcInF1ZXJ5XCIsXG4gIFwicGF0aG5hbWVcIixcbiAgXCJwYXRoXCIsXG4gIFwiaHJlZlwiXG5dLCBkZWZhdWx0UHJveHlIZWFkZXJXaGl0ZUxpc3QgPSBbXG4gIFwiYWNjZXB0XCIsXG4gIFwiYWNjZXB0LWNoYXJzZXRcIixcbiAgXCJhY2NlcHQtZW5jb2RpbmdcIixcbiAgXCJhY2NlcHQtbGFuZ3VhZ2VcIixcbiAgXCJhY2NlcHQtcmFuZ2VzXCIsXG4gIFwiY2FjaGUtY29udHJvbFwiLFxuICBcImNvbnRlbnQtZW5jb2RpbmdcIixcbiAgXCJjb250ZW50LWxhbmd1YWdlXCIsXG4gIFwiY29udGVudC1sb2NhdGlvblwiLFxuICBcImNvbnRlbnQtbWQ1XCIsXG4gIFwiY29udGVudC1yYW5nZVwiLFxuICBcImNvbnRlbnQtdHlwZVwiLFxuICBcImNvbm5lY3Rpb25cIixcbiAgXCJkYXRlXCIsXG4gIFwiZXhwZWN0XCIsXG4gIFwibWF4LWZvcndhcmRzXCIsXG4gIFwicHJhZ21hXCIsXG4gIFwicmVmZXJlclwiLFxuICBcInRlXCIsXG4gIFwidXNlci1hZ2VudFwiLFxuICBcInZpYVwiXG5dLCBkZWZhdWx0UHJveHlIZWFkZXJFeGNsdXNpdmVMaXN0ID0gW1wicHJveHktYXV0aG9yaXphdGlvblwiXTtcbmZ1bmN0aW9uIHNob3VsZEVuYWJsZShvcHRpb25zKSB7XG4gIHJldHVybiB0eXBlb2Ygb3B0aW9ucy50dW5uZWwgPCBcInVcIiA/ICEhb3B0aW9ucy50dW5uZWwgOiB1cmxfX2RlZmF1bHQuZGVmYXVsdC5wYXJzZShvcHRpb25zLnVybCkucHJvdG9jb2wgPT09IFwiaHR0cHM6XCI7XG59XG5mdW5jdGlvbiBhcHBseUFnZW50KG9wdHMgPSB7fSwgcHJveHkpIHtcbiAgY29uc3Qgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdHMpLCBwcm94eUhlYWRlcldoaXRlTGlzdCA9IGRlZmF1bHRQcm94eUhlYWRlcldoaXRlTGlzdC5jb25jYXQob3B0aW9ucy5wcm94eUhlYWRlcldoaXRlTGlzdCB8fCBbXSkubWFwKChoZWFkZXIpID0+IGhlYWRlci50b0xvd2VyQ2FzZSgpKSwgcHJveHlIZWFkZXJFeGNsdXNpdmVMaXN0ID0gZGVmYXVsdFByb3h5SGVhZGVyRXhjbHVzaXZlTGlzdC5jb25jYXQob3B0aW9ucy5wcm94eUhlYWRlckV4Y2x1c2l2ZUxpc3QgfHwgW10pLm1hcCgoaGVhZGVyKSA9PiBoZWFkZXIudG9Mb3dlckNhc2UoKSksIHByb3h5SGVhZGVycyA9IGdldEFsbG93ZWRQcm94eUhlYWRlcnMob3B0aW9ucy5oZWFkZXJzLCBwcm94eUhlYWRlcldoaXRlTGlzdCk7XG4gIHByb3h5SGVhZGVycy5ob3N0ID0gY29uc3RydWN0UHJveHlIb3N0KG9wdGlvbnMpLCBvcHRpb25zLmhlYWRlcnMgPSBPYmplY3Qua2V5cyhvcHRpb25zLmhlYWRlcnMgfHwge30pLnJlZHVjZSgoaGVhZGVycywgaGVhZGVyKSA9PiAocHJveHlIZWFkZXJFeGNsdXNpdmVMaXN0LmluZGV4T2YoaGVhZGVyLnRvTG93ZXJDYXNlKCkpID09PSAtMSAmJiAoaGVhZGVyc1toZWFkZXJdID0gb3B0aW9ucy5oZWFkZXJzW2hlYWRlcl0pLCBoZWFkZXJzKSwge30pO1xuICBjb25zdCB0dW5uZWxGbiA9IGdldFR1bm5lbEZuKG9wdGlvbnMsIHByb3h5KSwgdHVubmVsT3B0aW9ucyA9IGNvbnN0cnVjdFR1bm5lbE9wdGlvbnMob3B0aW9ucywgcHJveHksIHByb3h5SGVhZGVycyk7XG4gIHJldHVybiBvcHRpb25zLmFnZW50ID0gdHVubmVsRm4odHVubmVsT3B0aW9ucyksIG9wdGlvbnM7XG59XG5mdW5jdGlvbiBnZXRUdW5uZWxGbihvcHRpb25zLCBwcm94eSkge1xuICBjb25zdCB1cmkgPSBnZXRVcmlQYXJ0cyhvcHRpb25zKSwgdHVubmVsRm5OYW1lID0gY29uc3RydWN0VHVubmVsRm5OYW1lKHVyaSwgcHJveHkpO1xuICByZXR1cm4gdHVubmVsX19uYW1lc3BhY2VbdHVubmVsRm5OYW1lXTtcbn1cbmZ1bmN0aW9uIGdldFVyaVBhcnRzKG9wdGlvbnMpIHtcbiAgcmV0dXJuIHVyaVBhcnRzLnJlZHVjZSgodXJpLCBwYXJ0KSA9PiAodXJpW3BhcnRdID0gb3B0aW9uc1twYXJ0XSwgdXJpKSwge30pO1xufVxuZnVuY3Rpb24gY29uc3RydWN0VHVubmVsRm5OYW1lKHVyaSwgcHJveHkpIHtcbiAgY29uc3QgdXJpUHJvdG9jb2wgPSB1cmkucHJvdG9jb2wgPT09IFwiaHR0cHM6XCIgPyBcImh0dHBzXCIgOiBcImh0dHBcIiwgcHJveHlQcm90b2NvbCA9IHByb3h5LnByb3RvY29sID09PSBcImh0dHBzOlwiID8gXCJIdHRwc1wiIDogXCJIdHRwXCI7XG4gIHJldHVybiBgJHt1cmlQcm90b2NvbH1PdmVyJHtwcm94eVByb3RvY29sfWA7XG59XG5mdW5jdGlvbiBjb25zdHJ1Y3RQcm94eUhvc3QodXJpKSB7XG4gIGNvbnN0IHBvcnQgPSB1cmkucG9ydCwgcHJvdG9jb2wgPSB1cmkucHJvdG9jb2w7XG4gIGxldCBwcm94eUhvc3QgPSBgJHt1cmkuaG9zdG5hbWV9OmA7XG4gIHJldHVybiBwb3J0ID8gcHJveHlIb3N0ICs9IHBvcnQgOiBwcm90b2NvbCA9PT0gXCJodHRwczpcIiA/IHByb3h5SG9zdCArPSBcIjQ0M1wiIDogcHJveHlIb3N0ICs9IFwiODBcIiwgcHJveHlIb3N0O1xufVxuZnVuY3Rpb24gZ2V0QWxsb3dlZFByb3h5SGVhZGVycyhoZWFkZXJzLCB3aGl0ZUxpc3QpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKGhlYWRlcnMpLmZpbHRlcigoaGVhZGVyKSA9PiB3aGl0ZUxpc3QuaW5kZXhPZihoZWFkZXIudG9Mb3dlckNhc2UoKSkgIT09IC0xKS5yZWR1Y2UoKHNldCwgaGVhZGVyKSA9PiAoc2V0W2hlYWRlcl0gPSBoZWFkZXJzW2hlYWRlcl0sIHNldCksIHt9KTtcbn1cbmZ1bmN0aW9uIGNvbnN0cnVjdFR1bm5lbE9wdGlvbnMob3B0aW9ucywgcHJveHksIHByb3h5SGVhZGVycykge1xuICByZXR1cm4ge1xuICAgIHByb3h5OiB7XG4gICAgICBob3N0OiBwcm94eS5ob3N0bmFtZSxcbiAgICAgIHBvcnQ6ICtwcm94eS5wb3J0LFxuICAgICAgcHJveHlBdXRoOiBwcm94eS5hdXRoLFxuICAgICAgaGVhZGVyczogcHJveHlIZWFkZXJzXG4gICAgfSxcbiAgICBoZWFkZXJzOiBvcHRpb25zLmhlYWRlcnMsXG4gICAgY2E6IG9wdGlvbnMuY2EsXG4gICAgY2VydDogb3B0aW9ucy5jZXJ0LFxuICAgIGtleTogb3B0aW9ucy5rZXksXG4gICAgcGFzc3BocmFzZTogb3B0aW9ucy5wYXNzcGhyYXNlLFxuICAgIHBmeDogb3B0aW9ucy5wZngsXG4gICAgY2lwaGVyczogb3B0aW9ucy5jaXBoZXJzLFxuICAgIHJlamVjdFVuYXV0aG9yaXplZDogb3B0aW9ucy5yZWplY3RVbmF1dGhvcml6ZWQsXG4gICAgc2VjdXJlT3B0aW9uczogb3B0aW9ucy5zZWN1cmVPcHRpb25zLFxuICAgIHNlY3VyZVByb3RvY29sOiBvcHRpb25zLnNlY3VyZVByb3RvY29sXG4gIH07XG59XG5jb25zdCBhZGFwdGVyID0gXCJub2RlXCIsIHJlZHVjZVJlc3BvbnNlID0gKHJlcywgcmVxVXJsLCBtZXRob2QsIGJvZHkpID0+ICh7XG4gIGJvZHksXG4gIHVybDogcmVxVXJsLFxuICBtZXRob2QsXG4gIGhlYWRlcnM6IHJlcy5oZWFkZXJzLFxuICBzdGF0dXNDb2RlOiByZXMuc3RhdHVzQ29kZSxcbiAgc3RhdHVzTWVzc2FnZTogcmVzLnN0YXR1c01lc3NhZ2Vcbn0pLCBodHRwUmVxdWVzdGVyID0gKGNvbnRleHQsIGNiKSA9PiB7XG4gIGNvbnN0IHsgb3B0aW9ucyB9ID0gY29udGV4dCwgdXJpID0gT2JqZWN0LmFzc2lnbih7fSwgdXJsX19kZWZhdWx0LmRlZmF1bHQucGFyc2Uob3B0aW9ucy51cmwpKTtcbiAgaWYgKHR5cGVvZiBmZXRjaCA9PSBcImZ1bmN0aW9uXCIgJiYgb3B0aW9ucy5mZXRjaCkge1xuICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCksIHJlcU9wdHMyID0gY29udGV4dC5hcHBseU1pZGRsZXdhcmUoXCJmaW5hbGl6ZU9wdGlvbnNcIiwge1xuICAgICAgLi4udXJpLFxuICAgICAgbWV0aG9kOiBvcHRpb25zLm1ldGhvZCxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgLi4udHlwZW9mIG9wdGlvbnMuZmV0Y2ggPT0gXCJvYmplY3RcIiAmJiBvcHRpb25zLmZldGNoLmhlYWRlcnMgPyBsb3dlckNhc2VIZWFkZXJzKG9wdGlvbnMuZmV0Y2guaGVhZGVycykgOiB7fSxcbiAgICAgICAgLi4ubG93ZXJDYXNlSGVhZGVycyhvcHRpb25zLmhlYWRlcnMpXG4gICAgICB9LFxuICAgICAgbWF4UmVkaXJlY3RzOiBvcHRpb25zLm1heFJlZGlyZWN0c1xuICAgIH0pLCBmZXRjaE9wdHMgPSB7XG4gICAgICBjcmVkZW50aWFsczogb3B0aW9ucy53aXRoQ3JlZGVudGlhbHMgPyBcImluY2x1ZGVcIiA6IFwib21pdFwiLFxuICAgICAgLi4udHlwZW9mIG9wdGlvbnMuZmV0Y2ggPT0gXCJvYmplY3RcIiA/IG9wdGlvbnMuZmV0Y2ggOiB7fSxcbiAgICAgIG1ldGhvZDogcmVxT3B0czIubWV0aG9kLFxuICAgICAgaGVhZGVyczogcmVxT3B0czIuaGVhZGVycyxcbiAgICAgIGJvZHk6IG9wdGlvbnMuYm9keSxcbiAgICAgIHNpZ25hbDogY29udHJvbGxlci5zaWduYWxcbiAgICB9LCBpbmplY3RlZFJlc3BvbnNlMiA9IGNvbnRleHQuYXBwbHlNaWRkbGV3YXJlKFwiaW50ZXJjZXB0UmVxdWVzdFwiLCB2b2lkIDAsIHtcbiAgICAgIGFkYXB0ZXIsXG4gICAgICBjb250ZXh0XG4gICAgfSk7XG4gICAgaWYgKGluamVjdGVkUmVzcG9uc2UyKSB7XG4gICAgICBjb25zdCBjYlRpbWVyID0gc2V0VGltZW91dChjYiwgMCwgbnVsbCwgaW5qZWN0ZWRSZXNwb25zZTIpO1xuICAgICAgcmV0dXJuIHsgYWJvcnQ6ICgpID0+IGNsZWFyVGltZW91dChjYlRpbWVyKSB9O1xuICAgIH1cbiAgICBjb25zdCByZXF1ZXN0MiA9IGZldGNoKG9wdGlvbnMudXJsLCBmZXRjaE9wdHMpO1xuICAgIHJldHVybiBjb250ZXh0LmFwcGx5TWlkZGxld2FyZShcIm9uUmVxdWVzdFwiLCB7IG9wdGlvbnMsIGFkYXB0ZXIsIHJlcXVlc3Q6IHJlcXVlc3QyLCBjb250ZXh0IH0pLCByZXF1ZXN0Mi50aGVuKGFzeW5jIChyZXMpID0+IHtcbiAgICAgIGNvbnN0IGJvZHkgPSBvcHRpb25zLnJhd0JvZHkgPyByZXMuYm9keSA6IGF3YWl0IHJlcy50ZXh0KCksIGhlYWRlcnMgPSB7fTtcbiAgICAgIHJlcy5oZWFkZXJzLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgaGVhZGVyc1trZXldID0gdmFsdWU7XG4gICAgICB9KSwgY2IobnVsbCwge1xuICAgICAgICBib2R5LFxuICAgICAgICB1cmw6IHJlcy51cmwsXG4gICAgICAgIG1ldGhvZDogb3B0aW9ucy5tZXRob2QsXG4gICAgICAgIGhlYWRlcnMsXG4gICAgICAgIHN0YXR1c0NvZGU6IHJlcy5zdGF0dXMsXG4gICAgICAgIHN0YXR1c01lc3NhZ2U6IHJlcy5zdGF0dXNUZXh0XG4gICAgICB9KTtcbiAgICB9KS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICBlcnIubmFtZSAhPSBcIkFib3J0RXJyb3JcIiAmJiBjYihlcnIpO1xuICAgIH0pLCB7IGFib3J0OiAoKSA9PiBjb250cm9sbGVyLmFib3J0KCkgfTtcbiAgfVxuICBjb25zdCBib2R5VHlwZSA9IGlzU3RyZWFtX19kZWZhdWx0LmRlZmF1bHQob3B0aW9ucy5ib2R5KSA/IFwic3RyZWFtXCIgOiB0eXBlb2Ygb3B0aW9ucy5ib2R5O1xuICBpZiAoYm9keVR5cGUgIT09IFwidW5kZWZpbmVkXCIgJiYgYm9keVR5cGUgIT09IFwic3RyZWFtXCIgJiYgYm9keVR5cGUgIT09IFwic3RyaW5nXCIgJiYgIUJ1ZmZlci5pc0J1ZmZlcihvcHRpb25zLmJvZHkpKVxuICAgIHRocm93IG5ldyBFcnJvcihgUmVxdWVzdCBib2R5IG11c3QgYmUgYSBzdHJpbmcsIGJ1ZmZlciBvciBzdHJlYW0sIGdvdCAke2JvZHlUeXBlfWApO1xuICBjb25zdCBsZW5ndGhIZWFkZXIgPSB7fTtcbiAgb3B0aW9ucy5ib2R5U2l6ZSA/IGxlbmd0aEhlYWRlcltcImNvbnRlbnQtbGVuZ3RoXCJdID0gb3B0aW9ucy5ib2R5U2l6ZSA6IG9wdGlvbnMuYm9keSAmJiBib2R5VHlwZSAhPT0gXCJzdHJlYW1cIiAmJiAobGVuZ3RoSGVhZGVyW1wiY29udGVudC1sZW5ndGhcIl0gPSBCdWZmZXIuYnl0ZUxlbmd0aChvcHRpb25zLmJvZHkpKTtcbiAgbGV0IGFib3J0ZWQgPSAhMTtcbiAgY29uc3QgY2FsbGJhY2sgPSAoZXJyLCByZXMpID0+ICFhYm9ydGVkICYmIGNiKGVyciwgcmVzKTtcbiAgY29udGV4dC5jaGFubmVscy5hYm9ydC5zdWJzY3JpYmUoKCkgPT4ge1xuICAgIGFib3J0ZWQgPSAhMDtcbiAgfSk7XG4gIGxldCByZXFPcHRzID0gT2JqZWN0LmFzc2lnbih7fSwgdXJpLCB7XG4gICAgbWV0aG9kOiBvcHRpb25zLm1ldGhvZCxcbiAgICBoZWFkZXJzOiBPYmplY3QuYXNzaWduKHt9LCBsb3dlckNhc2VIZWFkZXJzKG9wdGlvbnMuaGVhZGVycyksIGxlbmd0aEhlYWRlciksXG4gICAgbWF4UmVkaXJlY3RzOiBvcHRpb25zLm1heFJlZGlyZWN0c1xuICB9KTtcbiAgY29uc3QgcHJveHkgPSBnZXRQcm94eU9wdGlvbnMob3B0aW9ucyksIHR1bm5lbDIgPSBwcm94eSAmJiBzaG91bGRFbmFibGUob3B0aW9ucyksIGluamVjdGVkUmVzcG9uc2UgPSBjb250ZXh0LmFwcGx5TWlkZGxld2FyZShcImludGVyY2VwdFJlcXVlc3RcIiwgdm9pZCAwLCB7XG4gICAgYWRhcHRlcixcbiAgICBjb250ZXh0XG4gIH0pO1xuICBpZiAoaW5qZWN0ZWRSZXNwb25zZSkge1xuICAgIGNvbnN0IGNiVGltZXIgPSBzZXRJbW1lZGlhdGUoY2FsbGJhY2ssIG51bGwsIGluamVjdGVkUmVzcG9uc2UpO1xuICAgIHJldHVybiB7IGFib3J0OiAoKSA9PiBjbGVhckltbWVkaWF0ZShjYlRpbWVyKSB9O1xuICB9XG4gIGlmIChvcHRpb25zLm1heFJlZGlyZWN0cyAhPT0gMCAmJiAocmVxT3B0cy5tYXhSZWRpcmVjdHMgPSBvcHRpb25zLm1heFJlZGlyZWN0cyB8fCA1KSwgcHJveHkgJiYgdHVubmVsMiA/IHJlcU9wdHMgPSBhcHBseUFnZW50KHJlcU9wdHMsIHByb3h5KSA6IHByb3h5ICYmICF0dW5uZWwyICYmIChyZXFPcHRzID0gcmV3cml0ZVVyaUZvclByb3h5KHJlcU9wdHMsIHVyaSwgcHJveHkpKSwgIXR1bm5lbDIgJiYgcHJveHkgJiYgcHJveHkuYXV0aCAmJiAhcmVxT3B0cy5oZWFkZXJzW1wicHJveHktYXV0aG9yaXphdGlvblwiXSkge1xuICAgIGNvbnN0IFt1c2VybmFtZSwgcGFzc3dvcmRdID0gcHJveHkuYXV0aC51c2VybmFtZSA/IFtwcm94eS5hdXRoLnVzZXJuYW1lLCBwcm94eS5hdXRoLnBhc3N3b3JkXSA6IHByb3h5LmF1dGguc3BsaXQoXCI6XCIpLm1hcCgoaXRlbSkgPT4gcXNfX2RlZmF1bHQuZGVmYXVsdC51bmVzY2FwZShpdGVtKSksIGF1dGhCYXNlNjQgPSBCdWZmZXIuZnJvbShgJHt1c2VybmFtZX06JHtwYXNzd29yZH1gLCBcInV0ZjhcIikudG9TdHJpbmcoXCJiYXNlNjRcIik7XG4gICAgcmVxT3B0cy5oZWFkZXJzW1wicHJveHktYXV0aG9yaXphdGlvblwiXSA9IGBCYXNpYyAke2F1dGhCYXNlNjR9YDtcbiAgfVxuICBjb25zdCB0cmFuc3BvcnQgPSBnZXRSZXF1ZXN0VHJhbnNwb3J0KHJlcU9wdHMsIHByb3h5LCB0dW5uZWwyKTtcbiAgdHlwZW9mIG9wdGlvbnMuZGVidWcgPT0gXCJmdW5jdGlvblwiICYmIHByb3h5ICYmIG9wdGlvbnMuZGVidWcoXG4gICAgXCJQcm94eWluZyB1c2luZyAlc1wiLFxuICAgIHJlcU9wdHMuYWdlbnQgPyBcInR1bm5lbCBhZ2VudFwiIDogYCR7cmVxT3B0cy5ob3N0fToke3JlcU9wdHMucG9ydH1gXG4gICk7XG4gIGNvbnN0IHRyeUNvbXByZXNzZWQgPSByZXFPcHRzLm1ldGhvZCAhPT0gXCJIRUFEXCI7XG4gIHRyeUNvbXByZXNzZWQgJiYgIXJlcU9wdHMuaGVhZGVyc1tcImFjY2VwdC1lbmNvZGluZ1wiXSAmJiBvcHRpb25zLmNvbXByZXNzICE9PSAhMSAmJiAocmVxT3B0cy5oZWFkZXJzW1wiYWNjZXB0LWVuY29kaW5nXCJdID0gXCJiciwgZ3ppcCwgZGVmbGF0ZVwiKTtcbiAgY29uc3QgZmluYWxPcHRpb25zID0gY29udGV4dC5hcHBseU1pZGRsZXdhcmUoXG4gICAgXCJmaW5hbGl6ZU9wdGlvbnNcIixcbiAgICByZXFPcHRzXG4gICksIHJlcXVlc3QgPSB0cmFuc3BvcnQucmVxdWVzdChmaW5hbE9wdGlvbnMsIChyZXNwb25zZSkgPT4ge1xuICAgIGNvbnN0IHJlcyA9IHRyeUNvbXByZXNzZWQgPyBkZWNvbXByZXNzUmVzcG9uc2VfX2RlZmF1bHQuZGVmYXVsdChyZXNwb25zZSkgOiByZXNwb25zZSwgcmVzU3RyZWFtID0gY29udGV4dC5hcHBseU1pZGRsZXdhcmUoXCJvbkhlYWRlcnNcIiwgcmVzLCB7XG4gICAgICBoZWFkZXJzOiByZXNwb25zZS5oZWFkZXJzLFxuICAgICAgYWRhcHRlcixcbiAgICAgIGNvbnRleHRcbiAgICB9KSwgcmVxVXJsID0gXCJyZXNwb25zZVVybFwiIGluIHJlc3BvbnNlID8gcmVzcG9uc2UucmVzcG9uc2VVcmwgOiBvcHRpb25zLnVybDtcbiAgICBpZiAob3B0aW9ucy5zdHJlYW0pIHtcbiAgICAgIGNhbGxiYWNrKG51bGwsIHJlZHVjZVJlc3BvbnNlKHJlcywgcmVxVXJsLCByZXFPcHRzLm1ldGhvZCwgcmVzU3RyZWFtKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbmNhdChyZXNTdHJlYW0sIChlcnIsIGRhdGEpID0+IHtcbiAgICAgIGlmIChlcnIpXG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgY29uc3QgYm9keSA9IG9wdGlvbnMucmF3Qm9keSA/IGRhdGEgOiBkYXRhLnRvU3RyaW5nKCksIHJlZHVjZWQgPSByZWR1Y2VSZXNwb25zZShyZXMsIHJlcVVybCwgcmVxT3B0cy5tZXRob2QsIGJvZHkpO1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHJlZHVjZWQpO1xuICAgIH0pO1xuICB9KTtcbiAgb3B0aW9ucy50aW1lb3V0ICYmIHRpbWVkT3V0KHJlcXVlc3QsIG9wdGlvbnMudGltZW91dCksIHJlcXVlc3Qub25jZShcImVycm9yXCIsIGNhbGxiYWNrKTtcbiAgY29uc3QgeyBib2R5U3RyZWFtLCBwcm9ncmVzcyB9ID0gZ2V0UHJvZ3Jlc3NTdHJlYW0ob3B0aW9ucyk7XG4gIHJldHVybiBjb250ZXh0LmFwcGx5TWlkZGxld2FyZShcIm9uUmVxdWVzdFwiLCB7IG9wdGlvbnMsIGFkYXB0ZXIsIHJlcXVlc3QsIGNvbnRleHQsIHByb2dyZXNzIH0pLCBib2R5U3RyZWFtID8gYm9keVN0cmVhbS5waXBlKHJlcXVlc3QpIDogcmVxdWVzdC5lbmQob3B0aW9ucy5ib2R5KSwgeyBhYm9ydDogKCkgPT4gcmVxdWVzdC5hYm9ydCgpIH07XG59O1xuZnVuY3Rpb24gZ2V0UHJvZ3Jlc3NTdHJlYW0ob3B0aW9ucykge1xuICBpZiAoIW9wdGlvbnMuYm9keSlcbiAgICByZXR1cm4ge307XG4gIGNvbnN0IGJvZHlJc1N0cmVhbSA9IGlzU3RyZWFtX19kZWZhdWx0LmRlZmF1bHQob3B0aW9ucy5ib2R5KSwgbGVuZ3RoID0gb3B0aW9ucy5ib2R5U2l6ZSB8fCAoYm9keUlzU3RyZWFtID8gbnVsbCA6IEJ1ZmZlci5ieXRlTGVuZ3RoKG9wdGlvbnMuYm9keSkpO1xuICBpZiAoIWxlbmd0aClcbiAgICByZXR1cm4gYm9keUlzU3RyZWFtID8geyBib2R5U3RyZWFtOiBvcHRpb25zLmJvZHkgfSA6IHt9O1xuICBjb25zdCBwcm9ncmVzcyA9IHByb2dyZXNzU3RyZWFtX19kZWZhdWx0LmRlZmF1bHQoeyB0aW1lOiAxNiwgbGVuZ3RoIH0pO1xuICByZXR1cm4geyBib2R5U3RyZWFtOiAoYm9keUlzU3RyZWFtID8gb3B0aW9ucy5ib2R5IDogdG9TdHJlYW1fX2RlZmF1bHQuZGVmYXVsdChvcHRpb25zLmJvZHkpKS5waXBlKHByb2dyZXNzKSwgcHJvZ3Jlc3MgfTtcbn1cbmZ1bmN0aW9uIGdldFJlcXVlc3RUcmFuc3BvcnQocmVxT3B0cywgcHJveHksIHR1bm5lbDIpIHtcbiAgY29uc3QgaXNIdHRwc1JlcXVlc3QgPSByZXFPcHRzLnByb3RvY29sID09PSBcImh0dHBzOlwiLCB0cmFuc3BvcnRzID0gcmVxT3B0cy5tYXhSZWRpcmVjdHMgPT09IDAgPyB7IGh0dHA6IGh0dHBfX2RlZmF1bHQuZGVmYXVsdCwgaHR0cHM6IGh0dHBzX19kZWZhdWx0LmRlZmF1bHQgfSA6IHsgaHR0cDogZm9sbG93X19kZWZhdWx0LmRlZmF1bHQuaHR0cCwgaHR0cHM6IGZvbGxvd19fZGVmYXVsdC5kZWZhdWx0Lmh0dHBzIH07XG4gIGlmICghcHJveHkgfHwgdHVubmVsMilcbiAgICByZXR1cm4gaXNIdHRwc1JlcXVlc3QgPyB0cmFuc3BvcnRzLmh0dHBzIDogdHJhbnNwb3J0cy5odHRwO1xuICBsZXQgaXNIdHRwc1Byb3h5ID0gcHJveHkucG9ydCA9PT0gNDQzO1xuICByZXR1cm4gcHJveHkucHJvdG9jb2wgJiYgKGlzSHR0cHNQcm94eSA9IC9eaHR0cHM6Py8udGVzdChwcm94eS5wcm90b2NvbCkpLCBpc0h0dHBzUHJveHkgPyB0cmFuc3BvcnRzLmh0dHBzIDogdHJhbnNwb3J0cy5odHRwO1xufVxuY29uc3QgZ2V0SXQgPSAoaW5pdE1pZGRsZXdhcmUgPSBbXSwgaHR0cFJlcXVlc3QgPSBodHRwUmVxdWVzdGVyKSA9PiBjcmVhdGVSZXF1ZXN0ZXIoaW5pdE1pZGRsZXdhcmUsIGh0dHBSZXF1ZXN0KSwgZW52aXJvbm1lbnQgPSBcIm5vZGVcIjtcbmV4cG9ydHMuYWRhcHRlciA9IGFkYXB0ZXI7XG5leHBvcnRzLmVudmlyb25tZW50ID0gZW52aXJvbm1lbnQ7XG5leHBvcnRzLmdldEl0ID0gZ2V0SXQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5janMubWFwXG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJkZWZhdWx0T3B0aW9uc1ZhbGlkYXRvciIsInJlcXVpcmUiLCJkZWNvbXByZXNzUmVzcG9uc2UiLCJmb2xsb3ciLCJodHRwIiwiaHR0cHMiLCJ0b1N0cmVhbSIsImlzU3RyZWFtIiwicHJvZ3Jlc3NTdHJlYW0iLCJxcyIsInVybCIsInR1bm5lbCIsIl9pbnRlcm9wRGVmYXVsdENvbXBhdCIsImUiLCJkZWZhdWx0IiwiX2ludGVyb3BOYW1lc3BhY2VDb21wYXQiLCJuIiwiY3JlYXRlIiwia2V5cyIsImZvckVhY2giLCJrIiwiZCIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImdldCIsImVudW1lcmFibGUiLCJmcmVlemUiLCJkZWNvbXByZXNzUmVzcG9uc2VfX2RlZmF1bHQiLCJmb2xsb3dfX2RlZmF1bHQiLCJodHRwX19kZWZhdWx0IiwiaHR0cHNfX2RlZmF1bHQiLCJ0b1N0cmVhbV9fZGVmYXVsdCIsImlzU3RyZWFtX19kZWZhdWx0IiwicHJvZ3Jlc3NTdHJlYW1fX2RlZmF1bHQiLCJxc19fZGVmYXVsdCIsInVybF9fZGVmYXVsdCIsInR1bm5lbF9fbmFtZXNwYWNlIiwibWlkZGxld2FyZVJlZHVjZXIiLCJtaWRkbGV3YXJlIiwiaG9vayIsImRlZmF1bHRWYWx1ZSIsImFyZ3MiLCJiYWlsRWFybHkiLCJpIiwibGVuZ3RoIiwiaGFuZGxlciIsImNyZWF0ZVB1YlN1YiIsInN1YnNjcmliZXJzIiwibmV4dElkIiwic3Vic2NyaWJlIiwic3Vic2NyaWJlciIsImlkIiwicHVibGlzaCIsImV2ZW50IiwiY2hhbm5lbE5hbWVzIiwibWlkZGxlaG9va3MiLCJjcmVhdGVSZXF1ZXN0ZXIiLCJpbml0TWlkZGxld2FyZSIsImh0dHBSZXF1ZXN0IiwibG9hZGVkTWlkZGxld2FyZSIsInJlZHVjZSIsIndhcmUiLCJuYW1lIiwicHJvY2Vzc09wdGlvbnMiLCJ2YWxpZGF0ZU9wdGlvbnMiLCJyZXF1ZXN0Iiwib3B0cyIsIm9uUmVzcG9uc2UiLCJyZXFFcnIiLCJyZXMiLCJjdHgiLCJlcnJvciIsInJlc3BvbnNlIiwiYXBwbHlNaWRkbGV3YXJlIiwiZXJyIiwiY2hhbm5lbHMiLCJ0YXJnZXQiLCJvcHRpb25zIiwiY29udGV4dCIsIm9uZ29pbmdSZXF1ZXN0IiwidW5zdWJzY3JpYmUiLCJhYm9ydCIsInJldHVyblZhbHVlIiwidXNlIiwibmV3TWlkZGxld2FyZSIsIkVycm9yIiwib25SZXR1cm4iLCJrZXkiLCJwdXNoIiwiY2xvbmUiLCJsb3dlckNhc2VIZWFkZXJzIiwiaGVhZGVycyIsImFjYyIsImhlYWRlciIsInRvTG93ZXJDYXNlIiwiZm9ybWF0SG9zdG5hbWUiLCJob3N0bmFtZSIsInJlcGxhY2UiLCJwYXJzZU5vUHJveHlab25lIiwiem9uZVN0ciIsInpvbmUiLCJ0cmltIiwiem9uZVBhcnRzIiwic3BsaXQiLCJ6b25lSG9zdCIsInpvbmVQb3J0IiwiaGFzUG9ydCIsImluZGV4T2YiLCJwb3J0IiwidXJpSW5Ob1Byb3h5IiwidXJpIiwibm9Qcm94eSIsInByb3RvY29sIiwibWFwIiwic29tZSIsIm5vUHJveHlab25lIiwiaXNNYXRjaGVkQXQiLCJob3N0bmFtZU1hdGNoZWQiLCJnZXRQcm94eUZyb21VcmkiLCJwcm9jZXNzIiwiZW52IiwiTk9fUFJPWFkiLCJub19wcm94eSIsIkhUVFBfUFJPWFkiLCJodHRwX3Byb3h5IiwiSFRUUFNfUFJPWFkiLCJodHRwc19wcm94eSIsImdldEhvc3RGcm9tVXJpIiwiaG9zdCIsImdldEhvc3RIZWFkZXJXaXRoUG9ydCIsInJld3JpdGVVcmlGb3JQcm94eSIsInJlcU9wdHMiLCJwcm94eSIsImFzc2lnbiIsImhyZWYiLCJwYXRoIiwiZm9ybWF0IiwiZ2V0UHJveHlPcHRpb25zIiwiaGFzT3duUHJvcGVydHkiLCJwYXJzZSIsImNvbmNhdCIsInN0cmVhbSIsImNiIiwiY2h1bmtzIiwib24iLCJjaHVuayIsIm9uY2UiLCJCdWZmZXIiLCJ0aW1lZE91dCIsInJlcSIsInRpbWUiLCJ0aW1lb3V0VGltZXIiLCJkZWxheXMiLCJpc05hTiIsInNvY2tldCIsImNvbm5lY3QiLCJob3N0SGVhZGVyIiwiZ2V0SGVhZGVyIiwic2V0VGltZW91dCIsImNvZGUiLCJlbWl0IiwiY29ubmVjdGluZyIsIl9jb25uZWN0aW5nIiwiY2xlYXIiLCJjbGVhclRpbWVvdXQiLCJ1cmlQYXJ0cyIsImRlZmF1bHRQcm94eUhlYWRlcldoaXRlTGlzdCIsImRlZmF1bHRQcm94eUhlYWRlckV4Y2x1c2l2ZUxpc3QiLCJzaG91bGRFbmFibGUiLCJhcHBseUFnZW50IiwicHJveHlIZWFkZXJXaGl0ZUxpc3QiLCJwcm94eUhlYWRlckV4Y2x1c2l2ZUxpc3QiLCJwcm94eUhlYWRlcnMiLCJnZXRBbGxvd2VkUHJveHlIZWFkZXJzIiwiY29uc3RydWN0UHJveHlIb3N0IiwidHVubmVsRm4iLCJnZXRUdW5uZWxGbiIsInR1bm5lbE9wdGlvbnMiLCJjb25zdHJ1Y3RUdW5uZWxPcHRpb25zIiwiYWdlbnQiLCJnZXRVcmlQYXJ0cyIsInR1bm5lbEZuTmFtZSIsImNvbnN0cnVjdFR1bm5lbEZuTmFtZSIsInBhcnQiLCJ1cmlQcm90b2NvbCIsInByb3h5UHJvdG9jb2wiLCJwcm94eUhvc3QiLCJ3aGl0ZUxpc3QiLCJmaWx0ZXIiLCJzZXQiLCJwcm94eUF1dGgiLCJhdXRoIiwiY2EiLCJjZXJ0IiwicGFzc3BocmFzZSIsInBmeCIsImNpcGhlcnMiLCJyZWplY3RVbmF1dGhvcml6ZWQiLCJzZWN1cmVPcHRpb25zIiwic2VjdXJlUHJvdG9jb2wiLCJhZGFwdGVyIiwicmVkdWNlUmVzcG9uc2UiLCJyZXFVcmwiLCJtZXRob2QiLCJib2R5Iiwic3RhdHVzQ29kZSIsInN0YXR1c01lc3NhZ2UiLCJodHRwUmVxdWVzdGVyIiwiZmV0Y2giLCJjb250cm9sbGVyIiwiQWJvcnRDb250cm9sbGVyIiwicmVxT3B0czIiLCJtYXhSZWRpcmVjdHMiLCJmZXRjaE9wdHMiLCJjcmVkZW50aWFscyIsIndpdGhDcmVkZW50aWFscyIsInNpZ25hbCIsImluamVjdGVkUmVzcG9uc2UyIiwiY2JUaW1lciIsInJlcXVlc3QyIiwidGhlbiIsInJhd0JvZHkiLCJ0ZXh0Iiwic3RhdHVzIiwic3RhdHVzVGV4dCIsImNhdGNoIiwiYm9keVR5cGUiLCJpc0J1ZmZlciIsImxlbmd0aEhlYWRlciIsImJvZHlTaXplIiwiYnl0ZUxlbmd0aCIsImFib3J0ZWQiLCJjYWxsYmFjayIsInR1bm5lbDIiLCJpbmplY3RlZFJlc3BvbnNlIiwic2V0SW1tZWRpYXRlIiwiY2xlYXJJbW1lZGlhdGUiLCJ1c2VybmFtZSIsInBhc3N3b3JkIiwiaXRlbSIsInVuZXNjYXBlIiwiYXV0aEJhc2U2NCIsImZyb20iLCJ0b1N0cmluZyIsInRyYW5zcG9ydCIsImdldFJlcXVlc3RUcmFuc3BvcnQiLCJkZWJ1ZyIsInRyeUNvbXByZXNzZWQiLCJjb21wcmVzcyIsImZpbmFsT3B0aW9ucyIsInJlc1N0cmVhbSIsInJlc3BvbnNlVXJsIiwiZGF0YSIsInJlZHVjZWQiLCJ0aW1lb3V0IiwiYm9keVN0cmVhbSIsInByb2dyZXNzIiwiZ2V0UHJvZ3Jlc3NTdHJlYW0iLCJwaXBlIiwiZW5kIiwiYm9keUlzU3RyZWFtIiwiaXNIdHRwc1JlcXVlc3QiLCJ0cmFuc3BvcnRzIiwiaXNIdHRwc1Byb3h5IiwidGVzdCIsImdldEl0IiwiZW52aXJvbm1lbnQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/get-it/dist/index.cjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/get-it/dist/middleware.cjs":
/*!*************************************************!*\
  !*** ./node_modules/get-it/dist/middleware.cjs ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: !0\n}));\nvar http = __webpack_require__(/*! http */ \"http\"), https = __webpack_require__(/*! https */ \"https\"), debugIt = __webpack_require__(/*! debug */ \"(ssr)/./node_modules/debug/src/index.js\"), defaultOptionsValidator = __webpack_require__(/*! ./_chunks/defaultOptionsValidator-CXwrNjme.cjs */ \"(ssr)/./node_modules/get-it/dist/_chunks/defaultOptionsValidator-CXwrNjme.cjs\"), isPlainObject = __webpack_require__(/*! is-plain-object */ \"(ssr)/./node_modules/is-plain-object/dist/is-plain-object.js\"), progressStream = __webpack_require__(/*! progress-stream */ \"(ssr)/./node_modules/progress-stream/index.js\"), allowed = __webpack_require__(/*! is-retry-allowed */ \"(ssr)/./node_modules/is-retry-allowed/index.js\");\nfunction _interopDefaultCompat(e) {\n    return e && typeof e == \"object\" && \"default\" in e ? e : {\n        default: e\n    };\n}\nvar debugIt__default = /* @__PURE__ */ _interopDefaultCompat(debugIt), progressStream__default = /* @__PURE__ */ _interopDefaultCompat(progressStream), allowed__default = /* @__PURE__ */ _interopDefaultCompat(allowed);\nconst isHttpsProto = /^https:/i;\nfunction agent(opts) {\n    const httpAgent = new http.Agent(opts), httpsAgent = new https.Agent(opts), agents = {\n        http: httpAgent,\n        https: httpsAgent\n    };\n    return {\n        finalizeOptions: (options)=>{\n            if (options.agent) return options;\n            if (options.maxRedirects > 0) return {\n                ...options,\n                agents\n            };\n            const isHttps = isHttpsProto.test(options.href || options.protocol);\n            return {\n                ...options,\n                agent: isHttps ? httpsAgent : httpAgent\n            };\n        }\n    };\n}\nconst leadingSlash = /^\\//, trailingSlash = /\\/$/;\nfunction base(baseUrl) {\n    const baseUri = baseUrl.replace(trailingSlash, \"\");\n    return {\n        processOptions: (options)=>{\n            if (/^https?:\\/\\//i.test(options.url)) return options;\n            const url = [\n                baseUri,\n                options.url.replace(leadingSlash, \"\")\n            ].join(\"/\");\n            return Object.assign({}, options, {\n                url\n            });\n        }\n    };\n}\nconst SENSITIVE_HEADERS = [\n    \"cookie\",\n    \"authorization\"\n], hasOwn = Object.prototype.hasOwnProperty, redactKeys = (source, redacted)=>{\n    const target = {};\n    for(const key in source)hasOwn.call(source, key) && (target[key] = redacted.indexOf(key.toLowerCase()) > -1 ? \"<redacted>\" : source[key]);\n    return target;\n};\nfunction debug(opts = {}) {\n    const verbose = opts.verbose, namespace = opts.namespace || \"get-it\", defaultLogger = debugIt__default.default(namespace), log = opts.log || defaultLogger, shortCircuit = log === defaultLogger && !debugIt__default.default.enabled(namespace);\n    let requestId = 0;\n    return {\n        processOptions: (options)=>(options.debug = log, options.requestId = options.requestId || ++requestId, options),\n        onRequest: (event)=>{\n            if (shortCircuit || !event) return event;\n            const options = event.options;\n            if (log(\"[%s] HTTP %s %s\", options.requestId, options.method, options.url), verbose && options.body && typeof options.body == \"string\" && log(\"[%s] Request body: %s\", options.requestId, options.body), verbose && options.headers) {\n                const headers2 = opts.redactSensitiveHeaders === !1 ? options.headers : redactKeys(options.headers, SENSITIVE_HEADERS);\n                log(\"[%s] Request headers: %s\", options.requestId, JSON.stringify(headers2, null, 2));\n            }\n            return event;\n        },\n        onResponse: (res, context)=>{\n            if (shortCircuit || !res) return res;\n            const reqId = context.options.requestId;\n            return log(\"[%s] Response code: %s %s\", reqId, res.statusCode, res.statusMessage), verbose && res.body && log(\"[%s] Response body: %s\", reqId, stringifyBody(res)), res;\n        },\n        onError: (err, context)=>{\n            const reqId = context.options.requestId;\n            return err ? (log(\"[%s] ERROR: %s\", reqId, err.message), err) : (log(\"[%s] Error encountered, but handled by an earlier middleware\", reqId), err);\n        }\n    };\n}\nfunction stringifyBody(res) {\n    return (res.headers[\"content-type\"] || \"\").toLowerCase().indexOf(\"application/json\") !== -1 ? tryFormat(res.body) : res.body;\n}\nfunction tryFormat(body) {\n    try {\n        const parsed = typeof body == \"string\" ? JSON.parse(body) : body;\n        return JSON.stringify(parsed, null, 2);\n    } catch  {\n        return body;\n    }\n}\nfunction headers(_headers, opts = {}) {\n    return {\n        processOptions: (options)=>{\n            const existing = options.headers || {};\n            return options.headers = opts.override ? Object.assign({}, existing, _headers) : Object.assign({}, _headers, existing), options;\n        }\n    };\n}\nclass HttpError extends Error {\n    constructor(res, ctx){\n        super();\n        const truncatedUrl = res.url.length > 400 ? `${res.url.slice(0, 399)}\\u2026` : res.url;\n        let msg = `${res.method}-request to ${truncatedUrl} resulted in `;\n        msg += `HTTP ${res.statusCode} ${res.statusMessage}`, this.message = msg.trim(), this.response = res, this.request = ctx.options;\n    }\n}\nfunction httpErrors() {\n    return {\n        onResponse: (res, ctx)=>{\n            if (!(res.statusCode >= 400)) return res;\n            throw new HttpError(res, ctx);\n        }\n    };\n}\nfunction injectResponse(opts = {}) {\n    if (typeof opts.inject != \"function\") throw new Error(\"`injectResponse` middleware requires a `inject` function\");\n    return {\n        interceptRequest: function(prevValue, event) {\n            const response = opts.inject(event, prevValue);\n            if (!response) return prevValue;\n            const options = event.context.options;\n            return {\n                body: \"\",\n                url: options.url,\n                method: options.method,\n                headers: {},\n                statusCode: 200,\n                statusMessage: \"OK\",\n                ...response\n            };\n        }\n    };\n}\nconst isBuffer = typeof Buffer > \"u\" ? ()=>!1 : (obj)=>Buffer.isBuffer(obj), serializeTypes = [\n    \"boolean\",\n    \"string\",\n    \"number\"\n];\nfunction jsonRequest() {\n    return {\n        processOptions: (options)=>{\n            const body = options.body;\n            return !body || !(typeof body.pipe != \"function\" && !isBuffer(body) && (serializeTypes.indexOf(typeof body) !== -1 || Array.isArray(body) || isPlainObject.isPlainObject(body))) ? options : Object.assign({}, options, {\n                body: JSON.stringify(options.body),\n                headers: Object.assign({}, options.headers, {\n                    \"Content-Type\": \"application/json\"\n                })\n            });\n        }\n    };\n}\nfunction jsonResponse(opts) {\n    return {\n        onResponse: (response)=>{\n            const contentType = response.headers[\"content-type\"] || \"\", shouldDecode = opts && opts.force || contentType.indexOf(\"application/json\") !== -1;\n            return !response.body || !contentType || !shouldDecode ? response : Object.assign({}, response, {\n                body: tryParse(response.body)\n            });\n        },\n        processOptions: (options)=>Object.assign({}, options, {\n                headers: Object.assign({\n                    Accept: \"application/json\"\n                }, options.headers)\n            })\n    };\n    function tryParse(body) {\n        try {\n            return JSON.parse(body);\n        } catch (err) {\n            throw err.message = `Failed to parsed response body as JSON: ${err.message}`, err;\n        }\n    }\n}\nfunction isBrowserOptions(options) {\n    return typeof options == \"object\" && options !== null && !(\"protocol\" in options);\n}\nfunction mtls(config = {}) {\n    if (!config.ca) throw new Error('Required mtls option \"ca\" is missing');\n    if (!config.cert) throw new Error('Required mtls option \"cert\" is missing');\n    if (!config.key) throw new Error('Required mtls option \"key\" is missing');\n    return {\n        finalizeOptions: (options)=>{\n            if (isBrowserOptions(options)) return options;\n            const mtlsOpts = {\n                cert: config.cert,\n                key: config.key,\n                ca: config.ca\n            };\n            return Object.assign({}, options, mtlsOpts);\n        }\n    };\n}\nlet actualGlobal = {};\ntypeof globalThis < \"u\" ? actualGlobal = globalThis :  false ? 0 : typeof global < \"u\" ? actualGlobal = global : typeof self < \"u\" && (actualGlobal = self);\nvar global$1 = actualGlobal;\nfunction observable(opts = {}) {\n    const Observable = // eslint-disable-next-line @typescript-eslint/no-explicit-any -- @TODO consider dropping checking for a global Observable since it's not on a standards track\n    opts.implementation || global$1.Observable;\n    if (!Observable) throw new Error(\"`Observable` is not available in global scope, and no implementation was passed\");\n    return {\n        onReturn: (channels, context)=>new Observable((observer)=>(channels.error.subscribe((err)=>observer.error(err)), channels.progress.subscribe((event)=>observer.next(Object.assign({\n                        type: \"progress\"\n                    }, event))), channels.response.subscribe((response)=>{\n                    observer.next(Object.assign({\n                        type: \"response\"\n                    }, response)), observer.complete();\n                }), channels.request.publish(context), ()=>channels.abort.publish()))\n    };\n}\nfunction normalizer(stage) {\n    return (prog)=>({\n            stage,\n            percent: prog.percentage,\n            total: prog.length,\n            loaded: prog.transferred,\n            lengthComputable: !(prog.length === 0 && prog.percentage === 0)\n        });\n}\nfunction progress() {\n    return {\n        onHeaders: (response, evt)=>{\n            const _progress = progressStream__default.default({\n                time: 16\n            }), normalize = normalizer(\"download\"), contentLength = response.headers[\"content-length\"], length = contentLength ? Number(contentLength) : 0;\n            return !isNaN(length) && length > 0 && _progress.setLength(length), _progress.on(\"progress\", (prog)=>evt.context.channels.progress.publish(normalize(prog))), response.pipe(_progress);\n        },\n        onRequest: (evt)=>{\n            if (!evt.progress) return;\n            const normalize = normalizer(\"upload\");\n            evt.progress.on(\"progress\", (prog)=>evt.context.channels.progress.publish(normalize(prog)));\n        }\n    };\n}\nconst promise = (options = {})=>{\n    const PromiseImplementation = options.implementation || Promise;\n    if (!PromiseImplementation) throw new Error(\"`Promise` is not available in global scope, and no implementation was passed\");\n    return {\n        onReturn: (channels, context)=>new PromiseImplementation((resolve, reject)=>{\n                const cancel = context.options.cancelToken;\n                cancel && cancel.promise.then((reason)=>{\n                    channels.abort.publish(reason), reject(reason);\n                }), channels.error.subscribe(reject), channels.response.subscribe((response)=>{\n                    resolve(options.onlyBody ? response.body : response);\n                }), setTimeout(()=>{\n                    try {\n                        channels.request.publish(context);\n                    } catch (err) {\n                        reject(err);\n                    }\n                }, 0);\n            })\n    };\n};\nclass Cancel {\n    constructor(message){\n        this.__CANCEL__ = !0, this.message = message;\n    }\n    toString() {\n        return `Cancel${this.message ? `: ${this.message}` : \"\"}`;\n    }\n}\nconst _CancelToken = class {\n    constructor(executor){\n        if (typeof executor != \"function\") throw new TypeError(\"executor must be a function.\");\n        let resolvePromise = null;\n        this.promise = new Promise((resolve)=>{\n            resolvePromise = resolve;\n        }), executor((message)=>{\n            this.reason || (this.reason = new Cancel(message), resolvePromise(this.reason));\n        });\n    }\n};\n_CancelToken.source = ()=>{\n    let cancel;\n    return {\n        token: new _CancelToken((can)=>{\n            cancel = can;\n        }),\n        cancel\n    };\n};\nlet CancelToken = _CancelToken;\nconst isCancel = (value)=>!!(value && value != null && value.__CANCEL__);\npromise.Cancel = Cancel;\npromise.CancelToken = CancelToken;\npromise.isCancel = isCancel;\nfunction proxy(_proxy) {\n    if (_proxy !== !1 && (!_proxy || !_proxy.host)) throw new Error(\"Proxy middleware takes an object of host, port and auth properties\");\n    return {\n        processOptions: (options)=>Object.assign({\n                proxy: _proxy\n            }, options)\n    };\n}\nvar defaultShouldRetry = (err, num, options)=>options.method !== \"GET\" && options.method !== \"HEAD\" || err.response && err.response.statusCode ? !1 : allowed__default.default(err);\nconst isStream = (stream)=>stream !== null && typeof stream == \"object\" && typeof stream.pipe == \"function\";\nvar sharedRetry = (opts)=>{\n    const maxRetries = opts.maxRetries || 5, retryDelay = opts.retryDelay || getRetryDelay, allowRetry = opts.shouldRetry;\n    return {\n        onError: (err, context)=>{\n            const options = context.options, max = options.maxRetries || maxRetries, shouldRetry = options.shouldRetry || allowRetry, attemptNumber = options.attemptNumber || 0;\n            if (isStream(options.body) || !shouldRetry(err, attemptNumber, options) || attemptNumber >= max) return err;\n            const newContext = Object.assign({}, context, {\n                options: Object.assign({}, options, {\n                    attemptNumber: attemptNumber + 1\n                })\n            });\n            return setTimeout(()=>context.channels.request.publish(newContext), retryDelay(attemptNumber)), null;\n        }\n    };\n};\nfunction getRetryDelay(attemptNum) {\n    return 100 * Math.pow(2, attemptNum) + Math.random() * 100;\n}\nconst retry = (opts = {})=>sharedRetry({\n        shouldRetry: defaultShouldRetry,\n        ...opts\n    });\nretry.shouldRetry = defaultShouldRetry;\nfunction encode(data) {\n    const query = new URLSearchParams(), nest = (name, _value)=>{\n        const value = _value instanceof Set ? Array.from(_value) : _value;\n        if (Array.isArray(value)) if (value.length) for(const index in value)nest(`${name}[${index}]`, value[index]);\n        else query.append(`${name}[]`, \"\");\n        else if (typeof value == \"object\" && value !== null) for (const [key, obj] of Object.entries(value))nest(`${name}[${key}]`, obj);\n        else query.append(name, value);\n    };\n    for (const [key, value] of Object.entries(data))nest(key, value);\n    return query.toString();\n}\nfunction urlEncoded() {\n    return {\n        processOptions: (options)=>{\n            const body = options.body;\n            return !body || !(typeof body.pipe != \"function\" && !isBuffer(body) && isPlainObject.isPlainObject(body)) ? options : {\n                ...options,\n                body: encode(options.body),\n                headers: {\n                    ...options.headers,\n                    \"Content-Type\": \"application/x-www-form-urlencoded\"\n                }\n            };\n        }\n    };\n}\nfunction buildKeepAlive(agent2) {\n    return function(config = {}) {\n        const ms = config.ms || 1e3, maxFree = config.maxFree || 256;\n        return agent2({\n            keepAlive: !0,\n            keepAliveMsecs: ms,\n            maxFreeSockets: maxFree\n        });\n    };\n}\nconst keepAlive = buildKeepAlive(agent);\nexports.processOptions = defaultOptionsValidator.processOptions;\nexports.validateOptions = defaultOptionsValidator.validateOptions;\nexports.Cancel = Cancel;\nexports.CancelToken = CancelToken;\nexports.agent = agent;\nexports.base = base;\nexports.debug = debug;\nexports.headers = headers;\nexports.httpErrors = httpErrors;\nexports.injectResponse = injectResponse;\nexports.jsonRequest = jsonRequest;\nexports.jsonResponse = jsonResponse;\nexports.keepAlive = keepAlive;\nexports.mtls = mtls;\nexports.observable = observable;\nexports.progress = progress;\nexports.promise = promise;\nexports.proxy = proxy;\nexports.retry = retry;\nexports.urlEncoded = urlEncoded; //# sourceMappingURL=middleware.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ2V0LWl0L2Rpc3QvbWlkZGxld2FyZS5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU8sQ0FBQztBQUFFLENBQUMsRUFBQztBQUMzRCxJQUFJQyxPQUFPQyxtQkFBT0EsQ0FBQyxrQkFBTSxHQUFHQyxRQUFRRCxtQkFBT0EsQ0FBQyxvQkFBTyxHQUFHRSxVQUFVRixtQkFBT0EsQ0FBQyxzREFBTyxHQUFHRywwQkFBMEJILG1CQUFPQSxDQUFDLHFJQUFnRCxHQUFHSSxnQkFBZ0JKLG1CQUFPQSxDQUFDLHFGQUFpQixHQUFHSyxpQkFBaUJMLG1CQUFPQSxDQUFDLHNFQUFpQixHQUFHTSxVQUFVTixtQkFBT0EsQ0FBQyx3RUFBa0I7QUFDcFMsU0FBU08sc0JBQXNCQyxDQUFDO0lBQzlCLE9BQU9BLEtBQUssT0FBT0EsS0FBSyxZQUFZLGFBQWFBLElBQUlBLElBQUk7UUFBRUMsU0FBU0Q7SUFBRTtBQUN4RTtBQUNBLElBQUlFLG1CQUFtQixhQUFhLEdBQUdILHNCQUFzQkwsVUFBVVMsMEJBQTBCLGFBQWEsR0FBR0osc0JBQXNCRixpQkFBaUJPLG1CQUFtQixhQUFhLEdBQUdMLHNCQUFzQkQ7QUFDak4sTUFBTU8sZUFBZTtBQUNyQixTQUFTQyxNQUFNQyxJQUFJO0lBQ2pCLE1BQU1DLFlBQVksSUFBSWpCLEtBQUtrQixLQUFLLENBQUNGLE9BQU9HLGFBQWEsSUFBSWpCLE1BQU1nQixLQUFLLENBQUNGLE9BQU9JLFNBQVM7UUFBRXBCLE1BQU1pQjtRQUFXZixPQUFPaUI7SUFBVztJQUMxSCxPQUFPO1FBQ0xFLGlCQUFpQixDQUFDQztZQUNoQixJQUFJQSxRQUFRUCxLQUFLLEVBQ2YsT0FBT087WUFDVCxJQUFJQSxRQUFRQyxZQUFZLEdBQUcsR0FDekIsT0FBTztnQkFBRSxHQUFHRCxPQUFPO2dCQUFFRjtZQUFPO1lBQzlCLE1BQU1JLFVBQVVWLGFBQWFXLElBQUksQ0FBQ0gsUUFBUUksSUFBSSxJQUFJ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QztBQUNmaEMsYUFBYSxHQUFHb0Q7QUFDaEJwRCxlQUFlLEdBQUdnRTtBQUNsQmhFLGtCQUFrQixHQUFHZ0c7QUFDckJoRyxzQkFBc0IsR0FBR2lHO0FBQ3pCakcsbUJBQW1CLEdBQUd5RztBQUN0QnpHLG9CQUFvQixHQUFHNkc7QUFDdkI3RyxpQkFBaUIsR0FBRzROO0FBQ3BCNU4sWUFBWSxHQUFHb0g7QUFDZnBILGtCQUFrQixHQUFHK0g7QUFDckIvSCxnQkFBZ0IsR0FBR3VJO0FBQ25CdkksZUFBZSxHQUFHZ0s7QUFDbEJoSyxhQUFhLEdBQUdzTDtBQUNoQnRMLGFBQWEsR0FBRzBNO0FBQ2hCMU0sa0JBQWtCLEdBQUd1TixZQUNyQix1Q0FBdUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9vbGktY3Jvc3NsYW5kLXZpZGVvZ3JhcGh5Ly4vbm9kZV9tb2R1bGVzL2dldC1pdC9kaXN0L21pZGRsZXdhcmUuY2pzPzBlYTYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pO1xudmFyIGh0dHAgPSByZXF1aXJlKFwiaHR0cFwiKSwgaHR0cHMgPSByZXF1aXJlKFwiaHR0cHNcIiksIGRlYnVnSXQgPSByZXF1aXJlKFwiZGVidWdcIiksIGRlZmF1bHRPcHRpb25zVmFsaWRhdG9yID0gcmVxdWlyZShcIi4vX2NodW5rcy9kZWZhdWx0T3B0aW9uc1ZhbGlkYXRvci1DWHdyTmptZS5janNcIiksIGlzUGxhaW5PYmplY3QgPSByZXF1aXJlKFwiaXMtcGxhaW4tb2JqZWN0XCIpLCBwcm9ncmVzc1N0cmVhbSA9IHJlcXVpcmUoXCJwcm9ncmVzcy1zdHJlYW1cIiksIGFsbG93ZWQgPSByZXF1aXJlKFwiaXMtcmV0cnktYWxsb3dlZFwiKTtcbmZ1bmN0aW9uIF9pbnRlcm9wRGVmYXVsdENvbXBhdChlKSB7XG4gIHJldHVybiBlICYmIHR5cGVvZiBlID09IFwib2JqZWN0XCIgJiYgXCJkZWZhdWx0XCIgaW4gZSA/IGUgOiB7IGRlZmF1bHQ6IGUgfTtcbn1cbnZhciBkZWJ1Z0l0X19kZWZhdWx0ID0gLyogQF9fUFVSRV9fICovIF9pbnRlcm9wRGVmYXVsdENvbXBhdChkZWJ1Z0l0KSwgcHJvZ3Jlc3NTdHJlYW1fX2RlZmF1bHQgPSAvKiBAX19QVVJFX18gKi8gX2ludGVyb3BEZWZhdWx0Q29tcGF0KHByb2dyZXNzU3RyZWFtKSwgYWxsb3dlZF9fZGVmYXVsdCA9IC8qIEBfX1BVUkVfXyAqLyBfaW50ZXJvcERlZmF1bHRDb21wYXQoYWxsb3dlZCk7XG5jb25zdCBpc0h0dHBzUHJvdG8gPSAvXmh0dHBzOi9pO1xuZnVuY3Rpb24gYWdlbnQob3B0cykge1xuICBjb25zdCBodHRwQWdlbnQgPSBuZXcgaHR0cC5BZ2VudChvcHRzKSwgaHR0cHNBZ2VudCA9IG5ldyBodHRwcy5BZ2VudChvcHRzKSwgYWdlbnRzID0geyBodHRwOiBodHRwQWdlbnQsIGh0dHBzOiBodHRwc0FnZW50IH07XG4gIHJldHVybiB7XG4gICAgZmluYWxpemVPcHRpb25zOiAob3B0aW9ucykgPT4ge1xuICAgICAgaWYgKG9wdGlvbnMuYWdlbnQpXG4gICAgICAgIHJldHVybiBvcHRpb25zO1xuICAgICAgaWYgKG9wdGlvbnMubWF4UmVkaXJlY3RzID4gMClcbiAgICAgICAgcmV0dXJuIHsgLi4ub3B0aW9ucywgYWdlbnRzIH07XG4gICAgICBjb25zdCBpc0h0dHBzID0gaXNIdHRwc1Byb3RvLnRlc3Qob3B0aW9ucy5ocmVmIHx8IG9wdGlvbnMucHJvdG9jb2wpO1xuICAgICAgcmV0dXJuIHsgLi4ub3B0aW9ucywgYWdlbnQ6IGlzSHR0cHMgPyBodHRwc0FnZW50IDogaHR0cEFnZW50IH07XG4gICAgfVxuICB9O1xufVxuY29uc3QgbGVhZGluZ1NsYXNoID0gL15cXC8vLCB0cmFpbGluZ1NsYXNoID0gL1xcLyQvO1xuZnVuY3Rpb24gYmFzZShiYXNlVXJsKSB7XG4gIGNvbnN0IGJhc2VVcmkgPSBiYXNlVXJsLnJlcGxhY2UodHJhaWxpbmdTbGFzaCwgXCJcIik7XG4gIHJldHVybiB7XG4gICAgcHJvY2Vzc09wdGlvbnM6IChvcHRpb25zKSA9PiB7XG4gICAgICBpZiAoL15odHRwcz86XFwvXFwvL2kudGVzdChvcHRpb25zLnVybCkpXG4gICAgICAgIHJldHVybiBvcHRpb25zO1xuICAgICAgY29uc3QgdXJsID0gW2Jhc2VVcmksIG9wdGlvbnMudXJsLnJlcGxhY2UobGVhZGluZ1NsYXNoLCBcIlwiKV0uam9pbihcIi9cIik7XG4gICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucywgeyB1cmwgfSk7XG4gICAgfVxuICB9O1xufVxuY29uc3QgU0VOU0lUSVZFX0hFQURFUlMgPSBbXCJjb29raWVcIiwgXCJhdXRob3JpemF0aW9uXCJdLCBoYXNPd24gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LCByZWRhY3RLZXlzID0gKHNvdXJjZSwgcmVkYWN0ZWQpID0+IHtcbiAgY29uc3QgdGFyZ2V0ID0ge307XG4gIGZvciAoY29uc3Qga2V5IGluIHNvdXJjZSlcbiAgICBoYXNPd24uY2FsbChzb3VyY2UsIGtleSkgJiYgKHRhcmdldFtrZXldID0gcmVkYWN0ZWQuaW5kZXhPZihrZXkudG9Mb3dlckNhc2UoKSkgPiAtMSA/IFwiPHJlZGFjdGVkPlwiIDogc291cmNlW2tleV0pO1xuICByZXR1cm4gdGFyZ2V0O1xufTtcbmZ1bmN0aW9uIGRlYnVnKG9wdHMgPSB7fSkge1xuICBjb25zdCB2ZXJib3NlID0gb3B0cy52ZXJib3NlLCBuYW1lc3BhY2UgPSBvcHRzLm5hbWVzcGFjZSB8fCBcImdldC1pdFwiLCBkZWZhdWx0TG9nZ2VyID0gZGVidWdJdF9fZGVmYXVsdC5kZWZhdWx0KG5hbWVzcGFjZSksIGxvZyA9IG9wdHMubG9nIHx8IGRlZmF1bHRMb2dnZXIsIHNob3J0Q2lyY3VpdCA9IGxvZyA9PT0gZGVmYXVsdExvZ2dlciAmJiAhZGVidWdJdF9fZGVmYXVsdC5kZWZhdWx0LmVuYWJsZWQobmFtZXNwYWNlKTtcbiAgbGV0IHJlcXVlc3RJZCA9IDA7XG4gIHJldHVybiB7XG4gICAgcHJvY2Vzc09wdGlvbnM6IChvcHRpb25zKSA9PiAob3B0aW9ucy5kZWJ1ZyA9IGxvZywgb3B0aW9ucy5yZXF1ZXN0SWQgPSBvcHRpb25zLnJlcXVlc3RJZCB8fCArK3JlcXVlc3RJZCwgb3B0aW9ucyksXG4gICAgb25SZXF1ZXN0OiAoZXZlbnQpID0+IHtcbiAgICAgIGlmIChzaG9ydENpcmN1aXQgfHwgIWV2ZW50KVxuICAgICAgICByZXR1cm4gZXZlbnQ7XG4gICAgICBjb25zdCBvcHRpb25zID0gZXZlbnQub3B0aW9ucztcbiAgICAgIGlmIChsb2coXCJbJXNdIEhUVFAgJXMgJXNcIiwgb3B0aW9ucy5yZXF1ZXN0SWQsIG9wdGlvbnMubWV0aG9kLCBvcHRpb25zLnVybCksIHZlcmJvc2UgJiYgb3B0aW9ucy5ib2R5ICYmIHR5cGVvZiBvcHRpb25zLmJvZHkgPT0gXCJzdHJpbmdcIiAmJiBsb2coXCJbJXNdIFJlcXVlc3QgYm9keTogJXNcIiwgb3B0aW9ucy5yZXF1ZXN0SWQsIG9wdGlvbnMuYm9keSksIHZlcmJvc2UgJiYgb3B0aW9ucy5oZWFkZXJzKSB7XG4gICAgICAgIGNvbnN0IGhlYWRlcnMyID0gb3B0cy5yZWRhY3RTZW5zaXRpdmVIZWFkZXJzID09PSAhMSA/IG9wdGlvbnMuaGVhZGVycyA6IHJlZGFjdEtleXMob3B0aW9ucy5oZWFkZXJzLCBTRU5TSVRJVkVfSEVBREVSUyk7XG4gICAgICAgIGxvZyhcIlslc10gUmVxdWVzdCBoZWFkZXJzOiAlc1wiLCBvcHRpb25zLnJlcXVlc3RJZCwgSlNPTi5zdHJpbmdpZnkoaGVhZGVyczIsIG51bGwsIDIpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBldmVudDtcbiAgICB9LFxuICAgIG9uUmVzcG9uc2U6IChyZXMsIGNvbnRleHQpID0+IHtcbiAgICAgIGlmIChzaG9ydENpcmN1aXQgfHwgIXJlcylcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgIGNvbnN0IHJlcUlkID0gY29udGV4dC5vcHRpb25zLnJlcXVlc3RJZDtcbiAgICAgIHJldHVybiBsb2coXCJbJXNdIFJlc3BvbnNlIGNvZGU6ICVzICVzXCIsIHJlcUlkLCByZXMuc3RhdHVzQ29kZSwgcmVzLnN0YXR1c01lc3NhZ2UpLCB2ZXJib3NlICYmIHJlcy5ib2R5ICYmIGxvZyhcIlslc10gUmVzcG9uc2UgYm9keTogJXNcIiwgcmVxSWQsIHN0cmluZ2lmeUJvZHkocmVzKSksIHJlcztcbiAgICB9LFxuICAgIG9uRXJyb3I6IChlcnIsIGNvbnRleHQpID0+IHtcbiAgICAgIGNvbnN0IHJlcUlkID0gY29udGV4dC5vcHRpb25zLnJlcXVlc3RJZDtcbiAgICAgIHJldHVybiBlcnIgPyAobG9nKFwiWyVzXSBFUlJPUjogJXNcIiwgcmVxSWQsIGVyci5tZXNzYWdlKSwgZXJyKSA6IChsb2coXCJbJXNdIEVycm9yIGVuY291bnRlcmVkLCBidXQgaGFuZGxlZCBieSBhbiBlYXJsaWVyIG1pZGRsZXdhcmVcIiwgcmVxSWQpLCBlcnIpO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIHN0cmluZ2lmeUJvZHkocmVzKSB7XG4gIHJldHVybiAocmVzLmhlYWRlcnNbXCJjb250ZW50LXR5cGVcIl0gfHwgXCJcIikudG9Mb3dlckNhc2UoKS5pbmRleE9mKFwiYXBwbGljYXRpb24vanNvblwiKSAhPT0gLTEgPyB0cnlGb3JtYXQocmVzLmJvZHkpIDogcmVzLmJvZHk7XG59XG5mdW5jdGlvbiB0cnlGb3JtYXQoYm9keSkge1xuICB0cnkge1xuICAgIGNvbnN0IHBhcnNlZCA9IHR5cGVvZiBib2R5ID09IFwic3RyaW5nXCIgPyBKU09OLnBhcnNlKGJvZHkpIDogYm9keTtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkocGFyc2VkLCBudWxsLCAyKTtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIGJvZHk7XG4gIH1cbn1cbmZ1bmN0aW9uIGhlYWRlcnMoX2hlYWRlcnMsIG9wdHMgPSB7fSkge1xuICByZXR1cm4ge1xuICAgIHByb2Nlc3NPcHRpb25zOiAob3B0aW9ucykgPT4ge1xuICAgICAgY29uc3QgZXhpc3RpbmcgPSBvcHRpb25zLmhlYWRlcnMgfHwge307XG4gICAgICByZXR1cm4gb3B0aW9ucy5oZWFkZXJzID0gb3B0cy5vdmVycmlkZSA/IE9iamVjdC5hc3NpZ24oe30sIGV4aXN0aW5nLCBfaGVhZGVycykgOiBPYmplY3QuYXNzaWduKHt9LCBfaGVhZGVycywgZXhpc3RpbmcpLCBvcHRpb25zO1xuICAgIH1cbiAgfTtcbn1cbmNsYXNzIEh0dHBFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IocmVzLCBjdHgpIHtcbiAgICBzdXBlcigpO1xuICAgIGNvbnN0IHRydW5jYXRlZFVybCA9IHJlcy51cmwubGVuZ3RoID4gNDAwID8gYCR7cmVzLnVybC5zbGljZSgwLCAzOTkpfVxcdTIwMjZgIDogcmVzLnVybDtcbiAgICBsZXQgbXNnID0gYCR7cmVzLm1ldGhvZH0tcmVxdWVzdCB0byAke3RydW5jYXRlZFVybH0gcmVzdWx0ZWQgaW4gYDtcbiAgICBtc2cgKz0gYEhUVFAgJHtyZXMuc3RhdHVzQ29kZX0gJHtyZXMuc3RhdHVzTWVzc2FnZX1gLCB0aGlzLm1lc3NhZ2UgPSBtc2cudHJpbSgpLCB0aGlzLnJlc3BvbnNlID0gcmVzLCB0aGlzLnJlcXVlc3QgPSBjdHgub3B0aW9ucztcbiAgfVxufVxuZnVuY3Rpb24gaHR0cEVycm9ycygpIHtcbiAgcmV0dXJuIHtcbiAgICBvblJlc3BvbnNlOiAocmVzLCBjdHgpID0+IHtcbiAgICAgIGlmICghKHJlcy5zdGF0dXNDb2RlID49IDQwMCkpXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgICB0aHJvdyBuZXcgSHR0cEVycm9yKHJlcywgY3R4KTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBpbmplY3RSZXNwb25zZShvcHRzID0ge30pIHtcbiAgaWYgKHR5cGVvZiBvcHRzLmluamVjdCAhPSBcImZ1bmN0aW9uXCIpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiYGluamVjdFJlc3BvbnNlYCBtaWRkbGV3YXJlIHJlcXVpcmVzIGEgYGluamVjdGAgZnVuY3Rpb25cIik7XG4gIHJldHVybiB7IGludGVyY2VwdFJlcXVlc3Q6IGZ1bmN0aW9uKHByZXZWYWx1ZSwgZXZlbnQpIHtcbiAgICBjb25zdCByZXNwb25zZSA9IG9wdHMuaW5qZWN0KGV2ZW50LCBwcmV2VmFsdWUpO1xuICAgIGlmICghcmVzcG9uc2UpXG4gICAgICByZXR1cm4gcHJldlZhbHVlO1xuICAgIGNvbnN0IG9wdGlvbnMgPSBldmVudC5jb250ZXh0Lm9wdGlvbnM7XG4gICAgcmV0dXJuIHtcbiAgICAgIGJvZHk6IFwiXCIsXG4gICAgICB1cmw6IG9wdGlvbnMudXJsLFxuICAgICAgbWV0aG9kOiBvcHRpb25zLm1ldGhvZCxcbiAgICAgIGhlYWRlcnM6IHt9LFxuICAgICAgc3RhdHVzQ29kZTogMjAwLFxuICAgICAgc3RhdHVzTWVzc2FnZTogXCJPS1wiLFxuICAgICAgLi4ucmVzcG9uc2VcbiAgICB9O1xuICB9IH07XG59XG5jb25zdCBpc0J1ZmZlciA9IHR5cGVvZiBCdWZmZXIgPiBcInVcIiA/ICgpID0+ICExIDogKG9iaikgPT4gQnVmZmVyLmlzQnVmZmVyKG9iaiksIHNlcmlhbGl6ZVR5cGVzID0gW1wiYm9vbGVhblwiLCBcInN0cmluZ1wiLCBcIm51bWJlclwiXTtcbmZ1bmN0aW9uIGpzb25SZXF1ZXN0KCkge1xuICByZXR1cm4ge1xuICAgIHByb2Nlc3NPcHRpb25zOiAob3B0aW9ucykgPT4ge1xuICAgICAgY29uc3QgYm9keSA9IG9wdGlvbnMuYm9keTtcbiAgICAgIHJldHVybiAhYm9keSB8fCAhKHR5cGVvZiBib2R5LnBpcGUgIT0gXCJmdW5jdGlvblwiICYmICFpc0J1ZmZlcihib2R5KSAmJiAoc2VyaWFsaXplVHlwZXMuaW5kZXhPZih0eXBlb2YgYm9keSkgIT09IC0xIHx8IEFycmF5LmlzQXJyYXkoYm9keSkgfHwgaXNQbGFpbk9iamVjdC5pc1BsYWluT2JqZWN0KGJvZHkpKSkgPyBvcHRpb25zIDogT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucywge1xuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShvcHRpb25zLmJvZHkpLFxuICAgICAgICBoZWFkZXJzOiBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLmhlYWRlcnMsIHtcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIlxuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24ganNvblJlc3BvbnNlKG9wdHMpIHtcbiAgcmV0dXJuIHtcbiAgICBvblJlc3BvbnNlOiAocmVzcG9uc2UpID0+IHtcbiAgICAgIGNvbnN0IGNvbnRlbnRUeXBlID0gcmVzcG9uc2UuaGVhZGVyc1tcImNvbnRlbnQtdHlwZVwiXSB8fCBcIlwiLCBzaG91bGREZWNvZGUgPSBvcHRzICYmIG9wdHMuZm9yY2UgfHwgY29udGVudFR5cGUuaW5kZXhPZihcImFwcGxpY2F0aW9uL2pzb25cIikgIT09IC0xO1xuICAgICAgcmV0dXJuICFyZXNwb25zZS5ib2R5IHx8ICFjb250ZW50VHlwZSB8fCAhc2hvdWxkRGVjb2RlID8gcmVzcG9uc2UgOiBPYmplY3QuYXNzaWduKHt9LCByZXNwb25zZSwgeyBib2R5OiB0cnlQYXJzZShyZXNwb25zZS5ib2R5KSB9KTtcbiAgICB9LFxuICAgIHByb2Nlc3NPcHRpb25zOiAob3B0aW9ucykgPT4gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucywge1xuICAgICAgaGVhZGVyczogT2JqZWN0LmFzc2lnbih7IEFjY2VwdDogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSwgb3B0aW9ucy5oZWFkZXJzKVxuICAgIH0pXG4gIH07XG4gIGZ1bmN0aW9uIHRyeVBhcnNlKGJvZHkpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIEpTT04ucGFyc2UoYm9keSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB0aHJvdyBlcnIubWVzc2FnZSA9IGBGYWlsZWQgdG8gcGFyc2VkIHJlc3BvbnNlIGJvZHkgYXMgSlNPTjogJHtlcnIubWVzc2FnZX1gLCBlcnI7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBpc0Jyb3dzZXJPcHRpb25zKG9wdGlvbnMpIHtcbiAgcmV0dXJuIHR5cGVvZiBvcHRpb25zID09IFwib2JqZWN0XCIgJiYgb3B0aW9ucyAhPT0gbnVsbCAmJiAhKFwicHJvdG9jb2xcIiBpbiBvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIG10bHMoY29uZmlnID0ge30pIHtcbiAgaWYgKCFjb25maWcuY2EpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdSZXF1aXJlZCBtdGxzIG9wdGlvbiBcImNhXCIgaXMgbWlzc2luZycpO1xuICBpZiAoIWNvbmZpZy5jZXJ0KVxuICAgIHRocm93IG5ldyBFcnJvcignUmVxdWlyZWQgbXRscyBvcHRpb24gXCJjZXJ0XCIgaXMgbWlzc2luZycpO1xuICBpZiAoIWNvbmZpZy5rZXkpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdSZXF1aXJlZCBtdGxzIG9wdGlvbiBcImtleVwiIGlzIG1pc3NpbmcnKTtcbiAgcmV0dXJuIHtcbiAgICBmaW5hbGl6ZU9wdGlvbnM6IChvcHRpb25zKSA9PiB7XG4gICAgICBpZiAoaXNCcm93c2VyT3B0aW9ucyhvcHRpb25zKSlcbiAgICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgICBjb25zdCBtdGxzT3B0cyA9IHtcbiAgICAgICAgY2VydDogY29uZmlnLmNlcnQsXG4gICAgICAgIGtleTogY29uZmlnLmtleSxcbiAgICAgICAgY2E6IGNvbmZpZy5jYVxuICAgICAgfTtcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLCBtdGxzT3B0cyk7XG4gICAgfVxuICB9O1xufVxubGV0IGFjdHVhbEdsb2JhbCA9IHt9O1xudHlwZW9mIGdsb2JhbFRoaXMgPCBcInVcIiA/IGFjdHVhbEdsb2JhbCA9IGdsb2JhbFRoaXMgOiB0eXBlb2Ygd2luZG93IDwgXCJ1XCIgPyBhY3R1YWxHbG9iYWwgPSB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsIDwgXCJ1XCIgPyBhY3R1YWxHbG9iYWwgPSBnbG9iYWwgOiB0eXBlb2Ygc2VsZiA8IFwidVwiICYmIChhY3R1YWxHbG9iYWwgPSBzZWxmKTtcbnZhciBnbG9iYWwkMSA9IGFjdHVhbEdsb2JhbDtcbmZ1bmN0aW9uIG9ic2VydmFibGUob3B0cyA9IHt9KSB7XG4gIGNvbnN0IE9ic2VydmFibGUgPSAoXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgLS0gQFRPRE8gY29uc2lkZXIgZHJvcHBpbmcgY2hlY2tpbmcgZm9yIGEgZ2xvYmFsIE9ic2VydmFibGUgc2luY2UgaXQncyBub3Qgb24gYSBzdGFuZGFyZHMgdHJhY2tcbiAgICBvcHRzLmltcGxlbWVudGF0aW9uIHx8IGdsb2JhbCQxLk9ic2VydmFibGVcbiAgKTtcbiAgaWYgKCFPYnNlcnZhYmxlKVxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiYE9ic2VydmFibGVgIGlzIG5vdCBhdmFpbGFibGUgaW4gZ2xvYmFsIHNjb3BlLCBhbmQgbm8gaW1wbGVtZW50YXRpb24gd2FzIHBhc3NlZFwiXG4gICAgKTtcbiAgcmV0dXJuIHtcbiAgICBvblJldHVybjogKGNoYW5uZWxzLCBjb250ZXh0KSA9PiBuZXcgT2JzZXJ2YWJsZSgob2JzZXJ2ZXIpID0+IChjaGFubmVscy5lcnJvci5zdWJzY3JpYmUoKGVycikgPT4gb2JzZXJ2ZXIuZXJyb3IoZXJyKSksIGNoYW5uZWxzLnByb2dyZXNzLnN1YnNjcmliZShcbiAgICAgIChldmVudCkgPT4gb2JzZXJ2ZXIubmV4dChPYmplY3QuYXNzaWduKHsgdHlwZTogXCJwcm9ncmVzc1wiIH0sIGV2ZW50KSlcbiAgICApLCBjaGFubmVscy5yZXNwb25zZS5zdWJzY3JpYmUoKHJlc3BvbnNlKSA9PiB7XG4gICAgICBvYnNlcnZlci5uZXh0KE9iamVjdC5hc3NpZ24oeyB0eXBlOiBcInJlc3BvbnNlXCIgfSwgcmVzcG9uc2UpKSwgb2JzZXJ2ZXIuY29tcGxldGUoKTtcbiAgICB9KSwgY2hhbm5lbHMucmVxdWVzdC5wdWJsaXNoKGNvbnRleHQpLCAoKSA9PiBjaGFubmVscy5hYm9ydC5wdWJsaXNoKCkpKVxuICB9O1xufVxuZnVuY3Rpb24gbm9ybWFsaXplcihzdGFnZSkge1xuICByZXR1cm4gKHByb2cpID0+ICh7XG4gICAgc3RhZ2UsXG4gICAgcGVyY2VudDogcHJvZy5wZXJjZW50YWdlLFxuICAgIHRvdGFsOiBwcm9nLmxlbmd0aCxcbiAgICBsb2FkZWQ6IHByb2cudHJhbnNmZXJyZWQsXG4gICAgbGVuZ3RoQ29tcHV0YWJsZTogIShwcm9nLmxlbmd0aCA9PT0gMCAmJiBwcm9nLnBlcmNlbnRhZ2UgPT09IDApXG4gIH0pO1xufVxuZnVuY3Rpb24gcHJvZ3Jlc3MoKSB7XG4gIHJldHVybiB7XG4gICAgb25IZWFkZXJzOiAocmVzcG9uc2UsIGV2dCkgPT4ge1xuICAgICAgY29uc3QgX3Byb2dyZXNzID0gcHJvZ3Jlc3NTdHJlYW1fX2RlZmF1bHQuZGVmYXVsdCh7IHRpbWU6IDE2IH0pLCBub3JtYWxpemUgPSBub3JtYWxpemVyKFwiZG93bmxvYWRcIiksIGNvbnRlbnRMZW5ndGggPSByZXNwb25zZS5oZWFkZXJzW1wiY29udGVudC1sZW5ndGhcIl0sIGxlbmd0aCA9IGNvbnRlbnRMZW5ndGggPyBOdW1iZXIoY29udGVudExlbmd0aCkgOiAwO1xuICAgICAgcmV0dXJuICFpc05hTihsZW5ndGgpICYmIGxlbmd0aCA+IDAgJiYgX3Byb2dyZXNzLnNldExlbmd0aChsZW5ndGgpLCBfcHJvZ3Jlc3Mub24oXCJwcm9ncmVzc1wiLCAocHJvZykgPT4gZXZ0LmNvbnRleHQuY2hhbm5lbHMucHJvZ3Jlc3MucHVibGlzaChub3JtYWxpemUocHJvZykpKSwgcmVzcG9uc2UucGlwZShfcHJvZ3Jlc3MpO1xuICAgIH0sXG4gICAgb25SZXF1ZXN0OiAoZXZ0KSA9PiB7XG4gICAgICBpZiAoIWV2dC5wcm9ncmVzcylcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3Qgbm9ybWFsaXplID0gbm9ybWFsaXplcihcInVwbG9hZFwiKTtcbiAgICAgIGV2dC5wcm9ncmVzcy5vbihcbiAgICAgICAgXCJwcm9ncmVzc1wiLFxuICAgICAgICAocHJvZykgPT4gZXZ0LmNvbnRleHQuY2hhbm5lbHMucHJvZ3Jlc3MucHVibGlzaChub3JtYWxpemUocHJvZykpXG4gICAgICApO1xuICAgIH1cbiAgfTtcbn1cbmNvbnN0IHByb21pc2UgPSAob3B0aW9ucyA9IHt9KSA9PiB7XG4gIGNvbnN0IFByb21pc2VJbXBsZW1lbnRhdGlvbiA9IG9wdGlvbnMuaW1wbGVtZW50YXRpb24gfHwgUHJvbWlzZTtcbiAgaWYgKCFQcm9taXNlSW1wbGVtZW50YXRpb24pXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiYFByb21pc2VgIGlzIG5vdCBhdmFpbGFibGUgaW4gZ2xvYmFsIHNjb3BlLCBhbmQgbm8gaW1wbGVtZW50YXRpb24gd2FzIHBhc3NlZFwiKTtcbiAgcmV0dXJuIHtcbiAgICBvblJldHVybjogKGNoYW5uZWxzLCBjb250ZXh0KSA9PiBuZXcgUHJvbWlzZUltcGxlbWVudGF0aW9uKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IGNhbmNlbCA9IGNvbnRleHQub3B0aW9ucy5jYW5jZWxUb2tlbjtcbiAgICAgIGNhbmNlbCAmJiBjYW5jZWwucHJvbWlzZS50aGVuKChyZWFzb24pID0+IHtcbiAgICAgICAgY2hhbm5lbHMuYWJvcnQucHVibGlzaChyZWFzb24pLCByZWplY3QocmVhc29uKTtcbiAgICAgIH0pLCBjaGFubmVscy5lcnJvci5zdWJzY3JpYmUocmVqZWN0KSwgY2hhbm5lbHMucmVzcG9uc2Uuc3Vic2NyaWJlKChyZXNwb25zZSkgPT4ge1xuICAgICAgICByZXNvbHZlKG9wdGlvbnMub25seUJvZHkgPyByZXNwb25zZS5ib2R5IDogcmVzcG9uc2UpO1xuICAgICAgfSksIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNoYW5uZWxzLnJlcXVlc3QucHVibGlzaChjb250ZXh0KTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgIH1cbiAgICAgIH0sIDApO1xuICAgIH0pXG4gIH07XG59O1xuY2xhc3MgQ2FuY2VsIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgIHRoaXMuX19DQU5DRUxfXyA9ICEwLCB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBgQ2FuY2VsJHt0aGlzLm1lc3NhZ2UgPyBgOiAke3RoaXMubWVzc2FnZX1gIDogXCJcIn1gO1xuICB9XG59XG5jb25zdCBfQ2FuY2VsVG9rZW4gPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGV4ZWN1dG9yKSB7XG4gICAgaWYgKHR5cGVvZiBleGVjdXRvciAhPSBcImZ1bmN0aW9uXCIpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiZXhlY3V0b3IgbXVzdCBiZSBhIGZ1bmN0aW9uLlwiKTtcbiAgICBsZXQgcmVzb2x2ZVByb21pc2UgPSBudWxsO1xuICAgIHRoaXMucHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICByZXNvbHZlUHJvbWlzZSA9IHJlc29sdmU7XG4gICAgfSksIGV4ZWN1dG9yKChtZXNzYWdlKSA9PiB7XG4gICAgICB0aGlzLnJlYXNvbiB8fCAodGhpcy5yZWFzb24gPSBuZXcgQ2FuY2VsKG1lc3NhZ2UpLCByZXNvbHZlUHJvbWlzZSh0aGlzLnJlYXNvbikpO1xuICAgIH0pO1xuICB9XG59O1xuX0NhbmNlbFRva2VuLnNvdXJjZSA9ICgpID0+IHtcbiAgbGV0IGNhbmNlbDtcbiAgcmV0dXJuIHtcbiAgICB0b2tlbjogbmV3IF9DYW5jZWxUb2tlbigoY2FuKSA9PiB7XG4gICAgICBjYW5jZWwgPSBjYW47XG4gICAgfSksXG4gICAgY2FuY2VsXG4gIH07XG59O1xubGV0IENhbmNlbFRva2VuID0gX0NhbmNlbFRva2VuO1xuY29uc3QgaXNDYW5jZWwgPSAodmFsdWUpID0+ICEhKHZhbHVlICYmIHZhbHVlICE9IG51bGwgJiYgdmFsdWUuX19DQU5DRUxfXyk7XG5wcm9taXNlLkNhbmNlbCA9IENhbmNlbDtcbnByb21pc2UuQ2FuY2VsVG9rZW4gPSBDYW5jZWxUb2tlbjtcbnByb21pc2UuaXNDYW5jZWwgPSBpc0NhbmNlbDtcbmZ1bmN0aW9uIHByb3h5KF9wcm94eSkge1xuICBpZiAoX3Byb3h5ICE9PSAhMSAmJiAoIV9wcm94eSB8fCAhX3Byb3h5Lmhvc3QpKVxuICAgIHRocm93IG5ldyBFcnJvcihcIlByb3h5IG1pZGRsZXdhcmUgdGFrZXMgYW4gb2JqZWN0IG9mIGhvc3QsIHBvcnQgYW5kIGF1dGggcHJvcGVydGllc1wiKTtcbiAgcmV0dXJuIHtcbiAgICBwcm9jZXNzT3B0aW9uczogKG9wdGlvbnMpID0+IE9iamVjdC5hc3NpZ24oeyBwcm94eTogX3Byb3h5IH0sIG9wdGlvbnMpXG4gIH07XG59XG52YXIgZGVmYXVsdFNob3VsZFJldHJ5ID0gKGVyciwgbnVtLCBvcHRpb25zKSA9PiBvcHRpb25zLm1ldGhvZCAhPT0gXCJHRVRcIiAmJiBvcHRpb25zLm1ldGhvZCAhPT0gXCJIRUFEXCIgfHwgZXJyLnJlc3BvbnNlICYmIGVyci5yZXNwb25zZS5zdGF0dXNDb2RlID8gITEgOiBhbGxvd2VkX19kZWZhdWx0LmRlZmF1bHQoZXJyKTtcbmNvbnN0IGlzU3RyZWFtID0gKHN0cmVhbSkgPT4gc3RyZWFtICE9PSBudWxsICYmIHR5cGVvZiBzdHJlYW0gPT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygc3RyZWFtLnBpcGUgPT0gXCJmdW5jdGlvblwiO1xudmFyIHNoYXJlZFJldHJ5ID0gKG9wdHMpID0+IHtcbiAgY29uc3QgbWF4UmV0cmllcyA9IG9wdHMubWF4UmV0cmllcyB8fCA1LCByZXRyeURlbGF5ID0gb3B0cy5yZXRyeURlbGF5IHx8IGdldFJldHJ5RGVsYXksIGFsbG93UmV0cnkgPSBvcHRzLnNob3VsZFJldHJ5O1xuICByZXR1cm4ge1xuICAgIG9uRXJyb3I6IChlcnIsIGNvbnRleHQpID0+IHtcbiAgICAgIGNvbnN0IG9wdGlvbnMgPSBjb250ZXh0Lm9wdGlvbnMsIG1heCA9IG9wdGlvbnMubWF4UmV0cmllcyB8fCBtYXhSZXRyaWVzLCBzaG91bGRSZXRyeSA9IG9wdGlvbnMuc2hvdWxkUmV0cnkgfHwgYWxsb3dSZXRyeSwgYXR0ZW1wdE51bWJlciA9IG9wdGlvbnMuYXR0ZW1wdE51bWJlciB8fCAwO1xuICAgICAgaWYgKGlzU3RyZWFtKG9wdGlvbnMuYm9keSkgfHwgIXNob3VsZFJldHJ5KGVyciwgYXR0ZW1wdE51bWJlciwgb3B0aW9ucykgfHwgYXR0ZW1wdE51bWJlciA+PSBtYXgpXG4gICAgICAgIHJldHVybiBlcnI7XG4gICAgICBjb25zdCBuZXdDb250ZXh0ID0gT2JqZWN0LmFzc2lnbih7fSwgY29udGV4dCwge1xuICAgICAgICBvcHRpb25zOiBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLCB7IGF0dGVtcHROdW1iZXI6IGF0dGVtcHROdW1iZXIgKyAxIH0pXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBzZXRUaW1lb3V0KCgpID0+IGNvbnRleHQuY2hhbm5lbHMucmVxdWVzdC5wdWJsaXNoKG5ld0NvbnRleHQpLCByZXRyeURlbGF5KGF0dGVtcHROdW1iZXIpKSwgbnVsbDtcbiAgICB9XG4gIH07XG59O1xuZnVuY3Rpb24gZ2V0UmV0cnlEZWxheShhdHRlbXB0TnVtKSB7XG4gIHJldHVybiAxMDAgKiBNYXRoLnBvdygyLCBhdHRlbXB0TnVtKSArIE1hdGgucmFuZG9tKCkgKiAxMDA7XG59XG5jb25zdCByZXRyeSA9IChvcHRzID0ge30pID0+IHNoYXJlZFJldHJ5KHsgc2hvdWxkUmV0cnk6IGRlZmF1bHRTaG91bGRSZXRyeSwgLi4ub3B0cyB9KTtcbnJldHJ5LnNob3VsZFJldHJ5ID0gZGVmYXVsdFNob3VsZFJldHJ5O1xuZnVuY3Rpb24gZW5jb2RlKGRhdGEpIHtcbiAgY29uc3QgcXVlcnkgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCksIG5lc3QgPSAobmFtZSwgX3ZhbHVlKSA9PiB7XG4gICAgY29uc3QgdmFsdWUgPSBfdmFsdWUgaW5zdGFuY2VvZiBTZXQgPyBBcnJheS5mcm9tKF92YWx1ZSkgOiBfdmFsdWU7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKVxuICAgICAgaWYgKHZhbHVlLmxlbmd0aClcbiAgICAgICAgZm9yIChjb25zdCBpbmRleCBpbiB2YWx1ZSlcbiAgICAgICAgICBuZXN0KGAke25hbWV9WyR7aW5kZXh9XWAsIHZhbHVlW2luZGV4XSk7XG4gICAgICBlbHNlXG4gICAgICAgIHF1ZXJ5LmFwcGVuZChgJHtuYW1lfVtdYCwgXCJcIik7XG4gICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09IFwib2JqZWN0XCIgJiYgdmFsdWUgIT09IG51bGwpXG4gICAgICBmb3IgKGNvbnN0IFtrZXksIG9ial0gb2YgT2JqZWN0LmVudHJpZXModmFsdWUpKVxuICAgICAgICBuZXN0KGAke25hbWV9WyR7a2V5fV1gLCBvYmopO1xuICAgIGVsc2VcbiAgICAgIHF1ZXJ5LmFwcGVuZChuYW1lLCB2YWx1ZSk7XG4gIH07XG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGRhdGEpKVxuICAgIG5lc3Qoa2V5LCB2YWx1ZSk7XG4gIHJldHVybiBxdWVyeS50b1N0cmluZygpO1xufVxuZnVuY3Rpb24gdXJsRW5jb2RlZCgpIHtcbiAgcmV0dXJuIHtcbiAgICBwcm9jZXNzT3B0aW9uczogKG9wdGlvbnMpID0+IHtcbiAgICAgIGNvbnN0IGJvZHkgPSBvcHRpb25zLmJvZHk7XG4gICAgICByZXR1cm4gIWJvZHkgfHwgISh0eXBlb2YgYm9keS5waXBlICE9IFwiZnVuY3Rpb25cIiAmJiAhaXNCdWZmZXIoYm9keSkgJiYgaXNQbGFpbk9iamVjdC5pc1BsYWluT2JqZWN0KGJvZHkpKSA/IG9wdGlvbnMgOiB7XG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIGJvZHk6IGVuY29kZShvcHRpb25zLmJvZHkpLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgLi4ub3B0aW9ucy5oZWFkZXJzLFxuICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCJcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBidWlsZEtlZXBBbGl2ZShhZ2VudDIpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGNvbmZpZyA9IHt9KSB7XG4gICAgY29uc3QgbXMgPSBjb25maWcubXMgfHwgMWUzLCBtYXhGcmVlID0gY29uZmlnLm1heEZyZWUgfHwgMjU2O1xuICAgIHJldHVybiBhZ2VudDIoe1xuICAgICAga2VlcEFsaXZlOiAhMCxcbiAgICAgIGtlZXBBbGl2ZU1zZWNzOiBtcyxcbiAgICAgIG1heEZyZWVTb2NrZXRzOiBtYXhGcmVlXG4gICAgfSk7XG4gIH07XG59XG5jb25zdCBrZWVwQWxpdmUgPSBidWlsZEtlZXBBbGl2ZShhZ2VudCk7XG5leHBvcnRzLnByb2Nlc3NPcHRpb25zID0gZGVmYXVsdE9wdGlvbnNWYWxpZGF0b3IucHJvY2Vzc09wdGlvbnM7XG5leHBvcnRzLnZhbGlkYXRlT3B0aW9ucyA9IGRlZmF1bHRPcHRpb25zVmFsaWRhdG9yLnZhbGlkYXRlT3B0aW9ucztcbmV4cG9ydHMuQ2FuY2VsID0gQ2FuY2VsO1xuZXhwb3J0cy5DYW5jZWxUb2tlbiA9IENhbmNlbFRva2VuO1xuZXhwb3J0cy5hZ2VudCA9IGFnZW50O1xuZXhwb3J0cy5iYXNlID0gYmFzZTtcbmV4cG9ydHMuZGVidWcgPSBkZWJ1ZztcbmV4cG9ydHMuaGVhZGVycyA9IGhlYWRlcnM7XG5leHBvcnRzLmh0dHBFcnJvcnMgPSBodHRwRXJyb3JzO1xuZXhwb3J0cy5pbmplY3RSZXNwb25zZSA9IGluamVjdFJlc3BvbnNlO1xuZXhwb3J0cy5qc29uUmVxdWVzdCA9IGpzb25SZXF1ZXN0O1xuZXhwb3J0cy5qc29uUmVzcG9uc2UgPSBqc29uUmVzcG9uc2U7XG5leHBvcnRzLmtlZXBBbGl2ZSA9IGtlZXBBbGl2ZTtcbmV4cG9ydHMubXRscyA9IG10bHM7XG5leHBvcnRzLm9ic2VydmFibGUgPSBvYnNlcnZhYmxlO1xuZXhwb3J0cy5wcm9ncmVzcyA9IHByb2dyZXNzO1xuZXhwb3J0cy5wcm9taXNlID0gcHJvbWlzZTtcbmV4cG9ydHMucHJveHkgPSBwcm94eTtcbmV4cG9ydHMucmV0cnkgPSByZXRyeTtcbmV4cG9ydHMudXJsRW5jb2RlZCA9IHVybEVuY29kZWQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1taWRkbGV3YXJlLmNqcy5tYXBcbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImh0dHAiLCJyZXF1aXJlIiwiaHR0cHMiLCJkZWJ1Z0l0IiwiZGVmYXVsdE9wdGlvbnNWYWxpZGF0b3IiLCJpc1BsYWluT2JqZWN0IiwicHJvZ3Jlc3NTdHJlYW0iLCJhbGxvd2VkIiwiX2ludGVyb3BEZWZhdWx0Q29tcGF0IiwiZSIsImRlZmF1bHQiLCJkZWJ1Z0l0X19kZWZhdWx0IiwicHJvZ3Jlc3NTdHJlYW1fX2RlZmF1bHQiLCJhbGxvd2VkX19kZWZhdWx0IiwiaXNIdHRwc1Byb3RvIiwiYWdlbnQiLCJvcHRzIiwiaHR0cEFnZW50IiwiQWdlbnQiLCJodHRwc0FnZW50IiwiYWdlbnRzIiwiZmluYWxpemVPcHRpb25zIiwib3B0aW9ucyIsIm1heFJlZGlyZWN0cyIsImlzSHR0cHMiLCJ0ZXN0IiwiaHJlZiIsInByb3RvY29sIiwibGVhZGluZ1NsYXNoIiwidHJhaWxpbmdTbGFzaCIsImJhc2UiLCJiYXNlVXJsIiwiYmFzZVVyaSIsInJlcGxhY2UiLCJwcm9jZXNzT3B0aW9ucyIsInVybCIsImpvaW4iLCJhc3NpZ24iLCJTRU5TSVRJVkVfSEVBREVSUyIsImhhc093biIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwicmVkYWN0S2V5cyIsInNvdXJjZSIsInJlZGFjdGVkIiwidGFyZ2V0Iiwia2V5IiwiY2FsbCIsImluZGV4T2YiLCJ0b0xvd2VyQ2FzZSIsImRlYnVnIiwidmVyYm9zZSIsIm5hbWVzcGFjZSIsImRlZmF1bHRMb2dnZXIiLCJsb2ciLCJzaG9ydENpcmN1aXQiLCJlbmFibGVkIiwicmVxdWVzdElkIiwib25SZXF1ZXN0IiwiZXZlbnQiLCJtZXRob2QiLCJib2R5IiwiaGVhZGVycyIsImhlYWRlcnMyIiwicmVkYWN0U2Vuc2l0aXZlSGVhZGVycyIsIkpTT04iLCJzdHJpbmdpZnkiLCJvblJlc3BvbnNlIiwicmVzIiwiY29udGV4dCIsInJlcUlkIiwic3RhdHVzQ29kZSIsInN0YXR1c01lc3NhZ2UiLCJzdHJpbmdpZnlCb2R5Iiwib25FcnJvciIsImVyciIsIm1lc3NhZ2UiLCJ0cnlGb3JtYXQiLCJwYXJzZWQiLCJwYXJzZSIsIl9oZWFkZXJzIiwiZXhpc3RpbmciLCJvdmVycmlkZSIsIkh0dHBFcnJvciIsIkVycm9yIiwiY29uc3RydWN0b3IiLCJjdHgiLCJ0cnVuY2F0ZWRVcmwiLCJsZW5ndGgiLCJzbGljZSIsIm1zZyIsInRyaW0iLCJyZXNwb25zZSIsInJlcXVlc3QiLCJodHRwRXJyb3JzIiwiaW5qZWN0UmVzcG9uc2UiLCJpbmplY3QiLCJpbnRlcmNlcHRSZXF1ZXN0IiwicHJldlZhbHVlIiwiaXNCdWZmZXIiLCJCdWZmZXIiLCJvYmoiLCJzZXJpYWxpemVUeXBlcyIsImpzb25SZXF1ZXN0IiwicGlwZSIsIkFycmF5IiwiaXNBcnJheSIsImpzb25SZXNwb25zZSIsImNvbnRlbnRUeXBlIiwic2hvdWxkRGVjb2RlIiwiZm9yY2UiLCJ0cnlQYXJzZSIsIkFjY2VwdCIsImlzQnJvd3Nlck9wdGlvbnMiLCJtdGxzIiwiY29uZmlnIiwiY2EiLCJjZXJ0IiwibXRsc09wdHMiLCJhY3R1YWxHbG9iYWwiLCJnbG9iYWxUaGlzIiwid2luZG93IiwiZ2xvYmFsIiwic2VsZiIsImdsb2JhbCQxIiwib2JzZXJ2YWJsZSIsIk9ic2VydmFibGUiLCJpbXBsZW1lbnRhdGlvbiIsIm9uUmV0dXJuIiwiY2hhbm5lbHMiLCJvYnNlcnZlciIsImVycm9yIiwic3Vic2NyaWJlIiwicHJvZ3Jlc3MiLCJuZXh0IiwidHlwZSIsImNvbXBsZXRlIiwicHVibGlzaCIsImFib3J0Iiwibm9ybWFsaXplciIsInN0YWdlIiwicHJvZyIsInBlcmNlbnQiLCJwZXJjZW50YWdlIiwidG90YWwiLCJsb2FkZWQiLCJ0cmFuc2ZlcnJlZCIsImxlbmd0aENvbXB1dGFibGUiLCJvbkhlYWRlcnMiLCJldnQiLCJfcHJvZ3Jlc3MiLCJ0aW1lIiwibm9ybWFsaXplIiwiY29udGVudExlbmd0aCIsIk51bWJlciIsImlzTmFOIiwic2V0TGVuZ3RoIiwib24iLCJwcm9taXNlIiwiUHJvbWlzZUltcGxlbWVudGF0aW9uIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJjYW5jZWwiLCJjYW5jZWxUb2tlbiIsInRoZW4iLCJyZWFzb24iLCJvbmx5Qm9keSIsInNldFRpbWVvdXQiLCJDYW5jZWwiLCJfX0NBTkNFTF9fIiwidG9TdHJpbmciLCJfQ2FuY2VsVG9rZW4iLCJleGVjdXRvciIsIlR5cGVFcnJvciIsInJlc29sdmVQcm9taXNlIiwidG9rZW4iLCJjYW4iLCJDYW5jZWxUb2tlbiIsImlzQ2FuY2VsIiwicHJveHkiLCJfcHJveHkiLCJob3N0IiwiZGVmYXVsdFNob3VsZFJldHJ5IiwibnVtIiwiaXNTdHJlYW0iLCJzdHJlYW0iLCJzaGFyZWRSZXRyeSIsIm1heFJldHJpZXMiLCJyZXRyeURlbGF5IiwiZ2V0UmV0cnlEZWxheSIsImFsbG93UmV0cnkiLCJzaG91bGRSZXRyeSIsIm1heCIsImF0dGVtcHROdW1iZXIiLCJuZXdDb250ZXh0IiwiYXR0ZW1wdE51bSIsIk1hdGgiLCJwb3ciLCJyYW5kb20iLCJyZXRyeSIsImVuY29kZSIsImRhdGEiLCJxdWVyeSIsIlVSTFNlYXJjaFBhcmFtcyIsIm5lc3QiLCJuYW1lIiwiX3ZhbHVlIiwiU2V0IiwiZnJvbSIsImluZGV4IiwiYXBwZW5kIiwiZW50cmllcyIsInVybEVuY29kZWQiLCJidWlsZEtlZXBBbGl2ZSIsImFnZW50MiIsIm1zIiwibWF4RnJlZSIsImtlZXBBbGl2ZSIsImtlZXBBbGl2ZU1zZWNzIiwibWF4RnJlZVNvY2tldHMiLCJ2YWxpZGF0ZU9wdGlvbnMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/get-it/dist/middleware.cjs\n");

/***/ })

};
;